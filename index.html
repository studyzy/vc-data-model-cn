<!DOCTYPE html>
<html>

<head>
  <title>Verifiable Credentials Data Model v2.0</title>
  <meta http-equiv='Content-Type' content='text/html;charset=utf-8' />
  <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
  <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
  <script src="./common.js" class="remove"></script>
  <script class="remove" src="https://cdn.jsdelivr.net/gh/digitalbazaar/respec-vc@2.0.1/dist/main.js"></script>
  <script class="removeOnSave" src="https://unpkg.com/reqlist/lib/reqlist.js"></script>
  <link class="removeOnSave" rel="stylesheet" type="text/css" href="https://unpkg.com/reqlist/lib/reqlist.css" />

  <script class="remove">
    var respecConfig = {
      group: "vc",

      // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus: "CRD",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "vc-data-model-2.0",

      // subtitle for the spec
      //subtitle: "Expressing information with verifiable provenance",

      // if you wish the publication date to be other than today, set this
      //publishDate: "2024-01-23",
      crEnd: "2024-03-23",
      //prEnd: "2019-10-01",
      implementationReportURI: "https://w3c.github.io/vc-data-model-2.0-test-suite/",
      //errata: "https://w3c.github.io/vc-data-model/errata.html",
      previousMaturity: "REC",
      previousPublishDate: "2022-03-03",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate:  "1977-03-15",
      // previousMaturity:  "WD",

      // extend the bibliography entries
      localBiblio: vcwg.localBiblio,
      doJsonLd: true,

      // Uncomment these to use the respec extension that generates a list of
      //   normative statements:
      preProcess: [/*prepare_reqlist*/],
      postProcess: [
        restrictRefs,
        window.respecVc.createVcExamples
        /*add_reqlist_button*/
      ],

      github: "https://github.com/w3c/vc-data-model/",
      includePermalinks: false,

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI: "https://w3c.github.io/vc-data-model/",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      // editors, add as many as you like
      // only "name" is required
      editors: [
        {
          name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          note: "v1.0, v1.1, v2.0", w3cid: 41758
        },
        {
          name: "Ted Thibodeau Jr", url: "https://github.com/TallTed",
          company: "OpenLink Software", companyURL: "https://www.openlinksw.com/",
          note: "v2.0", w3cid: 42501
        },
        {
          name: "Ivan Herman", url: "https://www.w3.org/People/Ivan/",
          company: "W3C", companyURL: "https://www.w3.org",
          note: "v2.0", w3cid: 7382, orcid: "0000-0003-0782-2704"
        },
        {
          name: "Michael B. Jones", url: "https://self-issued.info/",
          company: "Invited Expert",
          note: "v2.0", w3cid: 38745
        },
        {
          name: "Gabe Cohen", url: "https://github.com/decentralgabe",
          company: "Block", companyURL: "https://block.xyz/",
          note: "v2.0", w3cid: 116851
        },
      ],
      formerEditors: [
        {
          name: "Grant Noble", url: "https://www.linkedin.com/in/grant-noble-8253994a/",
          company: "ConsenSys", companyURL: "https://consensys.net/",
          note: "v1.0", w3cid: 110600
        },
        {
          name: "Dave Longley", url: "https://github.com/dlongley",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          note: "v1.0", w3cid: 48025
        },
        {
          name: "Daniel C. Burnett", url: "https://www.linkedin.com/in/daburnett/",
          company: "ConsenSys", companyURL: "https://consensys.net/",
          note: "v1.0", w3cid: 37473
        },
        {
          name: "Brent Zundel", url: "https://www.linkedin.com/in/bzundel/",
          company: "Evernym", companyURL: "https://www.evernym.com/",
          note: "v1.0", w3cid: 102128
        },
        {
          name: "Kyle Den Hartog", url: "https://www.linkedin.com/in/kyledenhartog/",
          company: "MATTR", companyURL: "https://mattr.global/",
          note: "v1.1", w3cid: 103517
        },
        {
          name: "Orie Steele", url: "https://github.com/OR13",
          company: "Transmute",
          companyURL: "https://transmute.industries/",
          note: "v2.0", w3cid: 109171
        },
        {
          name: "Oliver Terbu", url: "https://github.com/awoie",
          company: "Spruce Systems", companyURL: "https://spruceid.com/",
          note: "v2.0", w3cid: 110059
        }
      ],
      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:
        [
          {
            name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 41758
          },
          {
            name: "Dave Longley", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 48025
          },
          {
            name: "David Chadwick",
            url: "https://www.linkedin.com/in/davidwchadwick/",
            company: "Crossword Cybersecurity PLC",
            companyURL: "https://www.crosswordcybersecurity.com/",
            w3cid: 46156
          },
          {
            name: "Orie Steele", url: "https://github.com/OR13",
            company: "Transmute",
            companyURL: "https://www.transmute.industries/",
            note: "v2.0", w3cid: 109171
          }
        ],
      xref: ["URL", "I18N-GLOSSARY", "INFRA"],
      lint: { "informative-dfn": false },
      maxTocLevel: 2,
      inlineCSS: true
    };
  </script>
  <style>
    code {
      color: rgb(199, 73, 0);
      font-weight: bold;
    }

    pre {
      overflow-x: auto;
      white-space: pre-wrap;
    }

    pre .highlight {
      font-weight: bold;
      color: Green;
    }

    pre .subject {
      font-weight: bold;
      color: RoyalBlue;
    }

    pre .property {
      font-weight: bold;
      color: DarkGoldenrod;
    }

    pre .comment {
      font-weight: bold;
      color: SteelBlue;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    ol.algorithm {
      counter-reset: numsection;
      list-style-type: none;
    }

    ol.algorithm li {
      margin: 0.5em 0;
    }

    ol.algorithm li:before {
      font-weight: bold;
      counter-increment: numsection;
      content: counters(numsection, ".") ") ";
    }
  </style>
</head>

<body>
  <section id='abstract'>
    <p>
      [=凭证=]是我们日常生活的一部分；驾驶执照用于证明我们有驾驶汽车的能力，大学学位可以用来证明我们的教育水平，政府颁发的护照使我们能够在各国之间旅行。这个规范提供了一种在网络上表达这些类型的[=凭证=]的机制，这种机制是加密安全的，尊重隐私，且可由机器验证。
    </p>
  </section>

  <section id='sotd'>
    <p>
      工作组正在积极寻求对此规范的实施反馈。为了退出候选推荐阶段，工作组已设定了每个规范中的每个强制性功能至少需要两个独立实施的要求。请查看<a
        href="https://w3c.github.io/vc-data-model-2.0-test-suite/">
        实施报告</a>以获取更多详细信息。
    </p>

    <p>
      欢迎随时对此规范提出评论。
      请直接在
      <a href="https://github.com/w3c/vc-data-model/issues/">GitHub</a>上提交问题，
      或者，如果无法做到这一点，请发送到
      <a href="mailto:public-vc-comments@w3.org">public-vc-comments@w3.org</a>
      (<a href="mailto:public-vc-comments-request@w3.org?subject=subscribe">订阅</a>,
      <a href="https://lists.w3.org/Archives/Public/public-vc-comments/">档案</a>)。
    </p>

  </section>

  <section class="informative">
    <h2>简介</h2>

    <p>
      凭证是我们日常生活的一部分；驾驶执照用于证明我们有能力操作机动车辆，大学学位可用于证明我们的教育水平，政府颁发的护照使我们能够在国家之间旅行。这些凭证在现实世界中为我们提供了便利，但在网络上使用它们仍然难以捉摸。
    </p>

    <p>
      目前，在网络上表达教育资格、医疗数据、财务账户详细信息以及其他类型的第三方验证的机器可读个人信息是很困难的。在网络上表达数字凭证的困难使得在网络上获得与现实世界中相同的利益变得具有挑战性。
    </p>

    <p>
      本规范为在网络上表达凭证提供了一种标准方法，这种方法在密码学上是安全的，尊重隐私且可供机器验证。
    </p>

    <p>
      对于那些不熟悉与可验证凭证相关的概念的人，以下部分提供了一个概述：
    </p>

    <ul>
      <li>
        构成可验证凭证的组件
      </li>
      <li>
        构成可验证展示的组件
      </li>
      <li>
        可验证凭证和可验证展示预期有用的生态系统
      </li>
      <li>
        为本规范提供指导的用例和要求。
      </li>
    </ul>

    <section class="informative">
      <h3>什么是可验证凭证？</h3>

      <p>
        在现实世界中，凭证可能包括：
      </p>

      <ul>
        <li>
          与凭证主体相关的身份信息（例如，照片、姓名或身份证号）
        </li>
        <li>
          与颁发机构相关的信息（例如，市政府、国家机构或认证机构）
        </li>
        <li>
          与此凭证类型相关的信息（例如，荷兰护照、美国驾驶执照或健康保险卡）
        </li>
        <li>
          由颁发机构关于主体的特定属性或属性的相关信息（例如，国籍、有资格驾驶的车辆类别或出生日期）
        </li>
        <li>
          与凭证衍生的证据相关的信息
        </li>
        <li>
          与凭证约束相关的信息（例如，有效期或使用条款）。
        </li>
      </ul>

      <p>
        可验证凭证可以表示与实体凭证相同的所有信息。数字签名等技术的添加使可验证凭证比实体凭证更具篡改证据和更值得信赖。
      </p>

      <p>
        可验证凭证的持有者可以生成可验证的展示，然后与验证者共享这些可验证的展示，以证明他们具有某些特征的可验证凭证。
      </p>

      <p>
        可验证凭证和可验证展示可以快速传输，使它们在远程建立信任时比实体凭证更方便。
      </p>

      <p>
        虽然本规范试图改进表达数字凭证的便利性，但它还试图平衡这一目标与一系列保护隐私的目标。数字信息的持久性以及不同数字数据来源的收集和关联的便利性，构成了使用可验证且易于机器阅读的凭证可能加剧的隐私问题。本文档在<a
          href="#privacy-considerations"></a>部分概述并试图解决这些问题。本文档还提供了如何使用保护隐私的技术（例如零知识证明）使用此数据模型的示例。
      </p>

      <p>
        术语可验证凭证和可验证展示中的“可验证”是指凭证或展示具有可由验证者验证的特性，如本文档所定义。凭证的可验证性并不意味着其中编码的声明是真实的。相反，在建立可验证凭证或可验证展示的真实性和时效性后，验证者使用自己的业务规则验证包含的声明，然后才依赖它们。这种依赖仅在评估发行者、证明、主题和声明之后，根据一个或多个验证者策略进行。
      </p>
    </section>

    <section class="informative">
      <h3>生态系统概述</h3>

      <p>
        本节描述了核心参与者的角色以及在可验证凭证预期有用的生态系统中它们之间的关系。角色是一个抽象，可以用许多不同的方式实现。角色的分离表明了可能的接口和协议标准化。本规范引入了以下角色：
      </p>

      <dl>
        <dt>[=holder=]（持有者）</dt>
        <dd>
          通过拥有一个或多个可验证凭证并从中生成可验证展示来执行的实体角色。示例持有者包括学生、员工和客户。
        </dd>
        <dt>[=issuer=]（发行者）</dt>
        <dd>
          实体执行的角色，通过对一个或多个主体进行声明，从这些声明中创建可验证凭证，并将可验证凭证传输给持有者。示例发行者包括公司、非营利组织、行业协会、政府和个人。
        </dd>
        <dt>[=subject=]（主体）</dt>
        <dd>
          进行声明的实体。示例主体包括人类、动物和事物。在许多情况下，可验证凭证的持有者是主体，但在某些情况下不是。例如，父母（持有者）可能持有孩子（主体）的可验证凭证，或者宠物主人（持有者）可能持有他们宠物（主体）的可验证凭证。有关这些特殊情况的更多信息，请参阅可验证凭证实施指南[[VC-IMP-GUIDE]]中的
          <a href="https://www.w3.org/TR/vc-imp-guide/#subject-holder-relationships">
            主体-持有者关系</a>部分。
        </dd>
        <dt>[=verifier=]（验证者）</dt>
        <dd>
          通过接收一个或多个可验证凭证（可选地在可验证展示中）进行处理的实体角色。示例验证者包括雇主、安全人员和网站。
        </dd>
        <dt>[=verifiable data registry=]（可验证数据注册表）</dt>
        <dd>
          系统可能通过调解创建和验证标识符、密钥和其他相关数据（如可验证凭证模式、撤销注册表、发行者公钥等）来执行的角色，这些数据可能需要使用可验证凭证。某些配置可能需要可关联的主体标识符。示例可验证数据注册表包括可信数据库、分布式数据库、政府ID数据库和分布式分类帐。通常，在生态系统中会使用多种类型的可验证数据注册表。
        </dd>
      </dl>

      <figure id="roles">
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/ecosystem.svg" alt="示意图显示了
               凭证从发行者流向持有者，
               展示从持有者流向验证者，所有
               三方均可使用来自逻辑
               可验证数据注册表的信息">
        <figcaption style="text-align: center;">
          构成本规范基础的角色和信息流。
        </figcaption>
      </figure>

      <p class="note">
        上面的<a href="#roles"></a>提供了一个示例生态系统，以便将本规范的其他概念固定下来。其他生态系统（如受保护的环境或专有系统）也存在，其中可验证凭证也具有优势。
      </p>
    </section>

    <section class="informative">
      <h3>用例和要求</h3>

      <p>
        可验证凭证用例文档[[VC-USE-CASES]]概述了一些关键主题，读者可能会发现这些主题很有用，包括：
      </p>

      <ul>
        <li>
          对上述引入的
          <a href="https://www.w3.org/TR/vc-use-cases/#user-roles">角色</a>
          的更详细解释
        </li>
        <li>
          在市场垂直领域（如教育、金融、医疗、零售、专业许可和政府）中确定的
          <a href="https://www.w3.org/TR/vc-use-cases/#user-needs">需求</a>
        </li>
        <li>
          生态系统中角色执行的常见
          <a href="https://www.w3.org/TR/vc-use-cases/#user-tasks">任务</a>
          以及与之相关的要求
        </li>
        <li>
          工作组确定的常见
          <a href="https://www.w3.org/TR/vc-use-cases/#user-sequences">序列和流程</a>。
        </li>
      </ul>

      <p>
        通过记录和分析用例文档，为本规范确定了以下理想的生态系统特征：
      </p>
      <!-- 要求列表开始 -->
      <ul>
        <li>
          可验证凭证代表发行者以防篡改和尊重隐私的方式所作的声明。
        </li>
        <li>
          持有者可以将来自不同发行者的可验证凭证集合组装成一个单一的工件，即可验证展示。
        </li>
        <li>
          发行者可以颁发关于任何主体的可验证凭证。
        </li>
        <li>
          执行发行者、持有者或验证者的角色不需要任何权威机构的注册或批准，因为涉及的信任是双方之间的。
        </li>
        <li>
          可验证展示允许任何验证者验证来自任何发行者的可验证凭证的真实性。
        </li>
        <li>
          持有者可以从任何人那里接收可验证凭证。
        </li>
        <li>
          持有者可以通过任何用户代理与任何发行者和任何验证者互动。
        </li>
        <li>
          持有者可以共享可验证展示，然后可以验证它们，而无需向发行者透露验证者的身份。
        </li>
        <li>
          验证者可以验证可验证展示的真实性，而无需向发行者透露验证者的身份。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，而不需要共享主体的唯一标识符。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时尊重主体的隐私。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体选择性地披露信息。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体保留对披露给验证者的信息的控制。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行最小化。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行选择性披露。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行选择性披露，而无需泄露其他信息。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行选择性披露，而无需泄露其他信息，且不需要向发行者透露验证者的身份。
        </li>
      </ul>
      <!-- 要求列表结束 -->
    </section>
  </section>
  <section class="normative">
    <h2>术语</h2>

    <p>
      以下术语用于描述本规范中的概念。
    </p>

    <dl class="termlist definitions">
      <dt><dfn class="export" data-lt="claims">声明</dfn></dt>
      <dd>
        关于某个[=主体=]的断言。
      </dd>
      <dt><dfn class="export" data-lt="credential|credentials">凭证</dfn></dt>
      <dd>
        由一个[=发行者=]做出的一个或多个[=声明=]的集合。凭证中的[=声明=]
        可以关于不同的[=主体=]。本规范中使用的凭证的定义与
        <a href="https://csrc.nist.gov/glossary/term/credential">NIST的凭证定义</a>不同。
      </dd>
      <dt><dfn>数据最小化</dfn></dt>
      <dd>
        限制共享数据的行为，严格限制到完成任务或目标所必需的最小量。
      </dd>
      <dt><dfn data-lt="decentralized identifiers|DID|DIDs">去中心化标识符</dfn></dt>
      <dd>
        一种便携式基于URL的标识符，也被称为<strong><em>DID</em></strong>，
        与[=实体=]相关联。这些标识符最常用于
        [=可验证的凭证=]，并与[=主体=]关联，使得一个
        [=可验证的凭证=]可以轻易地从一个
        [=仓库=]迁移到另一个，而无需重新发行[=凭证=]。
        DID的一个例子是`did:example:123456abcdef`。
      </dd>
      <dt><dfn class="lint-ignore" data-lt="decentralized identifier documents|DID document|DID documents">去中心化
          标识符文档</dfn></dt>
      <dd>
        也被称为<strong><em>DID文档</em></strong>，这是一个可以通过[=可验证数据注册表=]访问的文档，
        包含与特定[=去中心化标识符=]相关的信息，如相关的[=仓库=]和公钥信息。
      </dd>
      <dt><dfn data-lt="default graph">默认图</dfn></dt>
      <dd>
        包含所有不明确属于
        [=命名图=]的[=声明=]的[=图=]。
      </dd>
      <dt><dfn data-lt="predicates|derived predicates">派生谓词</dfn></dt>
      <dd>
        关于[=可验证凭证=]中另一个属性值的可验证的布尔断言。
        这些在零知识证明风格的
        [=可验证呈现=]中很有用，因为它们可以限制信息的披露。
        例如，如果一个[=可验证的凭证=]包含一个用于表示特定高度（以厘米为单位）的属性，
        一个派生谓词可能会引用[=可验证凭证=]中的高度属性，证明
        [=发行者=]确认高度值满足最低高度要求，
        而实际上并未披露具体的高度值。例如，[=主体=]的身高超过150厘米。
      </dd>
      <dt><dfn class="lint-ignore">数字签名</dfn></dt>
      <dd>
        用于证明数字消息真实性的数学方案。
      </dd>
      <dt><dfn data-lt="entities|entity's">实体</dfn></dt>
      <dd>
        可以在陈述中作为抽象或具体名词引用的任何事物。
        实体包括但不限于人、组织、实物、文档、抽象概念、虚构角色和任意文本。任何
        实体都可能在生态系统中扮演角色，如果它有能力这样做。请注意，有些实体从根本上无法采取行动，例如，字符串"abc"
        不能发行凭证。
      </dd>
      <dt><dfn data-lt="graphs">图</dfn></dt>
      <dd>
        一组声明，形成一个由[=主体=]
        及其与其他[=主体=]或数据的关系组成的信息网络。每个[=声明=]
        都是图的一部分；在[=命名图=]的情况下，这是明确的，或者
        在[=默认图=]的情况下是隐含的。
      </dd>
      <dt><dfn class="export" data-lt="holders|holder's|holders'">持有者</dfn></dt>
      <dd>
        通过持有一个或多个
        [=可验证凭证=]并从中生成[=可验证呈现=]来执行的角色。持有者通常是，但不总是，他们持有的
        [=可验证凭证=]的[=主体=]。持有者将其
        [=凭证=]存储在[=凭证仓库=]中。
      </dd>
      <dt><dfn class="lint-ignore" data-lt="identities|identity's">身份</dfn></dt>
      <dd>
        跨上下文跟踪[=实体=]的手段。数字
        身份使得跟踪和定制[=实体=]在数字上下文中的交互成为可能，通常使用标识符和属性。身份信息的意外分发或使用可能会损害隐私。收集和使用此类信息应遵循
        [=数据最小化=]原则。
      </dd>
      <dt><dfn data-lt="identity providers|idp">身份提供者</dfn></dt>
      <dd>
        身份提供者，有时缩写为<em>IdP</em>，是一个为[=持有者=]创建、维护和管理身份信息的系统，
        同时为联盟或分布式网络中的[=依赖方=]应用程序提供身份验证服务。在这种情况下，[=持有者=]始终是[=主体=]。即使[=可验证凭证=]是持票人
        [=凭证=]，也假设[=可验证凭证=]仍然随着
        [=主体=]，如果没有，它们是被攻击者窃取的。本规范不使用此术语，除非将本文档中的概念与其他规范进行比较或映射。本规范将
        [=身份提供者=]概念拆分为两个独立的概念：[=发行者=]
        和[=持有者=]。
      </dd>
      <dt><dfn class="export" data-lt="issuers|issuer's">发行者</dfn></dt>
      <dd>
        一个[=实体=]可以通过对一个或多个[=主体=]进行[=声明=]，
        从这些[=声明=]中创建一个[=可验证凭证=]，
        并将[=可验证凭证=]传输给
        [=持有者=]来执行的角色。
      </dd>
      <dt><dfn data-lt="named graphs">命名图</dfn></dt>
      <dd>
        与特定属性相关联的[=图=]，例如
        `verifiableCredential`。这些属性
        导致独立的[=图=]，其中包含在相应的JSON对象中定义的所有[=声明=]。
      </dd>
      <dt><dfn class="export" data-lt="presentation|presentations">呈现</dfn></dt>
      <dd>
        从一个或多个[=可验证凭证=]，由一个或多个[=发行者=]发行的数据派生出来，
        并与特定的[=验证者=]共享。
      </dd>
      <dt><dfn class="export" data-lt="credential repository|credential repositories|repositories">仓库</dfn></dt>
      <dd>
        一个程序，如存储库或个人[=可验证凭证=]
        钱包，存储并保护对[=持有者的=]
        [=可验证凭证=]的访问。
      </dd>
      <dt><dfn class="export">选择性披露</dfn></dt>
      <dd>
        [=持有者=]做出关于分享哪些信息的细粒度决策的能力。
      </dd>
      <dt><dfn class="export" data-lt="subjects|subject's">主体</dfn></dt>
      <dd>
        制作[=声明=]的对象。
      </dd>
      <dt><dfn class="lint-ignore">用户代理</dfn></dt>
      <dd>
        一个程序，如浏览器或其他Web客户端，它调解
        [=持有者=]、[=发行者=]和[=验证者=]之间的
        通信。
      </dd>
      <dt><dfn class="export" data-lt="claim validation|validate">验证</dfn></dt>
      <dd>
        确保特定[=发行者=]的[=声明=]满足[=验证者=]对特定用途的业务要求的保证。本规范定义了验证者如何验证[=可验证凭证=]和
        [=可验证呈现=]。<br />
        它还规定[=验证者=]在依赖它们之前应验证[=可验证
        凭证=]中的声明。然而，这种验证的方法各不相同，超出了本规范的范围。预计[=验证者=]将信任某些[=发行者=]对某些声明，并
        应用他们自己的规则来确定哪些声明在哪些[=凭证=]
        对他们的系统来说是适合使用的。
      </dd>
      <dt><dfn class="export" data-lt="vc|vcs">可验证凭证</dfn></dt>
      <dd>
        可验证凭证是一种防篡改的凭证，其作者身份可以通过密码验证。可验证凭证可以用来构建[=可验证呈现=]，这也可以通过密码验证。
      </dd>
      <dt><dfn class="export" data-lt="verifiable data registries">可验证数据注册表</dfn></dt>
      <dd>
        一个系统可能通过调解识别符、密钥和其他相关数据（如
        [=可验证凭证=]模式、撤销注册表、发行者公钥等）的创建和[=验证=]
        来执行的角色，这些可能是使用[=可验证凭证=]所必需的。某些配置可能需要可关联的识别符对于[=主体=]。某些注册表，如UUID和公钥的注册表，可能只是识别符的命名空间。
      </dd>
      <dt><dfn class="export" data-lt="vp|vps">可验证呈现</dfn></dt>
      <dd>
        可验证呈现是一种防篡改的呈现，以这样一种方式编码，以便在密码学验证过程之后可以信任数据的作者身份。某些类型的可验证呈现可能包含从[=可验证
        凭证=]（例如，零知识证明）合成的数据，但不包含原始[=可验证
        凭证=]。
      </dd>
      <dt><dfn class="export" data-lt="verify|verified|verifying|verifiable|verifiability">验证</dfn></dt>
      <dd>
        评估一个[=可验证凭证=]或[=可验证
        呈现=]是否是发行者或
        呈现者的真实和当前陈述。这包括检查：凭证（或
        呈现）是否符合规范；证明方法是否满足；以及（如果存在）状态检查是否成功。验证凭证并不意味着评估凭证中编码的[=声明=]的真实性。
      </dd>
      <dt><dfn class="export"
          data-lt="verifier|verifiers|verifier's|credential verifiers|credential verifier's">验证者</dfn></dt>
      <dd>
        一个[=实体=]通过接收一个或多个
        [=可验证凭证=]，可选择地在
        [=可验证呈现=]中进行处理来执行的角色。其他规范可能将这个概念称为<dfn data-lt="relying parties">依赖方</dfn>。
      </dd>
      <dt><dfn data-lt="verification material">验证材料</dfn></dt>
      <dd>
        可能是一个密码公钥或用于验证证据的任何其他数据。
      </dd>
      <dt><dfn data-lt="URL|URLs">URL</dfn></dt>
      <dd>
        统一资源定位符，如[[URL]]所定义。URL可以被解引用，
        从而导致一个资源，如文档。解引用或获取URL的规则由URL [=url/scheme=]定义。本规范不使用术语URI或IRI，因为这些术语被认为对Web开发者来说很混乱。
      </dd>
    </dl>
  </section>

  <section class="informative">
    <h2>核心数据模型</h2>

    <p>
      以下部分概述了核心数据模型概念，如 [=claims=]、[=credentials=]、[=presentations=]、[=verifiable credentials=] 和 [=verifiable
      presentations=]，这些概念构成了本规范的基础。
    </p>

    <p class="note" title="凭证和可验证凭证之间的区别">
      读者可能会注意到，本节中描述的一些概念，如 [=credential=] 和 [=presentation=]，在本规范中没有定义媒体类型。然而，[=verifiable credential=] 或 [=verifiable
      presentation=] 这些概念被定义为 [=conforming documents=]，并且具有相关联的媒体类型。这些概念之间的具体区别 &mdash; 即 [=credential=] 和
      [=presentation=] 与 [=verifiable credential=] 和 [=verifiable presentation=] 之间的区别 &mdash; 仅仅在于 "可验证"
      对象以加密可验证的方式进行保护，而其他对象则没有。有关详细信息，请参见<a href="#securing-mechanisms">安全机制部分</a>。
    </p>

    <section class="informative">
      <h3>声明</h3>

      <p>
        一个[=claim=]是关于一个[=subject=]的陈述。一个[=subject=]是可以对其进行[=claims=]的事物。[=Claims=]使用<strong><em>主体</em></strong>-<dfn
          data-lt="property|properties">
          属性</dfn>-<dfn class="lint-ignore">值</dfn>关系来表示。
      </p>

      <figure id="basic-structure">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/claim.svg" alt="主体具有一个属性，该属性具有一个值">
        <figcaption style="text-align: center;">
          声明的基本结构。
        </figcaption>
      </figure>

      <p>
        如上图<a href="#basic-structure"></a>所示，[=claims=]的数据模型非常强大，可以用来表示各种各样的陈述。例如，某人是否从某个特定大学毕业，可以如下图<a
          href="#basic-example"></a>所示表示。
      </p>

      <figure id="basic-example">
        <img style="margin: auto; display: block; width: 60%;" src="diagrams/claim-example.svg"
          alt="Pat具有一个alumniOf属性，其值为Example University">
        <figcaption style="text-align: center;">
          一个基本的声明，表示Pat是“Example University”的校友。
        </figcaption>
      </figure>

      <p>
        单个[=claims=]可以合并在一起，以表达关于[=subject=]的信息[=graph=]。下图<a
          href="#multiple-claims"></a>中的示例通过添加Pat认识Sam的[=claims=]以及Sam被雇佣为教授的[=claims=]来扩展之前的[=claim=]。
      </p>

      <figure id="multiple-claims">
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/claim-extended.svg"
          alt="扩展先前的图表，添加一个名为knows的属性，其值为Sam，Sam具有一个名为jobTitle的属性，其值为Professor">
        <figcaption style="text-align: center;">
          多个声明可以组合在一起，以表达信息图。
        </figcaption>
      </figure>

      <p>
        到目前为止，已经介绍了[=claim=]和信息[=graph=]的概念。为了能够信任[=claims=]，预计将向图中添加更多信息。
      </p>
    </section>

    <section class="informative">
      <h3>凭证</h3>

      <p>
        一个[=credential=]是由相同的[=entity=]做出的一个或多个[=claims=]的集合。[=Credentials=]还可能包括一个标识符和元数据，用于描述[=credential=]的属性，如[=issuer=]、有效日期和时间段、代表性图像、[=verification
        material=]、吊销机制等。元数据可能由[=issuer=]签名。一个[=verifiable credential=]是一个防篡改的[=claims=]和元数据的集合，可以加密地证明谁发行了它。
      </p>

      <figure id="basic-vc">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/vc.svg" alt="一个可验证的凭证包含凭证元数据、声明和证明">
        <figcaption style="text-align: center;">
          可验证凭证的基本组件。
        </figcaption>
      </figure>

      <p>
        [=verifiable credentials=]的示例包括数字员工身份证、数字出生证明和数字教育证书。
      </p>

      <p class="note">
        [=Credential=]标识符通常用于识别特定实例的[=credential=]。这些标识符也可以用于关联。希望最小化关联的[=holder=]建议使用一种选择性披露方案，该方案不会泄露[=credential=]标识符。
      </p>

      <p>
        <a href="#basic-vc"></a>上面显示了一个[=verifiable
        credential=]的基本组件，但抽象了关于如何将[=claims=]组织成信息[=graphs=]的细节，然后将其组织成[=verifiable credentials=]。
      </p>
      <p>
        <a href="#info-graph-vc"></a>下面显示了一个使用基于[[?VC-DATA-INTEGRITY]]的[=embedded proof=]的更完整的[=verifiable
        credential=]描述。它由至少两个信息[=graphs=]组成。
        这些信息[=graphs=]中的第一个，即[=verifiable credential graph=]（它是[=default
        graph=]），通过[=credential=]元数据和其他[=claims=]来表达[=verifiable credential=]本身。
        第二个信息[=graph=]，由`proof`属性引用，是[=verifiable credential=]的<dfn>proof graph</dfn>，是一个单独的[=named graph=]。
        [=proof graph=]表达了数字证明，这种情况下是数字签名。
      </p>

      <figure id="info-graph-vc">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vc-graph.svg" alt="Diagram with a collections of
claims for a 'verifiable credential graph' on top
connected via a proof property (or predicate) to a 'verifiable credential proof
graph' on the bottom. The claims for a verifiable credential include 'Credential
123' as a subject with 4 properties: 'type' of value ExampleAlumniCredential,
'issuer' of Example University, 'validFrom' of 2010-01-01T19:23:24Z, and
credentialSubject of Pat, who also has an alumniOf property with value of
Example University.  The verifiable credential proof graph has an object
'Signature 456' subject with 5 properties: 'type' of DataIntegrityProof,
'verificationMethod' of Example University Public Key 7, 'created' of
2017-06-18T21:19:10Z, a 'nonce' of 34dj239dsj328, and 'proofValue' of
'zBavE110…3JT2pq'. The verifiable credential graph is also annotated with the
parenthetical remark '(the default graph)', the verifiable credential proof
graph is annotated with the parenthetical remark '(a named graph)'.">
        <figcaption style="text-align: center;">
          使用基于[[[VC-DATA-INTEGRITY]]]的[=embedded proof=]的基本可验证凭证的相关信息图。
        </figcaption>
      </figure>

      <p>
        <a href="#info-graph-vc-jwt"></a>下面显示了与<a href="#info-graph-vc"></a>相同的可验证凭证，
        但使用基于[[?VC-JOSE-COSE]]的JOSE。负载包含一个信息图，即可验证凭证图，其中包含凭证元数据和其他声明。
      </p>

      <figure id="info-graph-vc-jwt">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vc-jwt.svg" alt="Diagram with, on the left, a box, labeled as
'SD-JWT (Decoded)', and with three textual labels stacked vertically,
namely 'Header', 'Payload', and 'Signature'. The 'Header' label is
connected, with an arrow, to a separate rectangle on the right hand
side containing six text fields: 'kid: aB8J-_Z', 'alg: ES384', and
'cty: vc+ld+json', iss: https://example.com, iat: 1704690029, and typ:
vc+ld+json+sd-jwt The 'Payload' label on the left side is connected,
with an arrow, to a separate rectangle, containing a single graph. The
rectangle has a label: 'verifiable credential graph (serialized in
JSON)' The claims in the graph include 'Credential 123' as a subject
with 4 properties: 'type' with value 'ExampleAlumniCredential',
'issuer' with value 'Example University', 'validFrom' with value
'2010-01-01T19:23:24Z', and 'credentialSubject' with value 'Pat', who
also has an 'alumniOf' property with value 'Example University'.
Finally, the 'Signature' label on the left side is connected, with an
arrow, to a separate rectangle, containing a single text field:
'DtEhU3ljbEg8L38VWAfUA...'.
          ">
        <figcaption style="text-align: center;">
          使用基于[[[VC-JOSE-COSE]]] [[?VC-JOSE-COSE]]的[=enveloping proof=]的基本可验证凭证相关的信息图。
        </figcaption>
      </figure>

      <p class="note">
        可以有一个[=credential=]，例如婚姻证书，其中包含关于不同[=subjects=]的多个[=claims=]，这些主题不需要相关。
      </p>
      <p class="note">
        可以有一个[=credential=]，其中不包含关于发行[=credential=]的[=entity=]的任何[=claims=]。例如，一个只包含关于特定狗的[=claims=]，但发给其所有者的[=credential=]。
      </p>
    </section>

    <section class="informative">
      <h3>演示</h3>

      <p>
        增强隐私是本规范的一个关键设计特性。因此，对于使用这项技术的[=实体=]来说，能够仅表达适用于特定情境的个人形象的部分非常重要。一个人形象的子集被称为[=可验证的演示=]。不同形象的例子包括一个人的专业形象、他们的在线游戏形象、他们的家庭形象或匿名形象。
      </p>

      <p>
        [=可验证的演示=]可以表达来自多个[=可验证的凭证=]的数据，并包含编码为JSON-LD的任意附加数据。它们由[=持有人=]用于向[=验证者=]展示[=声明=]。也可以直接展示[=可验证的凭证=]。
      </p>

      <p>
        [=演示=]中的数据通常与同一个[=主题=]有关，但可能是由多个[=发行者=]发布的。这些信息的汇总通常表达了一个人、组织或[=实体=]的某个方面。
      </p>

      <figure id="basic-vp">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/presentation.svg"
          alt="可验证的演示包含演示元数据、可验证的凭证和证明">
        <figcaption style="text-align: center;">
          可验证演示的基本组件。
        </figcaption>
      </figure>

      <p>
        <a href="#basic-vp"></a>上面显示了[=可验证的演示=]的组件，但抽象了关于如何将[=可验证的凭证=]组织成信息[=图=]的细节，然后将这些信息[=图=]组织成[=可验证的演示=]。
      </p>
      <p id="info-graph-vp-explanation">
        <a
          href="#info-graph-vp"></a>下面显示了一个使用基于[[?VC-DATA-INTEGRITY]]的[=嵌入式证明=]的[=可验证的演示=]的更完整描述。它由至少四个信息[=图=]组成。其中第一个信息[=图=]，即[=可验证的演示图=]（它是[=默认图=]），通过[=演示=]元数据表达[=可验证的演示=]本身。[=可验证的演示=]通过`verifiableCredential`属性引用一个[=可验证的凭证=]。这个[=凭证=]是一个包含[=凭证=]元数据和其他[=声明=]的独立[=可验证的凭证图=]。这个[=凭证=]通过`proof`属性引用一个[=可验证的凭证=]的[=证明图=]，表达了[=凭证=]的证明（通常是数字签名）。这个[=可验证的凭证图=]及其链接的[=证明图=]分别构成第二和第三个信息[=图=]，每个都是一个单独的[=命名图=]。[=演示=]还通过`proof`属性引用[=演示=]的[=证明图=]，这是第四个信息[=图=]（另一个[=命名图=]）。这个[=演示=]的[=证明图=]表示[=可验证的演示图=]、[=可验证的凭证图=]以及从[=可验证的凭证图=]链接的[=证明图=]的数字签名。
      </p>
      <p>
        为了创建一个[=可验证的演示=]，[=持有人=]需要将一个或多个[=可验证的凭证=]组合在一起，并在需要时添加其他相关信息。然后，[=持有人=]需要对整个[=可验证的演示=]进行签名，以确保接收方可以验证其来源和完整性。这样，[=验证者=]就可以确信这些[=声明=]是真实的，并且是由相应的[=发行者=]颁发的。
      </p>

      <p>
        为了验证一个[=可验证的演示=]，[=验证者=]需要执行以下步骤：
      </p>

      <ol>
        <li>检查[=可验证的演示=]的数字签名以确保其来源和完整性。</li>
        <li>检查每个包含在[=可验证的演示=]中的[=可验证的凭证=]的数字签名。</li>
        <li>确保每个[=可验证的凭证=]都是由可信的[=发行者=]颁发的。</li>
        <li>确保每个[=可验证的凭证=]都没有过期或被撤销。</li>
        <li>根据需要，确保[=可验证的演示=]和[=可验证的凭证=]满足特定的业务规则和策略。</li>
      </ol>

      <p>
        一旦[=验证者=]完成了这些步骤，他们就可以信任[=可验证的演示=]中的[=声明=]，并据此做出决策。例如，根据所提供的年龄证明，他们可以决定是否允许用户访问年龄受限的内容。
      </p>

      <p>
        请注意，[=可验证的演示=]和[=可验证的凭证=]的验证过程可能会涉及与多个[=发行者=]和其他参与者的交互，以检查证书状态、获取公钥等。为了保护用户隐私，这些交互应尽可能地减少，并遵循最小披露原则，即仅披露验证所需的最少信息。
      </p>

      <p>
        本规范描述了创建和验证[=可验证的演示=]和[=可验证的凭证=]的通用方法和原则。实际应用中可能会有多种实现方式和技术，以满足不同场景和需求。这些实现应遵循本规范的核心原则，以确保互操作性和安全性。
      </p>

      <figure id="info-graph-vp">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-graph.svg" alt="Diagram with a
'verifiable presentation graph' on top connected via a 'proof' to
a 'verifiable presentation proof graph on the bottom.  The verifiable
presentation graph has and object 'Presentation ABC' with 3 properties: 'type'
of value VerifiablePresentation, 'termsOfUse' of value 'Do Not Archive'. The
graph is annotated with the parenthetical remark '(the default graph)'. This
graph is connected, through 'verifiableCredential', to the part of the figure
which is identical to Figure 6, except that the verifiable credential graph is
annotated to be a named graph instead of a default graph.
The verifiable presentation proof graph has an object with 'Signature 8910'
with 5 properties: 'type' with value 'DataIntegrityProof'; 'verificationMethod' with value 'Example
Presenter Public Key 11'; 'created' with value '2018-01-15T12:43:56Z';
'nonce' with value 'd28348djsj3239'; and 'proofValue' with value
'zp2KaZ...8Fj3K='. This graph is annotated with the parenthetical remark '(a
named graph)'">
        <figcaption style="text-align: center;">
          与基本的[=可验证呈现=]相关联的信息[=图=]，该呈现使用基于[[[VC-DATA-INTEGRITY]]] [[?VC-DATA-INTEGRITY]]的[=嵌入式证明=]。
        </figcaption>
      </figure>

      <p>
        <a href="#info-graph-vp-jwt"></a> 下面显示的是与 <a href="#info-graph-vp"></a> 相同的 [=可验证呈现=]，但使用基于 [[?VC-JOSE-COSE]] 的
        [=封装证明=]。有效负载仅包含两个信息图：通过呈现元数据表达 [=可验证呈现=] 本身的 [=可验证呈现图=]；以及相应的 [=可验证凭证图=]，由 `verifiableCredential`
        属性引用。[=可验证凭证图=] 包含单个 <a href="#defn-EnvelopedVerifiableCredential">`EnvelopedVerifiableCredential`</a> 实例，通过
        `data:` URL [[RFC2397]] 引用，指向通过 <a href="#info-graph-vc-jwt"></a> 上显示的 [=封装证明=] 保护的可验证凭证。
      </p>

      <figure id="info-graph-vp-jwt">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-jwt.svg" alt="Diagram with, on the left, a box, labeled as
'JWT (Decoded)', and with three textual labels stacked vertically,
namely 'Header', 'Payload', and 'Signature'. The 'Header' label is
connected, with an arrow, to a separate rectangle on the right hand
side containing six text fields: 'kid: aB8J-_Z', 'alg: ES384', and
'cty: vc+ld+json', iss: https://example.com, iat: 1704690029, and typ:
vp+ld+json+sd-jwt The 'Payload' label of the left side is connected,
with an arrow, to a separate rectangle, consisting of two related
graphs (stacked vertically) connected by a an arrow labeled
'verifiableCredential'. The two graphs have each a label 'verifiable
presentation graph (serialized in JSON)' and 'verifiable credential
graph (serialized in JSON)', respectively. The top graph in the
rectangle has and object 'Presentation ABC' with 3 properties: 'type'
of value VerifiablePresentation, 'termsOfUse' of value 'Do Not
Archive'. The bottom graph includes
'data:application/vc+ld+json+sd-jwt;QzVjV...RMjU' as a subject with a
single property: 'type' of value `EnvelopedVerifiableCredential`.
Finally, the 'Signature' label on the left side is connected, with an
arrow, to a separate rectangle, containing a single text field:
'XaOOh4ljklxH7L99RTVSfOl...'.
          ">
        <figcaption style="text-align: center;">
          与基本[=可验证呈现=]相关的信息图，该呈现使用基于JOSE [[?VC-JOSE-COSE]]的[=封装证明=]。
          `data:` URL指向<a href="#info-graph-vc-jwt"></a>上显示的[=可验证凭证=]。
        </figcaption>
      </figure>


      <p class="note">
        可以有一个[=呈现=]，例如一组大学凭证，它们依赖于关于不同[=主题=]的多个[=凭证=]，这些主题通常是相关的，但不是必须的。
        这是通过使用`verifiableCredential`属性来引用多个[=可验证凭证=]来实现的。
        有关更多详细信息，请参见附录<a href="#additional-diagrams-for-verifiable-presentations"></a>。
      </p>

    </section>

    <section class="informative">
      <h3>具体生命周期示例</h3>

      <p>
        前面的章节使用图形描述介绍了[=claims=]、[=verifiable credentials=]和[=verifiable
        presentations=]的概念。本节提供了一个具体的简单但完整的生命周期示例，用本规范支持的一种具体语法表示数据模型。在
        <a href="#ecosystem-overview">可验证凭证生态系统</a>中，[=credentials=]和[=presentations=]的生命周期通常遵循以下路径：
      </p>

      <ol>
        <li>
          发行一个或多个[=verifiable credentials=]。
        </li>
        <li>
          将[=verifiable credentials=]存储在[=credential repository=]（如数字钱包）中。
        </li>
        <li>
          将[=verifiable credentials=]组合成一个[=verifiable presentation=]，供[=verifiers=]使用。
        </li>
        <li>
          [=verifier=]对[=verifiable presentation=]进行[=Verification=]。
        </li>
        <li>
          [=verifier=]对包含在[=verifiable presentation=]中的相关[=claims=]进行[=Validation=]。
        </li>
      </ol>

      <p>
        为了说明这个生命周期，我们将使用从大学兑换校友折扣的例子。在下面的例子中，Pat从一所大学获得了一份校友[=verifiable credential=]，并将这个[=verifiable
        credential=]存储在一个数字钱包中。
      </p>

      <pre class="example nohighlight" title="一个可验证凭证内容的简单示例">
{
  <span class='comment'>// 设置上下文，建立我们将使用的特殊术语
  // 如'issuer'和'alumniOf'。</span>
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class='comment'>// 指定凭证的标识符</span>
  "id": "http://university.example/credentials/1872",
  <span class='comment'>// 凭证类型，声明凭证中期望的数据</span>
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  <span class='comment'>// 发行凭证的实体</span>
  "issuer": "https://university.example/issuers/565049",
  <span class='comment'>// 凭证发行的时间</span>
  "validFrom": "2010-01-01T19:23:24Z",
  <span class='comment'>// 关于凭证主题的声明</span>
  "credentialSubject": {
    <span class='comment'>// 凭证唯一主题的标识符</span>
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    <span class='comment'>// 关于凭证唯一主题的断言</span>
    "alumniOf": {
      <span class='comment'>// 大学的标识符</span>
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      <span class='comment'>// 大学的名称</span>
      "name": "Example University"
    }
  }
}
        </pre>

      <p>
        然后，Pat尝试兑换校友折扣。[=verifier=]，一个票务销售系统，声明“Example
        University”的校友可以获得体育赛事季票的折扣。使用移动设备，Pat开始购买季票的过程。在这个过程中的一个步骤请求一个校友[=verifiable
        credential=]，这个请求被路由到Pat的数字钱包。数字钱包询问Pat是否愿意提供以前发行的[=verifiable credential=]。Pat选择了校友[=verifiable
        credential=]，然后将其组合成一个[=verifiable presentation=]。[=verifiable presentation=]被发送到[=verifier=]并进行[=verified=]。
      </p>
      <p>
        一旦被[=verified=]为真实和当前的，季票的卖家然后验证[=verifiable credential=]的[=issuer=]是否被认可为校友状态的声明——它是，因为它是由Example
        University发行的——并且今天的日期在由`validFrom`和`validUntil`属性定义的有效期内。由于期望[=holder=]是[=verifiable
        credential=]的[=subject=]，[=verifier=]也确认校友声明的`id`与[=verifiable presentation=]的创建者的`id`匹配。
      </p>
      <p>
        在[=verified=]了凭证和演示，并验证了相关的声明后，票务销售商安全地为Pat启用了校友折扣，确信Pat有合法的权利享受这个折扣。
      </p>
      <pre class="example nohighlight" title="一个可验证演示的简单示例">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": "VerifiablePresentation",
  <span class='comment'>// 在上一个示例中发行的可验证凭证</span>
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/1872",
    "type": ["VerifiableCredential", "ExampleAlumniCredential"],
    "issuer": "https://university.example/issuers/565049",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "alumniOf": {
        "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
        "name": "Example University"
      }
    }
  }]
}
        </pre>

      <p class="note">
        上面的例子是未加密的。对于有兴趣了解更多关于保护[=verifiable credentials=]的实现者，可以参见规范[[[VC-JOSE-COSE]]]
        [[VC-JOSE-COSE]]和[[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]]
        以及[[[VC-SPECS]]]
        [[VC-SPECS]]的"Proofs"部分。
      </p>
    </section>
  </section>

  <section class="normative">
    <h2>基本概念</h2>

    <p>
      本节介绍了规范的一些基本概念，为文档后面的<a href="#advanced-concepts"></a>部分做准备。
    </p>

    <section class="informative">
      <h3>入门</h3>

      <p>
        本规范旨在简化新类型的[=可验证凭证=]原型的设计。开发者可以复制下面的模板，并将其粘贴到常见的[=可验证凭证=]工具中，以开始发布、持有和验证原型凭证。
      </p>

      <p>
        预计开发者会将下面的`MyPrototypeCredential`更改为他们想要创建的凭证类型。由于[=可验证凭证=]涉及主题，因此`credentialSubject`对象中的每个属性值对表示凭证主题的特定属性。一旦开发者添加了若干这样的属性值组合，修改后的对象可以发送给[=可验证凭证=]发行者软件，为开发者创建一个[=可验证凭证=]。从原型设计的角度来看，这就是开发者需要做的所有事情。
      </p>

      <pre class="example nohighlight" title="创建原型可验证凭证的模板">
{
  "@context": ["https://www.w3.org/ns/credentials/v2"],
  "type": ["VerifiableCredential", "MyPrototypeCredential"],
  "credentialSubject": {
    "mySubjectProperty": "mySubjectValue"
  }
}
        </pre>

      <p>
        一旦开发者将他们的凭证原型设计到他们认为所有凭证属性都稳定的程度，建议他们为他们的应用程序生成词汇表和上下文文件，并将它们发布在稳定的URL上，以便其他开发者可以使用相同的词汇表和上下文实现互操作性。这个过程在第<a
          href="#extensibility"></a>节中有介绍。或者，开发者可以重用现有的词汇表和上下文文件，以适应他们的用例。他们可以浏览[[[VC-SPECS]]] [[VC-SPECS]]以获取可重用资源。
      </p>

    </section>
    <section>
      <h3>上下文</h3>

      <p>
        当两个软件系统需要交换数据时，它们需要使用双方都理解的术语。作为一个类比，考虑一下两个人如何交流。两个人必须使用相同的语言，他们使用的词语对彼此必须具有相同的含义。这可能被称为
        <em>对话的上下文</em>。
      </p>
      <p>
        [=可验证的凭证=]和[=可验证的展示=]有许多由[=URLs=]
        [[URL]]标识的属性和值。然而，这些[=URLs=]可能很长，对人类并不友好。在这种情况下，短格式的人类友好别名可能更有帮助。本规范使用`@context`
        [=属性=]将这种短格式别名映射到特定的[=可验证的凭证=]和[=可验证的展示=]所需的[=URLs=]。
      </p>
      <p class="note">
        在JSON-LD中，`@context` [=属性=]也可以用来传递其他细节，如数据类型信息，语言信息，转换规则等，这些超出了本规范的需要，但可能在未来或相关工作中有用。更多信息，请参见
        <a href="https://www.w3.org/TR/json-ld11/#the-context">第3.1节：上下文</a>
        的[[[JSON-LD11]]] [[JSON-LD11]]规范。
      </p>
      <p>
        [=可验证的凭证=]和[=可验证的展示=]必须包含一个`@context` [=属性=]。
      </p>

      <dl>
        <dt><dfn class="export">@context</dfn></dt>
        <dd>
          `@context` [=属性=]的值必须是一个有序集，其中第一项是一个[=URL=]，值为
          `https://www.w3.org/ns/credentials/v2`。作为参考，附录<a href="#base-context"></a>提供了基础上下文的副本。
          数组中的后续项必须由任何组合的[=URLs=]和/或对象组成，每个对象都可以作为
          <a data-cite="JSON-LD11#the-context">JSON-LD上下文</a>处理。
        </dd>
      </dl>
      <p class="note">
        本规范要求存在`@context` [=属性=]
        ，此属性由[[JSON-LD11]]定义。
      </p>
      <pre class="example nohighlight" title="使用@context属性的示例">
{
  <span class="highlight">"@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ]</span>,
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

      <p>
        上面的例子使用基础上下文[=URL=]
        (`https://www.w3.org/ns/credentials/v2`)来确定对话是关于一个[=可验证的凭证=]。第二个[=URL=]
        (`https://www.w3.org/ns/credentials/examples/v2`)确定对话是关于示例的。
      </p>

      <p class="note">
        本文档使用示例上下文[=URL=]
        (`https://www.w3.org/ns/credentials/examples/v2`)来演示示例。实现期望不使用此[=URL=]进行任何其他目的，如在试点或生产系统中使用。
      </p>

      <p>
        在`https://www.w3.org/ns/credentials/v2`上可用的数据是一个静态文档，永远不会更新，应该被下载和缓存。可验证凭证数据模型的相关人类可读词汇文档可在
        <a href="https://www.w3.org/2018/credentials/">https://www.w3.org/2018/credentials/</a>获得。
        这个概念在<a href="#extensibility"></a>章节中有进一步的扩展。
      </p>

    </section>

    <section>
      <h3>标识符</h3>

      <p>
        当对特定事物（如人、产品或组织）进行陈述时，使用该事物的全球唯一标识符可能会很有用。
        全球唯一标识符使其他人能够对同一事物进行陈述。本规范定义了可选的`id`
        [=属性=]用于此类标识符。`id` [=属性=]
        允许在[=可验证的凭证=]中对特定事物进行陈述，并由[=发行者=]在表达
        [=可验证的凭证=]中的对象或[=持有者=]在表达
        [=可验证的展示=]中的对象时设置。`id`值的示例
        包括UUIDs (`urn:uuid:0c07c1ce-57cb-41af-bef2-1b932b986873`)，HTTP URLs
        (`https://id.example/things#123`)和DIDs (`did:example:1234abcd`)。
      </p>

      <p>
        <em>如果</em> `id` [=属性=]存在：
      </p>

      <ul>
        <li>
          `id` [=属性=]必须表达一个标识符，其他人预期会在对该标识符标识的特定事物进行陈述时使用这个标识符。
        </li>
        <li>
          `id` [=属性=]不能有多个值。
        </li>
        <li>
          `id` [=属性=]的值必须是一个[=URL=]，该URL可能会被解引用。
        </li>
      </ul>

      <p class="note">
        开发者应记住，在需要匿名性的场景中，标识符可能会造成伤害。鼓励开发者在考虑此类场景时仔细阅读<a href="#identifier-based-correlation"></a>部分。
        在<a href="#privacy-considerations"></a>部分记录的其他类型的关联机制也会产生隐私问题。在隐私是重要考虑因素的地方，`id` [=属性=]
        可以省略。有些用例不需要，或明确要求省略，`id` [=属性=]。
      </p>

      <dl>
        <dt><dfn class="export">id</dfn></dt>
        <dd>
          `id` [=属性=]的值必须是单个[=URL=]。
          建议`id`中的[=URL=]是一个可以被解引用的URL，如果被解引用，将得到一个包含有关`id`的机器可读信息的文档。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="id属性的使用" data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class="highlight">"id": "http://university.example/credentials/3732"</span>,
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    <span class="highlight">"id": "did:example:ebfeb1f712ebc6f1c276e12ec21"</span>,
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        上述示例使用了两种类型的标识符。第一个标识符用于[=可验证的凭证=]，使用基于HTTP的URL。第二个
        标识符用于[=可验证的凭证=]的[=主题=]（即[=声明=]所涉及的事物），并使用一种[=去中心化标识符=]，也称为[=DID=]。
      </p>

      <p class="note">
        截至本文发布，[=DIDs=]是一种新型标识符，对于[=可验证的凭证=]的有效性并非必需。具体来说，
        [=可验证的凭证=]并不依赖[=DIDs=]，[=DIDs=]也并不依赖[=可验证的凭证=]。然而，预计许多
        [=可验证的凭证=]将使用[=DIDs=]，实现此规范的软件库可能需要解析[=DIDs=]。
        [=DID=]-基础的URL用于表达与[=主题=]、[=发行者=]、[=持有者=]、凭证状态列表、
        加密密钥以及与[=可验证的凭证=]相关的其他机器可读信息相关联的标识符。
      </p>
    </section>

    <section>
      <h3>类型</h3>

      <p>
        处理本文档中指定的对象类型的软件系统
        使用类型信息来确定提供的
        [=可验证凭证=]或[=可验证陈述=]是否适用
        于预期的用例。本规范为表达类型信息定义了一个`type`
        [=属性=]。这种类型信息
        可以在附录中描述的[=验证=]过程中使用
        <a href="#validation"></a>。
      </p>

      <p>
        [=可验证凭证=]和[=可验证陈述=]必须具有
        `type` [=属性=]。也就是说，任何没有`type` [=属性=]的
        [=凭证=]或
        [=陈述=]<em>不是[=可验证的=]</em>，因此既不是[=可验证凭证=]
        也不是[=可验证陈述=]。
      </p>

      <dl>
        <dt><dfn class="export" data-lt="type|types">type</dfn></dt>
        <dd>
          `type` [=属性=]的值必须是，或映射到（通过
          解释`@context`属性），一个或多个[=URLs=]。
          如果提供了多个[=URL=]，则[=URLs=]必须解释为
          无序集合。应使用语法便利功能来简化开发者
          使用。这些便利功能可能包括JSON-LD术语。建议
          `type`中的每个[=URL=]都是一个，如果取消引用，结果
          是一个包含关于
          `type`的机器可读信息的文档。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="使用type属性" data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  <span class="highlight">"type": ["VerifiableCredential", "ExampleDegreeCredential"]</span>,
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        关于本规范，下表列出了必须指定[=类型=]的对象。
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>对象</th>
            <th>类型</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              [=可验证凭证=]&nbsp;对象
            </td>
            <td>
              `VerifiableCredential`以及可选的更具体的
              [=可验证凭证=] [=类型=]。例如，<br>
              `"type": ["VerifiableCredential", "ExampleDegreeCredential"]`
            </td>
          </tr>

          <tr>
            <td>
              [=可验证陈述=]&nbsp;对象
            </td>
            <td>
              `VerifiablePresentation`以及可选的更具体的
              [=可验证陈述=] [=类型=]。例如，<br>
              `"type": ["VerifiablePresentation", "ExamplePresentation"]`
            </td>
          </tr>

          <tr>
            <td>
              <a href="#status">credentialStatus</a>&nbsp;对象
            </td>
            <td>
              有效的[=凭证=]状态[=类型=]。例如，<br>
              `"type": "BitstringStatusListEntry"`
            </td>
          </tr>

          <tr>
            <td>
              <a href="#terms-of-use">termsOfUse</a>&nbsp;对象
            </td>
            <td>
              有效的使用条款[=类型=]。例如，<br>
              `"type": "ExampleTermsPolicy"`
            </td>
          </tr>

          <tr>
            <td>
              <a href="#evidence">evidence</a>&nbsp;对象
            </td>
            <td>
              有效的证据[=类型=]。例如，<br>
              `"type": "ExampleEvidence"`
            </td>
          </tr>

        </tbody>
      </table>

      <p class="note">
        可验证凭证数据模型的[=类型=]系统与[[JSON-LD11]]的系统相同，详细信息在
        <a href="https://www.w3.org/TR/json-ld/#specifying-the-type">第3.5节:
          指定类型</a>和
        <a href="https://www.w3.org/TR/json-ld/#json-ld-grammar">第9节: JSON-LD
          语法</a>中有详细描述。在使用JSON-LD上下文（参见第
        <a href="#extensibility"></a>节）时，本规范将
        `@type`关键字别名为`type`，以使JSON-LD文档
        更易于理解。虽然应用开发者和文档作者不需要理解JSON-LD类型系统的具体细节，但希望支持互操作扩展性的本规范的实现者需要理解。
      </p>

      <p>
        所有[=凭证=]、[=陈述=]和封装对象应该
        指定，或与，更窄的[=类型=]（如
        `ExampleDegreeCredential`，例如）相关联，以便软件系统可以
        更容易地检测和处理这些额外的信息。
      </p>

      <p>
        在处理本规范中定义的封装对象时（例如，与`credentialSubject`对象或
        深层嵌套在其中的对象相关联），软件系统应使用
        在层次结构中更高的封装对象中指定的[=类型=]信息。具体来说，一个
        封装对象，如[=凭证=]，应传达关联对象[=类型=]，以便[=验证者=]可以快速确定基于封装对象[=类型=]的关联对象的内容。
      </p>

      <p>
        例如，一个具有`type`为
        `ExampleDegreeCredential`的[=凭证=]对象，向[=验证者=]发出信号，表示
        与`credentialSubject`属性关联的对象包含以下的
        标识符：
      </p>

      <ul>
        <li>
          在`id`属性中的[=主题=]。
        </li>
        <li>
          在`type`属性中的学位类型。
        </li>
        <li>
          在`name`属性中的学位标题。
        </li>
      </ul>

      <p>
        这使得实现者可以依赖与
        `type`属性关联的值进行[=验证=]。[=类型=]及其关联属性的期望应至少在人类可读的规范中记录，最好在另一个机器可读的表示中记录。
      </p>

      <p class="note">
        本规范中描述的数据模型中使用的类型系统允许
        以多种方式将类型与数据关联。实现者和作者被敦促阅读可验证凭证
        实施指南[[?VC-IMP-GUIDE]]中关于类型的部分。
      </p>

    </section>

    <section>
      <h3>名称和描述</h3>

      <p>
        在显示一个[=credential=]时，由[=issuer=]提供的文本可以为
        [=credential=]提供一个名称以及其目的的简短描述。`name` 和 `description` [=properties=]
        就是为了实现这些目的。
      </p>

      <dl>
        <dt><dfn class="export">name</dfn></dt>
        <dd>
          一个可选的属性，表示[=credential=]的名称。如果
          存在，`name` [=property=]的值必须是一个字符串或
          如<a href="#language-and-base-direction"></a>所述的语言值对象。理想情况下，一个
          [=credential=]的名称简洁、易于阅读，并能让个人
          快速区分他们可能持有的其他任何[=credentials=]。
        </dd>
        <dt><dfn class="export">description</dfn></dt>
        <dd>
          一个可选的属性，传达关于[=credential=]的具体细节。如果
          存在，`description` [=property=]的值必须是一个
          字符串或如<a href="#language-and-base-direction"></a>所述的语言值对象。理想情况下，一个
          [=credential=]的描述长度不超过几句话，传达足够的
          关于[=credential=]的信息，以提醒个人其内容
          而无需查看全部的[=claims=]。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of the name and description property"
        data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": "Example University",
    "description": "A public university focusing on teaching examples."
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": "Example University Degree",
  "description": "2015 Bachelor of Science and Arts Degree",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        名称和描述还支持以不同的语言表达内容。
        要表达带有语言和[=基本方向=]信息的字符串，
        可以使用包含`@value`、`@language`和`@direction`属性的对象，
        分别表示文本值、语言标签和基本方向。
        有关详细信息，请参见
        <a href="#language-and-base-direction"></a>。
      </p>

      <pre class="example nohighlight" title="Usage of the name and description property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": [{
      "@value": "Example University",
      "@language": "en"
    }, {
      "@value": "Université de Exemple",
      "@language": "fr"
    }, {
      "@value": "جامعة المثال",
      "@language": "ar",
      "@direction": "rtl"
    }],
    "description": [{
      "@value": "A public university focusing on teaching examples.",
      "@language": "en"
    }, {
      "@value": "Une université publique axée sur l'enseignement des exemples.",
      "@language": "fr"
    }, {
      "@value": "جامعة عامة تركز على أمثلة التدريس.",
      "@language": "ar",
      "@direction": "rtl"
    }]
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": [{
    "@value": "Example University Degree",
    "@language": "en"
  }, {
    "@value": "Exemple de Diplôme Universitaire",
    "@language": "fr"
  }, {
    "@value": "مثال الشهادة الجامعية",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "description": [{
    "@value": "2015 Bachelor of Science and Arts Degree",
    "@language": "en"
  }, {
    "@value": "2015 Baccalauréat Scientifique et Arts",
    "@language": "fr"
  }, {
    "@value": "2015 بكالوريوس العلوم والآداب",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": [{
        "@value": "Bachelor of Science and Arts Degree",
        "@language": "en"
      }, {
        "@value": "Baccalauréat Scientifique et Arts",
        "@language": "fr"
      }, {
        "@value": "بكالوريوس العلوم والآداب",
        "@language": "ar",
        "@direction": "rtl"
      }]
    }
  }
}
        </pre>
    </section>

    <section>
      <h3>凭证主体</h3>

      <p>
        一个可验证凭证包含关于一个或多个主体的声明。本规范定义了一个 `credentialSubject` 属性，用于表达关于一个或多个主体的声明。
      </p>

      <p>
        一个可验证凭证必须具有 `credentialSubject` 属性。
      </p>

      <dl>
        <dt><dfn class="export" id="defn-credentialSubject">credentialSubject</dfn></dt>
        <dd>
          `credentialSubject` 属性的值被定义为一组对象，其中每个对象必须是一个或多个声明的主体，这些声明必须被序列化在 `credentialSubject` 属性内部。
          每个对象也可以包含一个 `id` 来标识主体，如第 <a href="#identifiers"></a> 节所述。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of the credentialSubject property"
        data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  <span class="highlight">"credentialSubject"</span>: {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        可以在可验证凭证中表达与多个主体相关的信息。下面的示例指定了两个配偶作为主体。请注意，使用数组表示法将多个主体与 `credentialSubject` 属性关联起来。
      </p>

      <pre class="example nohighlight" title="Specifying multiple subjects in a verifiable credential">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "https://example.com/issuer/123",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": <span class="highlight">[{
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Jayden Doe",
    "spouse": "did:example:c276e12ec21ebfeb1f712ebc6f1"
  }, {
    "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
    "name": "Morgan Doe",
    "spouse": "did:example:ebfeb1f712ebc6f1c276e12ec21"
  }]</span>
}
        </pre>

    </section>

    <section>
      <h3>发行者</h3>

      <p>
        本规范定义了一个用于表示[=verifiable credential=]的[=issuer=]属性。
      </p>

      <p>
        一个[=verifiable credential=]必须具有一个`issuer`[=property=]。
      </p>

      <dl>
        <dt><var id="defn-issuer">issuer</var></dt>
        <dd>
          `issuer`[=property=]的值必须是一个[=URL=]，或者是一个包含`id`[=property=]的对象，其值为[=URL=]；在任何情况下，发行者都选择这个[=URL=]以全球无歧义的方式识别自己。建议该[=URL=]为一个可解引用的URL，解引用后的结果是一个关于[=issuer=]的控制器文档，如[[VC-DATA-INTEGRITY]]或[[VC-JOSE-COSE]]中定义的，可用于[=verify=]在[=credential=]中表达的信息。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of issuer property"
        data-vc-vm="https://university.example/issuers/14#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": "https://university.example/issuers/14"</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        还可以通过将一个对象与发行者属性关联起来来表达有关发行者的其他信息：
      </p>

      <pre class="example nohighlight vc" title="Usage of issuer expanded property"
        data-vc-vm="did:example:76e12ec712ebc6f1c221ebfeb1f#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": {
    "id": "did:example:76e12ec712ebc6f1c221ebfeb1f",
    "name": "Example University"
  }</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p class="note">
        `issuer` [=property=] 的值也可以是一个 JWK（例如，`"https://example.com/keys/foo.jwk"`）或者一个
        [=DID=]（例如，`"did:example:abfe13f712120431c276e12ecab"`）。
      </p>

    </section>

    <section>
      <h3>有效期</h3>

      <p>
        本规范定义了`validFrom` [=property=]，以帮助发行者表达[=credential=]生效的日期和时间，以及`validUntil`
        [=property=]，用于表达[=credential=]失效的日期和时间。
      </p>

      <p>
        在比较日期和时间时，计算是“时间性”的，这意味着字符串值被转换为存在于时间轴上的一个点的“时间值”。然后通过检查要比较的日期和时间相对于时间轴上的特定点的位置来进行时间比较。
      </p>

      <dl>
        <dt><var id="defn-validFrom">validFrom</var></dt>
        <dd>
          如果存在，`validFrom` [=property=]的值必须是一个
          [<a data-cite="XMLSCHEMA11-2#dateTime">XMLSCHEMA11-2</a>]
          `dateTimeStamp`字符串值，表示[=credential=]生效的日期和时间，可以是未来或过去的日期和时间。请注意，此值表示与`credentialSubject`
          [=property=]关联的信息生效的最早时间点。如果还存在`validUntil`值，则
          `validFrom`值必须表示与`validUntil`值表示的日期时间相同或更早的日期时间。
        </dd>
        <dt><var id="defn-validUntil">validUntil</var></dt>
        <dd>
          如果存在，`validUntil` [=property=]的值必须是一个
          [<a data-cite="XMLSCHEMA11-2#dateTime">XMLSCHEMA11-2</a>]
          `dateTimeStamp`字符串值，表示[=credential=]失效的日期和时间，可以是过去或未来的日期和时间。请注意，此值表示与`credentialSubject`
          [=property=]关联的信息有效的最晚时间点。如果还存在`validFrom`值，则`validUntil`
          值必须表示与`validFrom`值表示的日期时间相同或更晚的日期时间。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of validFrom and validUntil property"
        data-vc-vm="https://university.example/issuers/14#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  <span class="highlight">"validFrom": "2010-01-01T19:23:24Z"</span>,
  <span class="highlight">"validUntil": "2020-01-01T19:23:24Z"</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p class="note">
        如果`validFrom`和`validUntil`不存在，则认为[=可验证凭证=]的有效期无限。在这种情况下，假定[=可验证凭证=]从创建时开始有效。
      </p>

      <h4>表示时间</h4>

      <p>
        实现者应该了解，表示和处理时间值并非像看起来那么简单，并且在世界不同地区有各种各样的特殊性。例如：
      </p>

      <ul>
        <li>
          除了公历日历系统外，其他日历系统也被各个地区积极使用。
        </li>
        <li>
          在处理夏令时/夏时制时，重要的是要了解：1) 并非所有地区都遵循夏令时，2) 开始和结束的日期或时间并不一定相同，3) 调整的幅度或方向并不总是与其他类似地区相匹配。
        </li>
        <li>
          跳秒可能不会在所有软件系统中考虑，尤其是对于在引入跳秒之前的日期和时间。跳秒会影响那些依赖于从纪元开始的精确毫秒偏移的高度敏感系统。然而，请注意，对于大多数应用程序，唯一受影响的时间点是跳秒本身的那一秒。也就是说，最近一次跳秒之后的时刻总是可以表示为下一天的第一个时刻（例如，`2023-01-01T00:00:00Z`），无论所讨论的系统是否理解跳秒。
        </li>
      </ul>

      <p>
        这些只是一些例子，说明实际的一天时间，如墙上的时钟所示，在一个地区可能存在，而在另一个地区可能不存在。因此，实现者应该使用更通用的时间值，如锚定在`Z`时区的值，而不是受夏令时/夏时制影响的值。
      </p>

      <p>
        本规范试图增加通用认可的日期和时间组合的数量，并通过使用首次由[<a data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a>]规范建立的
        `dateTimeStamp`构造来减少时间值误解的可能性。为了减少不同时区之间的误解，所有在[=符合规范的文档=]中表示的时间值都应该以`dateTimeStamp`
        格式指定，要么是世界协调时间（UTC），用`Z`表示，要么是相对于UTC的时区偏移。没有偏移的错误序列化的时间值必须解释为UTC。相对于UTC的有效时区偏移的示例包括`Z`、`+01:00`、`-08:00`和
        `+14:00`。请参阅本节末尾的正则表达式，以获取所有可接受值的正式定义。
      </p>

      <p>
        时区定义有时会被其管理机构更改。在更换或发布新的[=可验证证书=]时，实现者应确保当地时区规则的更改不会导致意外的有效期间隙。例如，考虑时区`America/Los_Angeles`，其原始偏移为UTC-8，并在2024年投票决定停止遵循夏令时。一个给定的[=可验证证书=]，其`validUtil`
        值为`2024-07-12T12:00:00-07:00`，可能会被重新发布，使其`validFrom`值为`2024-07-12T12:00:00-08:00`，这将导致一个小时的间隙，在这个间隙内，[=可验证证书=]将无效。
      </p>

      <p>
        希望检查`dateTimeStamp`值有效性的实现者可以使用下面提供的正则表达式，该正则表达式是从[<a
          data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a>]规范中复制过来的，以方便使用。为避免疑虑，[[XMLSCHEMA11-2]]中的正则表达式是规范性定义。实现者应注意，并非所有通过下面正则表达式的`dateTimeStamp`值都是有效的时间点。例如，下面的正则表达式允许每个月有31天，这包括闰年和闰秒，以及那些不存在的地方的日子。话虽如此，现代系统库生成的`dateTimeStamp`值在生成有效的`dateTimeStamp`值时通常是无误的。下面显示的正则表达式（减去为了可读性而包含的空白），在处理现代系统上库生成的日期和时间时通常是足够的。
      </p>

      <pre class="example nohighlight"
        title="Regular expression to detect a valid XML Schema 1.1: Part 2 dateTimeStamp">
-?([1-9][0-9]{3,}|0[0-9]{3})
-(0[1-9]|1[0-2])
-(0[1-9]|[12][0-9]|3[01])
T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))
(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))
        </pre>

    </section>

    <section>
      <h3>安全机制</h3>

      <p>
        本规范认可两类安全机制：使用封装证明的机制和使用嵌入式证明的机制。
      </p>

      <p>
        一个<dfn class="export">封装证明</dfn>是包裹了此数据模型序列化的证明。[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]中定义了一种建议的封装证明机制。
      </p>

      <p>
        一个<dfn class="export">嵌入式证明</dfn>是一种证明包含在数据模型序列化中的机制。[[[VC-DATA-INTEGRITY]]]
        [[VC-DATA-INTEGRITY]]中定义了一种建议的嵌入式证明机制。
      </p>

      <p>
        这两类安全机制并非互斥。根据第<a href="#securing-mechanism-specifications"></a>节的规则，还可以定义其他安全机制规范。
      </p>

      <pre class="example nohighlight" title="A verifiable credential utilizing an embedded proof">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.gov/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-rdfc-2022",
    "created": "2021-11-13T18:19:39Z",
    "verificationMethod": "https://university.example/issuers/14#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z58DAdFfa9SkqZMVPxAQp...jQCrfFPP2oumHKtz"
  }</span>
}
        </pre>

      <pre class="example nohighlight" title="A verifiable credential that uses an enveloping proof in SD-JWT format">
eyJhbGciOiJFUzM4NCIsImtpZCI6IkdOV2FBTDJQVlVVMkpJVDg5bTZxMGM3U3ZjNDBTLWJ2UjFTT0
Q3REZCb1UiLCJ0eXAiOiJ2YytsZCtqc29uK3NkLWp3dCIsImN0eSI6InZjK2xkK2pzb24ifQ
.
eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvbnMvY3JlZGVudGlhbHMvdjIiLCJodHRwcz
ovL3d3dy53My5vcmcvbnMvY3JlZGVudGlhbHMvZXhhbXBsZXMvdjIiXSwiaXNzdWVyIjoiaHR0cHM6
Ly91bml2ZXJzaXR5LmV4YW1wbGUvaXNzdWVycy81NjUwNDkiLCJ2YWxpZEZyb20iOiIyMDEwLTAxLT
AxVDE5OjIzOjI0WiIsImNyZWRlbnRpYWxTY2hlbWEiOnsiX3NkIjpbIlNFOHp4bmduZTNNbWEwLUNm
S2dlYW1rNUVqU1NfOXRaNlN5NDdBdTdxRWMiLCJjT3lySEVrSlZwdEtSdURtNkNZVTREajJvRkExd0
JQRjFHcTJnWEo1NXpzIl19LCJjcmVkZW50aWFsU3ViamVjdCI6eyJkZWdyZWUiOnsibmFtZSI6IkJh
Y2hlbG9yIG9mIFNjaWVuY2UgYW5kIEFydHMiLCJfc2QiOlsibVNfSVBMa0JHcTIxbVA3Z0VRaHhOck
E0ZXNMc1ZKQ1E5QUpZNDFLLVRQSSJdfSwiX3NkIjpbIlhTSG9iU05Md01PVl9QNkhQMHNvMnZ1clNy
VXZ3UURYREJHQWtyTXk3TjgiXX0sIl9zZCI6WyJQNE5qWHFXa2JOc1NfRzdvdmlLdm1NOG0yckhDTm
5XVVV2SXZBbW9jb2RZIiwieFNvSHBKUXlCNGV1dmg4SkFJdDFCd1pjNFVEOHY5S3ZOTmVLMk9OSjFC
QSJdLCJfc2RfYWxnIjoic2hhLTI1NiIsImlzcyI6Imh0dHBzOi8vdW5pdmVyc2l0eS5leGFtcGxlL2
lzc3VlcnMvNTY1MDQ5IiwiaWF0IjoxNzAzNjI1OTAxLCJleHAiOjE3MzUyNDgzMDEsImNuZiI6eyJq
d2siOnsia3R5IjoiRUMiLCJjcnYiOiJQLTM4NCIsImFsZyI6IkVTMzg0IiwieCI6Inl1Zlo1SFUzcU
NfOTRMbkI3Zklzd0hmT0swQlJra0Z5bzVhd1QyX21ld0tJWUpLMVNfR0QySVB3UjRYUTZpdFEiLCJ5
IjoiRmEtV2pOd2NLQ1RWWHVDU2tCY3RkdHJOYzh6bXdBTTZWOWxudmxxd1QyQnRlQ0ZHNmR6ZDJoMF
VjeXluTDg0dCJ9fX0
.
M7BFJB9LEV_xEylSJpP00fd_4WjrOlXshh0dUv3QgOzw2MEGIfSfi9PoCkHJH7TI0InsqkD6XZVz38
MpeDKekgBW-RoDdJmxnifYOEJhKpJ5EN9PvA007UPi9QCaiEzX
~
WyJFX3F2V09NWVQ1Z3JNTkprOHNXN3BBIiwgImlkIiwgImh0dHA6Ly91bml2ZXJzaXR5LmV4YW1wbG
UvY3JlZGVudGlhbHMvMTg3MiJd
~
WyJTSEc4WnpfRDVRbFMwU0ZrZFUzNXlRIiwgInR5cGUiLCBbIlZlcmlmaWFibGVDcmVkZW50aWFsIi
wgIkV4YW1wbGVBbHVtbmlDcmVkZW50aWFsIl1d
~
WyJqZzJLRno5bTFVaGFiUGtIaHV4cXRRIiwgImlkIiwgImh0dHBzOi8vZXhhbXBsZS5vcmcvZXhhbX
BsZXMvZGVncmVlLmpzb24iXQ
~
WyItQmhzaE10UnlNNUVFbGt4WGVXVm5nIiwgInR5cGUiLCAiSnNvblNjaGVtYSJd~WyJ0SEFxMEUwN
nY2ckRuUlNtSjlSUWRBIiwgImlkIiwgImRpZDpleGFtcGxlOjEyMyJd
~
WyJ1Ynd6bi1kS19tMzRSMGI0SG84QTBBIiwgInR5cGUiLCAiQmFjaGVsb3JEZWdyZWUiXQ
        </pre>

    </section>

    <section>
      <h3>状态</h3>

      <p>
        本规范为[=verifiable credential=]的状态信息（如是否被暂停或撤销）的发现定义了`credentialStatus` [=property=]。
      </p>

      <p>
        下面为与<strong id="defn-credentialStatus">credentialStatus</strong> [=property=]关联的对象值定义了以下属性：
      </p>

      <dl>
        <dt>id</dt>
        <dd>
          `id` [=property=]是可选的。它可以用于为凭证状态对象提供唯一标识符。如果存在，必须遵循第<a href="#identifiers"></a>节的规范性指南。
        </dd>
        <dt>type</dt>
        <dd>
          `type` [=property=]是必需的。它用于表示对象所表达的状态信息的类型。必须遵循第<a href="#types"></a>节的相关规范性指南。
        </dd>
      </dl>

      <p>
        [=credential=]状态信息的确切内容由特定的`credentialStatus`
        [=type=]定义决定，具体取决于诸如实现简单性和是否增强隐私等因素。预期该值将提供足够的信息来确定[=credential=]的当前状态，并且可以从URL检索机器可读信息。例如，对象可以包含指向外部文档的链接，该文档注明[=credential=]是否被暂停或撤销。
      </p>

      <pre class="example nohighlight" title="Usage of the status property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://w3id.org/vc/status-list/2021/v1"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialStatus": {
    "id": "https://university.example/credentials/status/3#94567",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "94567",
    "statusListCredential": "https://university.example/credentials/status/3"
  }</span>
}
        </pre>

      <p>
        定义状态方案的数据模型、格式和协议超出了本规范的范围。存在一个可验证的凭证规范目录
        [[?VC-SPECS]]，其中包含了实施者想要实施[=可验证的凭证=]
        状态检查的可用状态方案。
      </p>

      <p>
        创建状态方案的规范作者提供了以下指南：
      </p>

      <ul>
        <li>
          状态方案绝对不能以使得能够追踪个人的方式实施，例如，当一个[=验证者=]对特定的[=持有人=]
          或[=主题=]感兴趣时，[=发行者=]被通知（直接或间接）。不可接受的方法包括"电话回家"，即
          每次使用凭证都会联系凭证的[=发行者=]，以检查特定个人的状态，或者"伪名减少"，即
          每次使用凭证都会导致从[=发行者=]那里请求信息，这些信息可以被[=发行者=]用来推断
          [=验证者=]对特定个人的兴趣。
        </li>
      </ul>

    </section>

    <section>
      <h3>展示</h3>

      <p>
        [=可验证展示=] 可用于汇总来自多个 [=可验证凭证=] 的信息。
      </p>
      <p>
        [=可验证展示=] 应该非常短暂，并绑定到由 [=验证者=] 提供的挑战。实现这一点的细节取决于安全机制、传输协议和 [=验证者=] 策略。除非特定的安全机制或嵌入协议定义了其他要求，否则 [=验证者=] 通常无法假定
        [=可验证展示=] 与所提供的 [=可验证凭证=] 之间存在任何关联。
      </p>

      <p>
        [=可验证展示=] 的 [=默认图=] 也被称为 <dfn>可验证展示图</dfn>。
      </p>

      <p>
        下面为 [=可验证展示=] 定义了以下属性：
      </p>

      <dl>
        <dt>|id|</dt>
        <dd>
          `id` [=属性=] 是可选的。它可以用于为 [=可验证展示=] 提供唯一标识符。如果存在，必须遵循第 <a href="#identifiers"></a> 节的规范性指南。
        </dd>
        <dt>|type|</dt>
        <dd>
          `type` [=属性=] 必须存在。它用于表示 [=可验证展示=] 的类型。此属性的一个值必须是 `VerifiablePresentation`，但可以包含其他类型。必须遵循第 <a
            href="#types"></a> 节的相关规范性指南。
        </dd>
        <dt><var id="defn-verifiableCredential">verifiableCredential</var></dt>
        <dd>
          `verifiableCredential` [=属性=] 可以存在。该值必须是一个或多个 [=可验证凭证=] 和/或
          <a href="#enveloped-verifiable-credentials">封装的可验证凭证</a>
          对象（明确地说，值不能是非对象值，如数字、字符串或URL）。这些类型的对象称为
          <a href="#verifiable-credential-graphs">可验证凭证图</a>，并且必须使用
          <a href="#securing-mechanisms">安全机制</a>来表达已加密的信息。
          请参阅第 <a href="#verifiable-credential-graphs"></a> 节以获取更多详细信息。
        </dd>
        <dt><var id="defn-holder">holder</var></dt>
        <dd>
          [=可验证展示=] 可以包含一个 `holder`
          [=属性=]。如果存在，其值必须是一个 [=URL=] 或包含 `id` [=属性=] 的对象。建议 `holder` 中的 [=URL=] 或其 `id` 是一个可以解引用的 URL，解引用后会得到一个包含关于
          [=持有者=] 的机器可读信息的文档，该信息可用于 [=验证=] 在 [=可验证展示=] 中表达的信息。
          如果 `holder` [=属性=] 不存在，则预期关于 [=持有者=] 的信息将通过安全机制获得，或者与 [=可验证展示=] 的 [=验证=] 无关。
        </dd>
      </dl>

      <p>
        下面的示例显示了一个 [=可验证展示=]：
      </p>

      <pre class="example nohighlight" title="Basic structure of a presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5",
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{ <span class="comment">...</span> }]
}
        </pre>

      <p>
        上述的 `verifiableCredential` 属性的内容是本规范所描述的可验证凭证图。
      </p>

      <section>
        <h4>封装的可验证凭证</h4>

        <p>
          一个[=可验证的展示=]可以包含一个或多个使用安全机制保护的
          [=可验证的凭证=]，这种安全机制会"封装"载荷，例如[[[?VC-JOSE-COSE]]] [[?VC-JOSE-COSE]]。
          这可以通过将`verifiableCredential`属性与一个`type`为`EnvelopedVerifiableCredential`的对象关联来实现。
        </p>

        <dl>
          <dt id="defn-EnvelopedVerifiableCredential">封装的可验证凭证</dt>
          <dd>
            用于将包含封装的[=可验证凭证=]的对象与[=可验证的展示=]中的`verifiableCredential`属性关联。
            对象的`@context`属性必须存在并包含一个上下文，
            例如<a href="#base-context">此规范的基础上下文</a>，
            至少定义了`id`、`type`和`EnvelopedVerifiableCredential`
            这些术语，这些术语由此规范提供的基础上下文定义。对象的`id`
            值必须是一个`data:` URL [[RFC2397]]，它用
            <a href="#dfn-enveloping-proof">封装</a>的安全方案表达了一个安全的
            [=可验证凭证=]，例如[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]。对象的`type`值必须是
            `EnvelopedVerifiableCredential`。
          </dd>
        </dl>

        <p>
          下面的例子展示了一个包含封装的[=可验证凭证=]的[=可验证的展示=]：
        </p>

        <pre class="example nohighlight" title="Basic structure of a presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "id": "data:application/vc+ld+json+sd-jwt;QzVjV...RMjU",
    "type": "EnvelopedVerifiableCredential"
  }]</span>
}
        </pre>

      </section>

      <section>
        <h4>使用派生凭证的演示</h4>

        <p>
          一些零知识密码学方案可能使[=持有人=]能够
          间接证明他们持有来自[=可验证凭证=]的[=声明=]
          而无需揭示该[=可验证凭证=]中的所有声明。在这些
          方案中，[=可验证凭证=]可用于派生可呈现的
          数据，这些数据经过加密断言，使得[=验证者=]可以信任
          该值（如果他们信任[=颁发者=]）。
        </p>
        <p>
          一些选择性披露方案可以共享从[=可验证凭证=]派生的[=声明=]子集。
        </p>

        <p class="note">
          有关包含派生数据而非直接嵌入[=可验证凭证=]的ZKP风格[=可验证演示=]的示例，请参见第<a href="#zero-knowledge-proofs"></a>节。
        </p>

        <figure>
          <img style="margin: auto; display: block; width: 50%;" src="diagrams/claim-example-2.svg" alt="Pat拥有一个
                 overAge属性，其值为21">
          <figcaption style="text-align: center;">
            表示Pat年龄超过21岁的基本声明。
          </figcaption>
        </figure>
      </section>
      <section>
        <h4>Presentations Including Holder Claims</h4>
        <p>
          A [=holder=] MAY use the `verifiableCredential` [=property=] in
          a [=verifiable presentation=] to include [=verifiable credentials=] from
          any [=issuer=], including themselves. When the [=issuer=] of a
          [=verifiable credential=] is the [=holder=], the [=claims=] in that
          [=verifiable credential=] are considered to be <em>self-asserted</em>.
          Such self-asserted claims can be secured by the same mechanism that secures
          the [=verifiable presentation=] in which they are included or by any
          mechanism usable for other [=verifiable credentials=].
        </p>
        <p>
          The <a href="#dfn-subjects">subject(s)</a> of these self-asserted [=claims=]
          are not limited, so these [=claims=] can include statements about the
          [=holder=], one of the other included [=verifiable credentials=], or even
          the [=verifiable presentation=] in which the self-asserted [=verifiable
          credential=] is included. In each case, the `id` [=property=]
          is used to identify the specific [=subject=], in the object where the
          [=claims=] about it are made, just as it is done in
          [=verifiable credentials=] that are not self-asserted.
        </p>
        <p>
          A [=verifiable presentation=] that includes a self-asserted
          [=verifiable credential=] that is only secured using the same mechanism as
          the [=verifiable presentation=] MUST include a `holder`
          [=property=].
        </p>
        <p>
          All of the normative requirements defined for [=verifiable credentials=]
          apply to self-asserted [=verifiable credentials=].
        </p>
        <p>
          When a self-asserted [=verifiable credential=] is secured using the same
          mechanism as the [=verifiable presentation=], the value of the
          `issuer` [=property=] of the [=verifiable credential=]
          MUST be identical to the `holder` [=property=] of the
          [=verifiable presentation=].
        </p>
        <p>
          The example below shows a [=verifiable presentation=] that embeds a
          self-asserted [=verifiable credential=] that is secured using the same
          mechanism as the [=verifiable presentation=].
        </p>

        <pre class="example nohighlight"
          title="A verifiable presentation, secured with an embedded Data Integrity proof, with a self-asserted verifiable credential">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleFoodPreferenceCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      "favoriteCheese": "Gouda"
    },
    { <span class="comment">...</span> }
  }],
  "proof": [{ <span class="comment">...</span> }]
}
          </pre>
        <p>
          The example below shows a [=verifiable presentation=] that embeds a
          self-asserted [=verifiable credential=] that holds [=claims=] about the
          [=verifiable presentation=]. It is secured using the same mechanism as the
          [=verifiable presentation=].
        </p>

        <pre class="example nohighlight"
          title="A verifiable presentation, secured with an embedded Data Integrity proof, with a self-asserted verifiable credential about the verifiable presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleAssertCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
      "assertion": "This VP is submitted by the subject as evidence of a legal right to drive"
    },
    "proof": { <span class="comment">...</span> }
  }],
  "proof": { <span class="comment">...</span> }
}
          </pre>
      </section>
    </section>

    <section>
      <h3>Data Schemas</h3>

      <p>
        Data schemas are useful when enforcing a specific structure on a given
        collection of data. There are at least two types of data schemas that this
        specification considers:
      </p>

      <ul>
        <li>
          Data verification schemas, which are used to establish that the structure
          and contents of a [=credential=] or [=verifiable credential=] conform to a
          published schema.
        </li>
        <li>
          Data encoding schemas, which are used to map the contents of a
          [=verifiable credential=] to an alternative representation format, such as a
          format used in a zero-knowledge proof.
        </li>
      </ul>

      <p>
        It is important to understand that data schemas serve a different purpose from
        the `@context` property, which neither enforces data structure or
        data syntax, nor enables the definition of arbitrary encodings to alternate
        representation formats.
      </p>
      <p>
        This specification defines the following [=property=] for the expression of a
        data schema, which can be included by an [=issuer=] in
        the [=verifiable credentials=] that it issues:
      </p>

      <dl>
        <dt><var id="defn-credentialSchema">credentialSchema</var></dt>
        <dd>
          <p>
            The value of the `credentialSchema` [=property=] MUST be one or
            more data schemas that provide [=verifiers=] with enough information to
            determine whether the provided data conforms to the provided schema(s). Each
            `credentialSchema` MUST specify its `type` (for example,
            `JsonSchema`), and an `id` [=property=]
            that MUST be a [=URL=] identifying the schema file. The precise contents of
            each data schema is determined by the specific type definition.
          </p>
          <p>
            If multiple schemas are present, validity is determined according to the
            processing rules outlined by each associated `credentialSchema`
            `type` property.
          </p>
        </dd>
      </dl>

      <p class="note">
        The `credentialSchema` [=property=] provides an opportunity to
        annotate type definitions or lock them to specific versions of the vocabulary.
        Authors of [=verifiable credentials=] can include a static version of their
        vocabulary using `credentialSchema` that is locked to some content
        integrity protection mechanism. The `credentialSchema`
        [=property=] also makes it possible to perform syntactic checking on the
        [=credential=] and to use [=verification=] mechanisms such as JSON Schema
        [[?VC-JSON-SCHEMA]] validation.
      </p>

      <pre class="example nohighlight" title="Usage of the credentialSchema property to perform JSON schema validation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential", "ExamplePersonCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    },
    "alumniOf": {
      "name": "Example University"
    }
  },
  <span class="highlight">"credentialSchema": [{
    "id": "https://example.org/examples/degree.json",
    "type": "JsonSchema"
  },
  {
    "id": "https://example.org/examples/alumni.json",
    "type": "JsonSchema"
  }]</span>
}
        </pre>

      <p>
        In the example above, the [=issuer=] is specifying a
        `credentialSchema`, which points to a [[?VC-JSON-SCHEMA]] file that
        can be used by a [=verifier=] to determine whether the
        [=verifiable credential=] is well-formed.
      </p>

      <p class="note">
        For information about linkages to JSON Schema [[?VC-JSON-SCHEMA]] or other
        optional schema validation mechanisms, see the Verifiable Credentials
        Implementation Guidelines [[VC-IMP-GUIDE]] document.
      </p>

      <p>
        Data schemas can also be used to specify mappings to other formats, such as
        those used to perform zero-knowledge proofs. For more information on using the
        `credentialSchema` [=property=] with zero-knowledge proofs,
        see Section <a href="#zero-knowledge-proofs"></a>.
      </p>

      <pre class="example nohighlight"
        title="Usage of the credentialSchema property to perform zero-knowledge validation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialSchema": {
    "id": "https://example.org/examples/degree",
    "type": "ZkpExampleSchema2018"
  }</span>
}
        </pre>

      <p>
        In the example above, the [=issuer=] is specifying a
        `credentialSchema` pointing to a means of transforming the input data
        into a format which can then be used by a [=verifier=] to determine whether
        the proof provided with the [=verifiable credential=] is well-formed.
      </p>


    </section>

  </section>

  <section>
    <h2>Advanced Concepts</h2>

    <p>
      Building on the concepts introduced in Section <a href="#basic-concepts"></a>,
      this section explores more complex topics about [=verifiable credentials=].
    </p>

    <section class="informative">
      <h3>Lifecycle Details</h3>

      <p>
        Section <a href="#ecosystem-overview"></a> provided an overview of the
        [=verifiable credential=] ecosystem. This section provides more detail about
        how the ecosystem is envisaged to operate.
      </p>

      <figure id="life-cycle-details">
        <img style="margin: auto; display: block; width: 85%;" src="diagrams/ecosystemdetail.svg" alt="diagram showing how
         credentials flow from issuer to holder, and optionally
         from one holder to another; and how
         presentations flow from holder to verifier, where
         all parties can use information from a logical
         verifiable data registry">
        <figcaption style="text-align: center;">
          The roles and information flows for this specification.
        </figcaption>
      </figure>

      <p class="issue" title="Validation needs to be added to image.">
        The process of validation needs to be added to the image above.
      </p>

      <p>
        The roles and information flows in the [=verifiable credential=] ecosystem
        are as follows:
      </p>

      <ul>
        <li>
          An [=issuer=] <dfn class="export" data-lt="issue">issues</dfn> a
          [=verifiable credential=] to a [=holder=]. Issuance always occurs before
          any other actions involving a [=credential=].
        </li>
        <li>
          A [=holder=] might <dfn class="export" data-lt="transfers">transfer</dfn> one or more of its [=verifiable
          credentials=] to another [=holder=].
        </li>
        <li>
          A [=holder=] <dfn class="export" data-lt="present">presents</dfn> one or
          more of its [=verifiable credentials=] to a [=verifier=], optionally
          inside a [=verifiable presentation=].
        </li>
        <li>
          A [=verifier=] [=verifies=] the authenticity of the presented
          [=verifiable presentation=] and [=verifiable credentials=] and
          checks any <a href="#status">credential status</a> (if present)
          of the [=verifiable credentials=].
        </li>
        <li>
          After [=verification=], a [=verifier=] validates the relevant claims in
          presented [=verifiable credentials=], using their own business logic to
          evaluate which issuers are appropriate for which claims and which subjects are
          appropriate for the requested use.
        </li>
        <li>
          An [=issuer=] might <dfn class="export" data-lt="revoke">revoke</dfn> a
          [=verifiable credential=].
        </li>
        <li>
          A [=holder=] might <dfn class="export" data-lt="delete">delete</dfn> a
          [=verifiable credential=].
        </li>
      </ul>

      <p class="note">
        The order of the actions above is not fixed, and some actions might be taken
        more than once. Such action-recurrence might be immediate or at any later
        point.
      </p>

      <p>
        The most common sequence of actions is envisioned to be:
      </p>

      <ol>
        <li>
          An [=issuer=] <a href="#lifecycle-details">issues</a> a [=verifiable
          credential=] to a [=holder=].
        </li>
        <li>
          The [=holder=] <a href="#lifecycle-details">presents</a> to a
          [=verifier=].
        </li>
        <li>
          The [=verifier=] <a href="#lifecycle-details">verifies</a>.
        </li>
        <li>
          The [=verifier=] <a href="#lifecycle-details">validates</a> claims.
        </li>
        <li>
          The [=verifier=] applies valid claims</a>.
        </li>
      </ol>

      <p>
        This specification does not define any protocol for transferring
        [=verifiable credentials=] or [=verifiable presentations=], but assuming
        other specifications do specify how they are transferred between entities, then
        this Verifiable Credential Data Model is directly applicable.
      </p>

      <p>
        This specification neither defines an authorization framework nor
        does it restrict the business decisions that a [=verifier=] might make
        after [=verifying=] a [=verifiable credential=] or [=verifiable
        presentation=]. Rather, [=verifiers=]
        apply their own business rules before treating any claim as valid,
        taking into account the [=holder=], the [=issuer=] of the
        [=verifiable credential=], the claims of the
        [=verifiable credential=], and the [=verifier's=] own policies.
      </p>

      <p>
        In particular, Sections <a href="#terms-of-use"></a> and
        the <a href="https://w3c.github.io/vc-imp-guide/#subject-holder-relationships">
          Subject-Holder Relationships</a> section in the Verifiable Credentials
        Implementation Guide [[VC-IMP-GUIDE]] specify how a [=verifier=] can
        determine:
      </p>

      <ul>
        <li>
          Whether the [=holder=] is a [=subject=] of a [=verifiable credential=].
        </li>
        <li>
          The relationship between the [=subject=] and the [=holder=].
        </li>
        <li>
          Whether the original [=holder=] passed a [=verifiable credential=] to a
          subsequent [=holder=].
        </li>
        <li>
          Any restrictions using the [=verifiable credentials=] by the [=holder=]
          or [=verifier=].
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>Trust Model</h3>

      <p>
        The [=verifiable credentials=] trust model is as follows:
      </p>

      <ul>
        <li>
          The [=verifier=] trusts the [=issuer=] to issue the [=credential=] that
          it received. To establish this trust, a [=credential=] is expected to either:
          <ul>
            <li>
              Secure the [=credential=] with a <a href="#securing-mechanisms">securing mechanism</a> establishing that
              the
              [=issuer=] generated the [=credential=] (that is, it is a
              [=verifiable credential=]), or
            </li>
            <li>
              Have been transmitted in a way clearly establishing that the [=issuer=]
              generated the [=verifiable credential=] and that the
              [=verifiable credential=] was not tampered with in transit or storage. This
              trust could be weakened depending on the risk assessment of the [=verifier=].
            </li>
          </ul>
        </li>
        <li>
          All [=entities=] trust the [=verifiable data registry=] to be
          tamper-evident and to be a correct record of which data is controlled by which
          [=entities=].
        </li>
        <li>
          The [=holder=] and [=verifier=] trust the [=issuer=] to issue
          true (that is, not false) [=credentials=] about the [=subject=], and to
          revoke them quickly when appropriate.
        </li>
        <li>
          The [=holder=] trusts the [=repository=] to store [=credentials=]
          securely, to not release them to anyone other than the [=holder=], and to not
          corrupt or lose them while they are in its care.
        </li>
      </ul>

      <p>
        This trust model differentiates itself from other trust models by ensuring
        the:
      </p>

      <ul>
        <li>
          [=Issuer=] and the [=verifier=] do not need to trust the
          [=repository=]
        </li>
        <li>
          [=Issuer=] does not need to know or trust the [=verifier=].
        </li>
      </ul>

      <p>
        By decoupling the trust between the [=identity provider=] and the
        [=relying party=] a more flexible and dynamic trust model is created such
        that market competition and customer choice is increased.
      </p>

      <p>
        For more information about how this trust model interacts with various threat
        models studied by the Working Group, see the Verifiable Credentials Use Cases
        document [[VC-USE-CASES]].
      </p>

      <p class="note">
        The data model detailed in this specification does not imply a transitive trust
        model, such as that provided by more traditional Certificate Authority trust
        models. In the Verifiable Credentials Data Model, a [=verifier=] either
        directly trusts or does not trust an [=issuer=]. While it is possible to
        build transitive trust models using the Verifiable Credentials Data Model,
        implementers are urged to
        <a href="https://datatracker.ietf.org/doc/draft-iab-web-pki-problems/">learn
          about the security weaknesses</a> introduced by
        <a href="https://www.usenix.org/conference/imc-05/perils-transitive-trust-domain-name-system">
          broadly delegating trust</a> in the manner adopted by Certificate Authority
        systems.
      </p>
    </section>

    <section>
      <h3>Extensibility</h3>

      <p>
        One of the goals of the Verifiable Credentials Data Model is to enable
        permissionless innovation. To achieve this, the data model needs to be
        extensible in a number of different ways. The data model is required to:
      </p>

      <ul>
        <li>
          Model complex multi-entity relationships through the use of a [=graph=]-based
          data model.
        </li>
        <li>
          Extend the machine-readable vocabularies used to describe information in the
          data model, without the use of a centralized system for doing so, through the
          use of [[?LINKED-DATA]].
        </li>
        <li>
          Support multiple types of cryptographic proof formats through the use of JOSE or
          COSE [[VC-JOSE-COSE]], Data Integrity Proofs [[VC-DATA-INTEGRITY]], and a
          variety of cryptographic suites listed in the Verifiable Credential
          Specifications Directory [[?VC-SPECS]].
        </li>
        <li>
          Provide all of the extensibility mechanisms outlined above in a data format that
          is popular with software developers and web page authors, and is enabled through
          the use of [[JSON-LD11]].
        </li>
      </ul>

      <p>
        This approach to data modeling is often called an
        <em>open world assumption</em>, meaning that any entity can say anything about
        any other entity. While this approach seems to conflict with building simple and
        predictable software systems, balancing extensibility with program correctness
        is always more challenging with an open world assumption than with closed
        software systems.
      </p>

      <p>
        The rest of this section describes, through a series of examples, how both
        extensibility and program correctness are achieved.
      </p>

      <p>
        Let us assume we start with the [=verifiable credential=] shown below.
      </p>

      <pre class="example nohighlight vc" title="A simple credential"
        data-vc-vm="https://university.example/issuers/14#keys-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe"
  }
}
        </pre>

      <p>
        This [=verifiable credential=] states that the [=entity=] associated with
        `did:example:abcdef1234567` has a `name` with a value of
        `Jane Doe`.
      </p>

      <p>
        Now let us assume a developer wants to extend the [=verifiable credential=]
        to store two additional pieces of information: an internal corporate reference
        number, and Jane's favorite food.
      </p>

      <p>
        The first thing to do is to create a JSON-LD context containing two new terms,
        as shown below.
      </p>

      <pre class="example nohighlight" title="A JSON-LD context">
{
  "@context": {
    "referenceNumber": "https://example.com/vocab#referenceNumber",
    "favoriteFood": "https://example.com/vocab#favoriteFood"
  }
}
        </pre>

      <p>
        After this JSON-LD context is created, the developer publishes it somewhere so
        it is accessible to [=verifiers=] who will be processing the
        [=verifiable credential=]. Assuming the above JSON-LD context is published at
        `https://example.com/contexts/mycontext.jsonld`, we can extend this
        example by including the context and adding the new [=properties=] and
        [=credential=] [=type=] to the [=verifiable credential=].
      </p>

      <pre class="example nohighlight" title="A verifiable credential with a custom extension">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    <span class="highlight">"https://example.com/contexts/mycontext.jsonld"</span>
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential", "CustomExt12"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  <span class="highlight">"referenceNumber": 83294847,</span>
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe",
    <span class="highlight">"favoriteFood": "Papaya"</span>
  }
}
        </pre>

      <p>
        This example demonstrates extending the Verifiable Credentials Data Model in a
        permissionless and decentralized way. The mechanism shown also ensures that
        [=verifiable credentials=] created in this way provide a mechanism to prevent
        namespace conflicts and semantic ambiguity.
      </p>

      <p>
        A dynamic extensibility model such as this does increase the implementation
        burden. Software written for such a system has to determine whether
        [=verifiable credentials=] with extensions are acceptable based on the risk
        profile of the application. Some applications might accept only certain
        extensions while highly secure environments might not accept any extensions.
        These decisions are up to the developers of these applications and are
        specifically not the domain of this specification.
      </p>

      <p>
        Developers are urged to ensure that extension JSON-LD contexts are highly
        available. Implementations that cannot dereference a context will produce an
        error. Strategies for ensuring that extension JSON-LD contexts are always
        available include using content-addressed URLs for contexts, bundling context
        documents with implementations, or enabling aggressive caching of contexts.
      </p>

      <p>
        Implementers are advised to pay close attention to the extension points in this
        specification, such as in Sections <a href="#proofs-signatures"></a>,
        <a href="#status"></a>, <a href="#data-schemas"></a>,<a href="#refreshing"></a>,
        <a href="#terms-of-use"></a>, and <a href="#evidence"></a>. While this
        specification does not define concrete implementations for those extension
        points, the Verifiable Credential Specifications Directory [[?VC-SPECS]]
        provides an unofficial, curated list of extensions that developers can use from
        these extension points.
      </p>

      <section>
        <h4>Semantic Interoperability</h4>

        <ul>
          <li>
            JSON-LD-based processors MUST produce an error when a JSON-LD context redefines
            any term in the
            <a href="https://www.w3.org/TR/json-ld/#dfn-active-context">active context</a>.
            The only way to change the definition of existing terms is to introduce a new
            term that clears the active context within the scope of that new term. Authors
            that are interested in this feature should read about the
            `@protected` feature in the JSON-LD 1.1 specification.
          </li>
        </ul>

        <p>
          A human-readable document describing the expected order of values for the
          `@context` [=property=] is expected to be published by any
          implementer seeking interoperability. A machine-readable description
          (that is, a normal JSON-LD Context document) is expected to be published
          at the URL specified in the `@context` [=property=] by
          JSON-LD implementers seeking interoperability.
        </p>
      </section>
    </section>

    <section>
      <h2>Integrity of Related Resources</h2>
      <p>
        When including a link to an external resource in a [=verifiable credential=],
        it is desirable to know whether the resource that is pointed to is the same at
        signing time as it is at verification time. This applies to cases where there is
        an external resource that is remotely retrieved as well as to cases where the
        [=issuer=] and/or [=verifier=] may have local cached copies of a resource.
      </p>
      <p>
        It is also desirable to know that the contents of the JSON-LD context(s) used in
        the [=verifiable credential=] are the same when used by both the
        [=issuer=] and [=verifier=].
      </p>
      <p>
        To validate that a resource referenced by a [=verifiable credential=] is the
        same at verification time as it is at issuing time, an implementer MAY include a
        property named <code id="defn-relatedResource">relatedResource</code> that
        stores an array of objects that describe additional integrity metadata about
        each resource referenced by the [=verifiable credential=]. If
        `relatedResource` is present, there MUST be an object in the array
        for each remote resource for each context used in the verifiable credential.
      </p>
      <p class="issue" title="Mandatory listing of contexts in relatedResouce are under debate.">
        The requirement that contexts be listed in `relatedResource` is currently being
        debated in the VCWG. This requirement might be removed in future iterations of
        the specification.
      </p>
      <p>
        Each object in the `relatedResource` array MUST contain the
        following: the [[URL]] to the resource named `id` and the
        <code id="defn-digestSRI">digestSRI</code> information for the resource
        constructed using the method specified in
        <a href="https://www.w3.org/TR/SRI/#integrity-metadata">Subresource Integrity</a>.
      </p>
      <p class="issue" title="Unification of cryptographic hash expression formats are under discussion">
        The Working Group is currently attempting to determine whether cryptographic hash
        expression formats can be unified across all of the VCWG core specifications.
        Candidates for this mechanism include `digestSRI` and `digestMultibase`. There
        are arguments for and against unification that the WG is currently debating.
      </p>
      <p>
        There MUST NOT be more than one object in the `relatedResource` per
        `id`.
      </p>
      <p>
        An object in the `relatedResource` array MAY contain a property named
        `mediaType` that indicates the expected media type for the indicated
        `resource`. If a `mediaType` is included, its value
        SHOULD:
      </p>
      <ul>
        <li>
          be a valid media type as listed in the
          <a href="https://www.iana.org/assignments/media-types/media-types.xhtml">
            IANA Media Types</a> registry
        </li>
        <li>
          be used when retrieving the content, such as via the `Accept` HTTP Header
        </li>
        <li>
          match the retrieved content media type, such as via the `Content-Type` HTTP
          Header.
        </li>
      </ul>

      <p>
        Any object in the [=verifiable credential=] that contains an `id` [[URL]]
        property MAY be annotated with integrity information as specified in this
        section by inclusion of `digestSRI`
        in the object.
      </p>
      <p>
        Any objects for which selective disclosure is desired SHOULD NOT be included as
        an object in the `relatedResource` array.
      </p>
      <p>
        Specification authors that write algorithms that fetch a resource based on the
        `id` of an object inside a [=conforming document=] need to consider whether
        that resource's content is vital to the validity of that document. If it is, the
        specification MUST produce a validation error unless the resource has the
        expected media type and its bytes hash to the expected digest.
      </p>
      <p>
        Implementers are urged to consult appropriate sources, such as the
        <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">
          FIPS 180-4 Secure Hash Standard</a> and the
        <a href="https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF">
          Commercial National Security Algorithm Suite 2.0</a> to ensure that they are
        chosing a current and reliable hash algorithm. At the time of this writing
        `sha384` SHOULD be considered the minimum strength hash algorithm for use by
        implementers.
      </p>
      <p class="issue">
        The working group is discussing if we will adopt more aspects of subresource
        integrity as defined in [[SRI]] is adopted into the [[JSON-LD11]] specification as
        noted in that specifications <a href="https://www.w3.org/TR/json-ld11/#security">
          current security considerations</a> of that specification, this hash in the VC
        can serve as an additional check towards ensuring that a cached context used
        when issuing the VC matches the remote resource.
      </p>
      <p>
        An example of a related resource integrity object referencing JSON-LD contexts.
      </p>

      <pre class="example nohighlight" title="Usage of the relatedResource property">
"relatedResource": [{
  "id": "https://www.w3.org/ns/credentials/v2",
  "digestSRI":
    "sha384-lHKDHh0msc6pRx8PhDOMkNtSI8bOfsp4giNbUrw71nXXLf13nTqNJoRp3Nx+ArVK",
},{
  "id": "https://www.w3.org/ns/credentials/examples/v2",
  "digestSRI":
    "sha384-zNNbQTWCSUSi0bbz7dbua+RcENv7C6FvlmYJ1Y+I727HsPOHdzwELMYO9Mz68M26",
}]
        </pre>

      <p>
        An example of an object in a `credentialSubject` that is refering to an
        integrity protected image.
      </p>

      <pre class="example nohighlight" title="An integrity-protected image that is associated with a credentialSubject">
"credentialSubject": {
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "image": {
    "id": "https://university.example.org/images/58473",
    "digestSRI":
      "sha384-ZfAwuJmMgoX3s86L7x9XSPi3AEbiz6S/5SyGHJPCxWHs5NEth/c5S9QoS1zZft+J",
    "mediaType": "application/svg+xml",
  },
  ...
}
        </pre>
    </section>

    <section>
      <h3>Refreshing</h3>

      <p class="issue" title="(AT RISK) Feature depends on demonstration of independent implementations">
        This feature is at risk and will be removed from the specification if at least
        two independent, interoperable implementations are not demonstrated for a
        single extension type by the end of the Candidate Recommendation Phase. If
        this feature is removed, the property will be included in Section
        <a href="#reserved-extension-points"></a>, in anticipation of future
        implementation and inclusion in the specification.
      </p>

      <p>
        It is useful for systems to enable the manual or automatic refresh of an expired
        [=verifiable credential=]. For more information about validity periods for
        [=verifiable credentials=], see Section <a href="#validity-periods"></a>.
        This specification defines a `refreshService` [=property=], which
        enables an [=issuer=] to include a link to a refresh service.
      </p>
      <p>
        The [=issuer=] can include the refresh service as an element inside the
        [=verifiable credential=] if it is intended for either the [=verifier=] or
        the [=holder=] (or both), or inside the [=verifiable presentation=] if it
        is intended for the [=holder=] only. In the latter case, this enables the
        [=holder=] to refresh the [=verifiable credential=] before creating a
        [=verifiable presentation=] to share with a [=verifier=]. In the former
        case, including the refresh service inside the [=verifiable credential=]
        enables either the [=holder=] or the [=verifier=] to perform future
        updates of the [=credential=].
      </p>
      <p>
        The refresh service is only expected to be used when either the
        [=credential=] has expired or the [=issuer=] does not publish
        [=credential=] status information. [=Issuers=] are advised not to put the
        `refreshService` [=property=] in a [=verifiable credential=]
        that does not contain public information or whose refresh service is not
        protected in some way.
      </p>
      <p class="note">
        Placing a `refreshService` [=property=] in a
        [=verifiable credential=] so that it is available to [=verifiers=] can
        remove control and consent from the [=holder=] and allow the
        [=verifiable credential=] to be issued directly to the [=verifier=],
        thereby bypassing the [=holder=].
      </p>

      <dl>
        <dt><var id="defn-refreshService">refreshService</var></dt>
        <dd>
          The value of the `refreshService` [=property=] MUST be one or more
          refresh services that provides enough information to the recipient's software
          such that the recipient can refresh the [=verifiable credential=]. Each
          `refreshService` value MUST specify its `type` (for
          example, `ManualRefreshService2018`) and its `id`, which
          is the [=URL=] of the service. There is an expectation that machine readable
          information needs to be retrievable from the URL. The precise content of
          each refresh service is determined by the specific `refreshService`
          [=type=] definition.
        </dd>
      </dl>

      <pre class="example nohighlight" title="Usage of the refreshService property by an issuer">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"refreshService": {
    "id": "https://university.example/refresh/3732",
    "type": "ManualRefreshService2018"
  }</span>
}
        </pre>

      <p>
        In the example above, the [=issuer=] specifies a manual
        `refreshService` that can be used by directing the [=holder=] or
        the [=verifier=] to `https://university.example/refresh/3732`.
      </p>

    </section>

    <section>
      <h3>Terms of Use</h3>

      <p>
        Terms of use can be utilized by an [=issuer=] or a [=holder=] to
        communicate the terms under which a [=verifiable credential=] or
        [=verifiable presentation=] was issued. The [=issuer=] places their terms
        of use inside the [=verifiable credential=]. The [=holder=] places their
        terms of use inside a [=verifiable presentation=]. This specification defines
        a `termsOfUse` [=property=] for expressing terms of use
        information.
      </p>

      <p>
        The value of the `termsOfUse` [=property=] might be used
        to tell the [=verifier=] any or all of the following, among other things:
      </p>

      <ul>
        <li>
          the procedures or policies that were used in issuing the [=verifiable
          credential=], by providing, for example, a pointer to a public location
          (to avoid "phone home" privacy issues) where these procedures or policies
          can be found, or the name of the standard that defines them
        </li>
        <li>
          the rules and policies of the [=issuer=] that apply to the presentation
          of this [=verifiable credential=] to a [=verifier=], by providing,
          for example, a pointer to a pubic location (to avoid "phone home" privacy
          issues) where these rules or policies can be found
        </li>
        <li>
          the identity of the entity under whose authority the [=issuer=] issued
          this particular [=verifiable credential=]
        </li>
      </ul>

      <dl>
        <dt><var id="defn-termsOfUse">termsOfUse</var></dt>
        <dd>
          The value of the `termsOfUse` [=property=] MUST specify one or
          more terms of use policies under which the creator issued the [=credential=]
          or [=presentation=]. If the recipient (a [=holder=] or
          [=verifier=]) is not willing to adhere to the specified terms of use, then
          they do so on their own responsibility and might incur legal liability if they
          violate the stated terms of use. Each `termsOfUse` value MUST specify
          its [=type=], for example, `IssuerPolicy`, and MAY specify its
          instance `id`. The precise contents of each term of use is determined
          by the specific `termsOfUse` [=type=] definition.
        </dd>
      </dl>

      <pre class="example nohighlight" title="Usage of the termsOfUse property by an issuer">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:did:123456",
  "type": [
    "VerifiableCredential",
    "EbsiTermsOfUseExample"
  ],
  "issuer": "did:ebsi:zz7XsC9ixAXuZecoD9sZEM1",
  "validFrom": "2021-11-01T00:00:00Z",
  "validUntil": "2021-10-30T00:00:00Z",
  "credentialSubject": {
    "id": "did:key:z2dmzD81cgPx8Vki7JbuuMmFYrWPgYoytykUZ3eyqht1j9KbrDt4zxXoDrBWYFiATYZ8G9JMeEXC7Kki24fbTwtsJbGe5qcbkYFunSzcDokMRmj8UJ1PbdCGh33mf97K3To89bMzd15qrYq3VkDztoZqfmujkJVpvTbqoXWXqxmzNDbvMJ",
    "personalIdentifier": "IT/DE/1234",
    "familyName": "Castafiori",
    "firstName": "Bianca",
    "dateOfBirth": "1930-10-01"
  },
  "credentialSchema": {
    "id": "https://api-test.ebsi.eu/trusted-schemas-registry/v2/schemas/z3MgUFUkb722uq4x3dv5yAJmnNmzDFeK5UC8x83QoeLJM",
    "type": "JsonSchema"
  },
  "termsOfUse": {
    "id": "https://api-test.ebsi.eu/trusted-issuers-registry/v4/issuers/did:ebsi:zz7XsC9ixAXuZecoD9sZEM1/attributes/7201d95fef05f72667f5454c2192da2aa30d9e052eeddea7651b47718d6f31b0",
    "type": "IssuanceCertificate"
  }
}
        </pre>

      <p>
        In the example above, the [=issuer=] is asserting that as a European
        Blockchain Services Infrastructure (EBSI) accredited issuer, it complies with the EBSI
        policies as an accredited issuer and is registered in the EBSI register of trusted issuers.
        The `termsOfUse` [=id=] can be resolved by the [=verifier=] to confirm
        that the [=issuer=] has been issued an accreditation VC (in JWT format)
        by a trusted issuer higher in the EBSI trust chain [?EBSI].
      </p>

      <pre class="example nohighlight" title="Usage of the termsOfUse property by a holder">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    {
        "@protected": true,
        "VerifiablePresentationTermsOfUseExtension": {
          "@id": "https://www.w3.org/2018/credentials/examples#VerifiablePresentationExtension",
          "@context": {
            "@protected": true,
            "termsOfUse": {
              "@id": "https://www.w3.org/2018/credentials#termsOfUse",
              "@type": "@id"
            }
          }
        }
    }
  ],
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/3732",
    "type": ["VerifiableCredential", "ExampleDegreeCredential"],
    "issuer": "https://university.example/issuers/14",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "degree": {
        "type": "ExampleBachelorDegree",
        "name": "Bachelor of Science and Arts"
      }
    }
  }],
  <span class="highlight">"termsOfUse": [{
    "type": "HolderPolicy",
    "id": "http://example.com/policies/credential/6",
    "profile": "http://example.com/profiles/credential",
    "prohibition": [{
      "assigner": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "assignee": "https://wineonline.example.org/",
      "target": "http://university.example/credentials/3732",
      "action": ["3rdPartyCorrelation"]
    }]
  }]</span>
}
        </pre>

      <p>
        In the example above, the [=holder=] (the `assigner`), who is
        also the [=subject=], expressed a term of use prohibiting the [=verifier=]
        (the `assignee`, `https://wineonline.example.org`) from
        using the information provided to correlate the [=holder=] or [=subject=]
        using a third-party service. If the [=verifier=] were to use a third-party
        service for correlation, they would violate the terms under which the
        [=holder=] created the [=presentation=].
      </p>

      <p>
        This feature is also expected to be used by government-issued
        [=verifiable credentials=] to instruct digital wallets to limit their use to
        similar government organizations in an attempt to protect citizens from
        unexpected usage of sensitive data. Similarly, some
        [=verifiable credentials=] issued by private industry are expected to limit
        usage to within departments inside the organization, or during business hours.
        Implementers are urged to read more about this rapidly evolving feature in the
        appropriate section of the Verifiable Credentials Implementation Guidelines
        [[?VC-IMP-GUIDE]] document.
      </p>

    </section>

    <section>
      <h3>Evidence</h3>

      <p class="issue" data-number="1303"
        title="(AT RISK) Feature depends on demonstration of independent implementations">
        This feature is at risk and will be removed from the specification if at least
        two independent, interoperable implementations are not demonstrated for a
        single extension type by the end of the Candidate Recommendation Phase. If
        this feature is removed, the property will be included in Section
        <a href="#reserved-extension-points"></a>, in anticipation of future
        implementation and inclusion in the specification.
      </p>

      <p>
        Evidence can be included by an [=issuer=] to provide the [=verifier=] with
        additional supporting information in a [=verifiable credential=]. This could
        be used by the [=verifier=] to establish the confidence with which it relies
        on the claims in the [=verifiable credential=].
      </p>
      <p>
        For example, an [=issuer=] could check physical documentation provided by the
        [=subject=] or perform a set of background checks before issuing the
        [=credential=]. In certain scenarios, this information is useful to the
        [=verifier=] when determining the risk associated with relying on a given
        [=credential=].
      </p>

      <p>
        This specification defines the `evidence` [=property=] for
        expressing evidence information.
      </p>

      <dl>
        <dt><dfn id="defn-evidence" class="export">evidence</dfn></dt>
        <dd>
          The value of the `evidence` [=property=] MUST be one or more
          evidence schemes providing enough information for a [=verifier=] to determine
          whether the evidence gathered by the [=issuer=] meets its confidence
          requirements for relying on the [=credential=]. Each evidence scheme is
          identified by its [=type=]. The `id` [=property=] is optional,
          but if present, SHOULD contain a URL that points to where more information about
          this instance of evidence can be found. The precise content of each evidence
          scheme is determined by the specific `evidence` [=type=]
          definition.
        </dd>
      </dl>

      <p class="note">
        For information about how attachments and references to [=credentials=] and
        non-credential data might be supported by the specification, see the
        Verifiable Credentials Implementation Guidelines [[VC-IMP-GUIDE]] document.
      </p>

      <pre class="example nohighlight" title="Usage of the evidence property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"evidence": {
    "id": "https://university.example/evidence/f2aeec97-fc0d-42bf-8ca7-0548192d4231",
    "type": ["DocumentVerification"],
    "verifier": "https://university.example/issuers/14",
    "evidenceDocument": "DriversLicense",
    "subjectPresence": "Physical",
    "documentPresence": "Physical",
    "licenseNumber": "123AB4567"
  }</span>
}
        </pre>

      <p class="note">
        In this `evidence` example, the [=issuer=] is asserting that they
        physically matched the [=subject=] of the [=credential=] to a physical
        copy of a driver's license with the stated license number. This driver's license
        was used in the issuance process to verify that "Example University" verified
        the subject before issuance of the credential and how they did so (physical
        verification).
      </p>

      <p class="note">
        The `evidence` [=property=] provides information that is different from and
        information to the securing mechanism utilized. The `evidence`
        [=property=] is used to express supporting information, such as documentary
        evidence, related to the integrity of the [=verifiable credential=]. In
        contrast, the securing mechanism is used to express
        machine-verifiable mathematical proofs related to the authenticity of the
        [=issuer=] and integrity of the [=verifiable credential=]. For more
        information about securing mechanisms, see Section
        <a href="#securing-mechanisms"></a>.
      </p>

    </section>

    <section>
      <h3>Zero-Knowledge Proofs</h3>

      <p>
        Zero-knowledge proofs are cryptographic methods which enable a user to prove
        knowledge of a value without disclosing the actual value. This data model
        supports being secured with the use of zero-knowledge proof mechanisms.
      </p>
      <p>
        Some capabilities that are compatible with [=verifiable credentials=] which
        are made possible by zero-knowledge proof mechanisms:
      </p>
      <ul>
        <li>
          Selective disclosure of the properties in a [=verifiable credential=] by the
          [=holder=] to a [=verifier=]. This allows a [=holder=] to provide a
          [=verifier=] with precisely the information they need and nothing more.
          This also enables the production of a derived [=verifiable credential=] that
          is formatted according to the [=verifier's=] data schema without needing to
          involve the [=issuer=] during presentation. This provides a great deal of
          flexibility for [=holders=] to use their issued
          [=verifiable credentials=].
        </li>
        <li>
          Blinding of the signature value that is shared with a [=verifier=]. Blinded
          signatures allow for unlinkable proofs, which remove a common source of
          [=holder=] correlation during multiple presentations to one or more
          [=verifiers=]. This allows a [=holder=] to share a different signature
          value with each presentation, which in turn reduces the amount of data shared.
        </li>
        <li>
          Privacy preserving identification of the [=holder=] and/or [=subject=].
          This allows a [=holder=] to prove that a [=credential=] was issued to
          them, or a [=subject=] to prove that a [=credential=] was issued about
          them, without sharing an identifier. This also reduces the amount of data
          necessary to be shared. This capability can also be used to combine multiple
          [=verifiable credentials=] from multiple [=issuers=] into a single
          [=verifiable presentation=] without revealing [=verifiable credential=] or
          [=subject=] identifiers to the [=verifier=].
        </li>
      </ul>
      <p>
        Not all capabilities are supported in all zero-knowledge proof mechanisms.
        Specific details about the capabilities and techniques provided by a particular
        zero knowledge proof mechanism, along with any normative requirements for using
        them with [=verifiable credentials=], would be found in a specification for
        securing [=verifiable credentials=] with that zero-knowledge proof mechanism.
      </p>
      <p>
        We note that in most instances, for [=holder=] to make use of zero knowledge
        mechanisms with [=verifiable credentials=] requires an [=issuer=] to
        secure the [=verifiable credential=] in a manner that supports these
        capabilities.
      </p>
      <p>
        When a [=holder=] has selectively disclosed a portion of a
        [=verifiable credential=], it is important that the [=verifier=] check
        whether the information provided in the derived [=verifiable credential=] is
        compatible with the schema in the `credentialSchema`
        [=property=] provided by the [=issuer=]. It is also possible for the
        [=verifier=] to provide a schema to the [=holder=] as part of a request
        for the [=holder=]'s data, and for the [=verifier=] to ensure that the
        derived [=verifiable credential=] is compatible with that schema as well. We
        do not define such a request schema in this specification, but an example of one
        method for doing so is [[?PRES-EX]].
      </p>
      <p class="note">
        `credentialSchema` implementers are encouraged to consider the
        implications of selective disclosure credentials and provide guidance for
        processing depending on the construction. If a schema is not formed with
        selective disclosure in mind, then validation is likely to fail.
      </p>
      <p>
        The diagram below highlights how the data model might be used to issue and
        present [=verifiable credentials=] in zero-knowledge.
      </p>
      <p class="issue">
        Examples of leveraging <a href="https://w3c.github.io/vc-di-bbs/">vc-di-bbs</a>,
        will be added here in the future, or this section will be removed.
      </p>

      <figure>
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/zkp-cred-pres.svg" alt="Verifiable
            Credential 1 and Verifiable Credential 2 on the left map
            to Derived Credential 1 and Derived Credential 2 inside a
            Presentation on the right.  Verifiable Credential 1
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains GivenName, FamilyName, and
            Birthdate and Proof contains Signature, Proof of
            Correctness, and Attributes.  Verifiable Credential 2
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains University, which contains
            Department, which contains DegreeAwarded, and Proof contains Signature, Proof of
            Correctness, and Attributes.  The Presentation diagram on
            the right contains Context, Type, ID,
            VerifiableCredential, and Proof, where
            VerifiableCredential contains Derived Credential 1 and
            Derived Credential 2 and Proof contains Common Link
            Secret.  Derived Credential 1 contains Context, Type, ID,
            Issuer, Issue Date, CredentialSubject, and Proof, where
            CredentialSubject contains AgeOver18 and Proof contains
            Knowledge of Signature.  Derived Credential 2 contains
            Context, Type, ID, Issuer, Issue Date, CredentialSubject,
            and Proof, where CredentialSubject contains Degree and
            Proof contains Knowledge of Signature.  A line links
            Birthdate in Verifiable Credential 1 to AgeOver18 in
            Derived Credential 1.  A line links DegreeAwarded in
            Verifiable Credential 2 to Degree in Derived Credential 2.">
        <figcaption style="text-align: center;">
          A visual example of the relationship between credentials and derived
          credentials in a ZKP [=presentation=].
        </figcaption>
      </figure>

      <p>
        The following guideline is provided for authors who create
        <a href="#securing-mechanisms">securing mechanisms</a>
        specifications that provide unlinkability:
      </p>

      <ul>
        <li>
          Unlinkable securing mechanisms MUST NOT be designed in such a way that they
          leak information that would enable the [=verifier=] to correlate a
          [=holder=] across multiple [=verifiable presentations=] to different
          [=verifiers=].
        </li>
      </ul>

    </section>

    <section class="informative">
      <h3>Authorization</h3>

      <p>
        [=Verifiable credentials=] are intended as a means of reliably identifying
        [=subjects=]. While it is recognized that Role Based Access Controls (RBACs)
        and Attribute Based Access Controls (ABACs) rely on this identification as a
        means of authorizing [=subjects=] to access resources, this specification
        does not provide a complete solution for RBAC or ABAC. Authorization is not an
        appropriate use for this specification without an accompanying authorization
        framework.
      </p>

      <p>
        The Working Group did consider authorization use cases during the creation of
        this specification and is pursuing that work as an architectural layer built
        on top of this specification.
      </p>
    </section>

    <section class="normative">
      <h3>Reserved Extension Points</h3>

      <p>
        This specification reserves a number of [=properties=] to serve as possible
        extension points. While some implementers signaled interest in these properties,
        their inclusion in this specification was considered to be premature; these
        extension points might be more formally defined in future versions of this
        specification. It is important to note that these properties are not defined by
        this specification and implementers are cautioned that usage of these properties
        is considered experimental.
      </p>
      <p>
        Implementers MAY use these properties, but SHOULD expect them and/or
        their meanings to change during the process to normatively specify them.
        Implementers SHOULD NOT use these properties without a publicly disclosed
        specification describing their implementation.
      </p>

      <p>
        In order to avoid collisions regarding how the following properties are used,
        implementations MUST specify a `type` property in the value associated with the
        reserved property. For more information related to adding `type` information,
        see Section <a href="#types"></a>.
      </p>
      <p class="issue" title="Extension points under consideration by the Working Group">
        The working group is discussing if additional extension points
        will be reserved in <a href="https://www.w3.org/ns/credentials/v2">https://www.w3.org/ns/credentials/v2</a>.
        <br /><br />
        The working group currently plans to only reserve extension points that
        have at least a draft specification that is being incubated in a community group.
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>Reserved&nbsp;Property</th>
            <th>Description</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>`confidenceMethod`</td>
            <td>
              A property used for specifying one or more methods that a verifier might use to
              increase their confidence that the value of an attribute in or of a verifiable
              credential or verifiable presentation is accurate, including but not limited to
              attributes such as `initialRecipient` (a/k/a `issuee`), `presenter`,
              `authorizedPresenter`, `holder`, etc. The associated vocabulary URL MUST be
              `https://www.w3.org/2018/credentials#confidenceMethod`.
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                This property reservation might be deleted in favor of an existing section
                in the specification if at least one specification with two independent
                implementations are demonstrated by the end of the Candidate Recommendation
                Phase. If that does not occur, this reservation will remain, but the existing
                section in the specification will be removed.
                See <a href="https://w3c-ccg.github.io/confidence-method-spec/">Verifiable Credential Confidence
                  Methods</a>.
              </p>
            </td>
          </tr>
          <tr>
            <td>`evidence`</td>
            <td>
              A property used for specifying the evidence that was presented in order to
              issue the credential. The associated vocabulary URL MUST be
              `https://www.w3.org/2018/credentials#evidence`.
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                This property reservation might be deleted in favor of an existing section
                in the specification if at least one specification with two independent
                implementations are demonstrated by the end of the Candidate Recommendation
                Phase. If that does not occur, this reservation will remain, but the existing
                section in the specification will be removed.
              </p>
            </td>
          </tr>
          <tr>
            <td>`refreshService`</td>
            <td>
              A property used for specifying how a credential can be refreshed. The
              associated vocabulary URL MUST be
              `https://www.w3.org/2018/credentials#refreshService`.
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                This property reservation might be deleted in favor of an existing section
                in the specification if at least one specification with two independent
                implementations are demonstrated by the end of the Candidate Recommendation
                Phase. If that does not occur, this reservation will remain, but the existing
                section in the specification will be removed.
              </p>
            </td>
          </tr>
          <tr>
            <td>`renderMethod`</td>
            <td>
              A property used for specifying one or more methods to render a credential into a visual,
              auditory, or haptic format. The associated vocabulary URL MUST be
              `https://www.w3.org/2018/credentials#renderMethod`.
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                This reserved property is at risk and will be removed from the
                specification if at least one specification with two independent implementations
                are not demonstrated by the end of the Candidate Recommendation Phase.
                See <a href="https://w3c-ccg.github.io/vc-render-method/">Verifiable Credential Rendering Methods</a>.
              </p>
            </td>
          </tr>
          <tr>
            <td>`termsOfUse`</td>
            <td>
              A property used for specifying the terms of use for a credential. The associated
              vocabulary URL MUST be `https://www.w3.org/2018/credentials#termsOfUse`.
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                This property reservation might be deleted in favor of an existing section
                in the specification if at least one specification with two independent
                implementations are demonstrated by the end of the Candidate Recommendation
                Phase. If that does not occur, this reservation will remain, but the existing
                section in the specification will be removed.
              </p>
            </td>
          </tr>
        </tbody>
      </table>


      <p>
        An unofficial list of specifications that are associated with the extension
        points defined in this specification, as well as the reserved extension points
        defined in this section, can be found in the Verifiable Credentials
        Specifications Directory [[?VC-SPECS]]. Items in the directory that refer to
        reserved extension points SHOULD be treated as experimental.
      </p>

    </section>

    <section class="normative">
      <h3>Ecosystem Compatibility</h3>

      <p>
        There are a number of digital credential formats that do not natively use the
        data model provided in this document, but are aligned with a number of concepts
        in this specification. At the time of publication, examples of these digital
        credential formats include
        <a href="https://www.rfc-editor.org/rfc/rfc7519.html">
          JSON Web Tokens</a> (JWTs),
        <a href="https://www.rfc-editor.org/rfc/rfc8392.html">
          CBOR Web Tokens</a> (CWTs),
        <a href="https://www.iso.org/standard/69084.html">ISO-18013-5:2021</a>
        (mDLs),
        <a href="https://hyperledger.github.io/anoncreds-spec/">
          AnonCreds</a>,
        <a href="https://datatracker.ietf.org/doc/draft-mcnally-envelope/">
          Gordian Envelopes</a>, and
        <a href="https://datatracker.ietf.org/doc/draft-ssmith-acdc/">
          Authentic Chained Data Containers</a> (ACDCs).
      </p>

      <p>
        If conceptually aligned digital credential formats can be transformed into a
        [=conforming document=] according to the rules provided in this section, they
        are considered <em>"compatible with the W3C Verifiable Credentials
          ecosystem"</em>. Specifications that describe how to perform transformations
        that enable compatibility with the Verifiable Credentials ecosystem:
      </p>

      <ul>
        <li>
          MUST identify whether the transformation to this data model is one-way-only or
          round-trippable.
        </li>
        <li>
          MUST preserve the `@context` values when performing round-trippable
          transformation.
        </li>
        <li>
          MUST result in a [=conforming document=] when transforming to the data
          model described by this specification.
        </li>
        <li>
          MUST specify a registered media type for the input document.
        </li>
        <li>
          SHOULD provide a test suite that demonstrates that the specified transformation
          algorithm to the data model in this specification results in
          a [=conforming document=].
        </li>
        <li>
          SHOULD ensure that all semantics utilized in the transformed
          [=conforming document=] follow best practices for Linked Data. See
          Section <a href="#getting-started"></a>, Section
          <a href="#extensibility"></a>, and Linked Data Best Practices [[?LD-BP]]
          for additional guidance.
        </li>
      </ul>

      <p class="note" title="What constitutes a verifiable credential?">
        Readers are advised that a digital credential is only considered compatible with
        the W3C Verifiable Credentials ecosystem if it is a [=conforming document=]
        and it utilizes at least one securing mechanism, as described by their
        respective requirements in this specification. While some communities might call
        some digital credential formats that are not [=conforming documents=]
        "verifiable credentials", doing so does NOT make that digital credential
        compliant to this specification.
      </p>

    </section>

    <section>
      <h3>Verifiable Credential Graphs</h3>

      <p>
        When expressing [=verifiable credentials=] (for example in a
        [=presentation=]), it is important to ensure that data in one [=verifiable
        credential=] is not mistaken to be the same data in another [=verifiable
        credential=]. For example, if one has two [=verifiable credentials=], each
        containing an object of the following form: `{"type": "Person", "name": "Jane
        Doe"}`, it is not possible to tell if one object is describing the same person
        as the other object. In other words, merging data between two [=verifiable
        credentials=] without confirming that they are discussing the same entities
        and/or properties, can lead to a corrupted data set.
      </p>

      <p>
        To ensure that data from different [=verifiable credentials=] are not
        accidentally co-mingled, the concept of a <dfn class="export">verifiable
          credential graph</dfn> is used to encapsulate each [=verifiable credential=].
        For simple [=verifiable credentials=], i.e., when the JSON-LD document
        contains a single credential with, possibly, associated proofs, this graph is
        the [=default graph=]. For [=presentations=], each value associated with
        the `verifiableCredential` property of the [=presentation=] is a separate
        [=named graph=] of type <dfn class="export">VerifiableCredentialGraph</dfn>
        which contains a single [=verifiable credential=] or an
        <a href="#enveloped-verifiable-credentials">enveloped verifiable credential</a>.
      </p>
      <p>
        Using these [=graphs=] has a concrete effect when performing JSON-LD
        processing, which properly separates graph node identifiers in one graph from
        those in another graph. Implementers that limit their inputs to
        application-specific JSON-LD documents will also need to keep this in mind if
        they merge data from one [=verifiable credential=] with data from another,
        such as when the `credentialSubject.id` is the same in both [=verifiable
        credentials=], but the object might contain objects of the "Jane Doe" form
        described in the previous paragraph. It is important to not merge objects that
        seem to have similar properties but do not contain an `id` property that uses a
        global identifier, such as a URL.
      </p>
    </section>

    <section>
      <h3>Securing Mechanism Specifications</h3>

      <p>
        As described in Section <a href="#securing-mechanisms"></a>, there are
        multiple strategies that an implementer can use when securing a
        [=conforming document=]. In order to maximize utility and interoperability,
        specification authors that desire to author new ways of securing
        [=conforming documents=] are provided with the guidance in this section.
      </p>

      <p>
        Securing mechanism specifications MUST document normative algorithms that
        provide content integrity protection for [=conforming documents=]. The
        algorithms MAY be general in nature and MAY be used to secure data other than
        [=conforming documents=].
      </p>

      <p>
        Securing mechanism specifications MUST provide a verification mechanism that
        returns only the information in the [=conforming document=] that has been
        secured, without any securing mechanism information included, such as `proof` or
        JOSE/COSE header parameters and signatures. Specifications MAY provide additional mechanisms to convey
        other information that might be helpful (for example, during validation or for
        debugging purposes), such as securing mechanism data. A securing mechanism's
        verification algorithm MUST provide an interface that receives a sequence of
        bytes ([=byte sequence=] |inputBytes|) or a document ([=map=] |inputDocument|)
        and a media type ([=string=] |inputMediaType|) as inputs and returns a
        verification result with at least the following [=struct/items=]:
      </p>

      <dl>
        <dt>[=boolean=] |status|</dt>
        <dd>
          A verification status whose value is `true` if the verification succeeded and
          `false` if it did not.
        </dd>
        <dt>[=map=] |document|</dt>
        <dd>
          A document that only contains information that was successfully secured.
        </dd>
        <dt>[=string=] |mediaType|</dt>
        <dd>
          A media type as defined in [[RFC6838]].
        </dd>
      </dl>

      <p class="issue atrisk" title="Controller document reference might change">
        The Working Group is currently attempting to align the definitions of a
        controller document between [[[?DID-CORE]]], [[[?VC-DATA-INTEGRITY]]], and
        [[[?VC-JOSE-COSE]]]. The goal is to have one specification that each of the
        previously stated specifications, and this specification, can reference for
        the normative statements related to controller documents. The normative
        references to controller documents are expected to change during the
        Candidate Recommendation phase.
      </p>

      <p>
        Securing mechanism specifications SHOULD provide integrity protection for any
        information referenced by a URL that is critical to validation. Mechanisms that
        can achieve this protection are discussed in Section
        <a href="#integrity-of-related-resources"></a> and Section
        <a href="#base-context"></a>.
      </p>

      <p>
        Securing mechanism specifications that create new types of [=embedded proofs=]
        MUST specify a [=property=] for securing both [=verifiable credentials=] and
        [=verifiable presentations=]. The requirements for the property used by the
        embedded securing mechanism are as follows:
      </p>

      <ul>
        <li>
          The property MUST relate the [=verifiable credential=] or [=verifiable
          presentation=] to a separable and securable [=proof graph=].
        </li>
        <li>
          The property MUST define all terms used by the [=proof graph=]. For example,
          the mechanism could define vocabulary specifications and `@context` files
          in the same manner as they are utilized by this specification.
        </li>
        <li>
          In a [=verifiable credential=], the property MUST secure the
          [=default graph=].
        </li>
        <li>
          In a [=verifiable presentation=], the property MUST secure the
          [=default graph=] of the [=presentation=] as well as every [=proof graph=]
          related to each [=verifiable credential=] in the [=presentation=].
        </li>
        <li>
          The `proof` property as defined in [[VC-DATA-INTEGRITY]] MAY be used by the
          embedded securing mechanism.
        </li>
      </ul>

      <p>
        Securing mechanism specifications SHOULD register the securing mechanism in the
        <a data-cite="?VC-SPECS#securing-mechanisms">Securing Mechanisms</a> section
        of the [[[?VC-SPECS]]] [[?VC-SPECS]].
      </p>

      <p class="note" title="Choice of securing mechanism is use-case dependent">
        There are multiple acceptable securing mechanisms, and this specification does
        not mandate any particular securing mechanism for use with
        [=verifiable credentials=] or [=verifiable presentations=].
        The Working Group that produced this specification did standardize two
        securing mechanism options, which are:
        [[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]] and [[[VC-JOSE-COSE]]]
        [[VC-JOSE-COSE]]. Other securing mechanisms that are known to the community
        can be found in the
        <a data-cite="?VC-SPECS#securing-mechanisms">Securing Mechanisms</a> section
        of the [[[?VC-SPECS]]] [[?VC-SPECS]].
      </p>

    </section>

  </section>

  <section>
    <h2>Syntaxes</h2>

    <p>
      The data model as described in Sections
      <a href="#core-data-model"></a>, <a href="#basic-concepts"></a>, and
      <a href="#advanced-concepts"></a> is the canonical structural representation of
      a [=verifiable credential=] or [=verifiable presentation=]. All
      serializations are representations of that data model in a specific format. This
      section specifies how the data model is realized in JSON-LD for
      `application/vc+ld+json`, the base media type for Verifiable Credentials.
      Although syntactic mappings are only provided for JSON-LD, applications and
      services can use any other data representation syntax (such as XML, YAML, or
      CBOR) that is capable of being mapped back to `application/vc+ld+json`. As the
      [=verification=] and [=validation=] requirements are defined in terms of
      the data model, all serialization syntaxes have to be deterministically
      translated to the data model for processing, [=validation=], or comparison.
    </p>

    <p>
      The expected arity of the property values in this specification, and the
      resulting datatype which holds those values, can vary depending on the property.
      If present, the following properties are represented as a single value:
    </p>

    <ul>
      <li>
        `id` [=property=]
      </li>
      <li>
        `issuer` [=property=]
      </li>
      <li>
        `validFrom` [=property=]
      </li>
      <li>
        `validUntil` [=property=].
      </li>
    </ul>

    <p>
      All other properties, if present, are represented as either a single value
      or an array of values.
    </p>

    <section>
      <h3>JSON-LD</h3>

      <p>
        [[!JSON-LD11]] is a JSON-based format used to serialize
        <a href="https://www.w3.org/TR/ld-glossary/#linked-data">Linked Data</a>. The
        syntax is designed to easily integrate into deployed systems already using JSON,
        and provides a smooth upgrade path from JSON to [[!JSON-LD11]]. It is primarily
        intended to be a way to use Linked Data in Web-based programming environments,
        to build interoperable Web services, and to store Linked Data in JSON-based
        storage engines.
      </p>

      <p>
        [[!JSON-LD11]] is useful when extending the data model described in this
        specification. Instances of the data model are encoded in JSON-LD compacted
        form [[!JSON-LD11]] and include the `@context` [=property=]. The
        <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD context</a>
        is described in detail in the [[!JSON-LD11]] specification and its use is
        elaborated on in Section <a href="#contexts"></a> and
        Section <a href="#extensibility"></a>.
      </p>

      <p>
        Multiple contexts MAY be used or combined to express any arbitrary information
        about [=verifiable credentials=] in idiomatic JSON. The
        <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD context</a>,
        available at `https://www.w3.org/ns/credentials/v2`, is a static
        document that is never updated and can therefore be downloaded and cached client
        side. The associated vocabulary document for the Verifiable Credentials Data
        Model is available at `https://www.w3.org/2018/credentials`.
      </p>

      <p>
        This specification restricts the usage of JSON-LD representations of
        the data model. JSON-LD <a href="https://www.w3.org/TR/json-ld/#compacted-document-form">compacted document
          form</a> MUST be utilized for all representations of the data model in the
        base media type, `application/vc+ld+json`.
      </p>

      <p>
        As elaborated upon in Section
        <a href="#credential-type-specific-processing"></a>, some software applications
        might not perform generalized JSON-LD processing. Authors of [=conforming
        documents=] are advised that interoperability might be reduced if JSON-LD
        keywords in the `@context` value are used to globally affect values in a
        [=verifiable credential=] or [=verifiable presentation=], such as by
        globally setting the `@base` keyword. For example, globally setting these values
        might trigger a failure in a mis-implemented JSON Schema check on the `@context`
        value in an implementation that is performing [=credential type-specific
        processing=] and not expecting the `@base` value to be expressed in the
        `@context` value.
      </p>

      <p>
        In order to increase interoperability, [=conforming document=] authors are
        urged to not use JSON-LD features that are not easily detected when performing
        [=credential type-specific processing=]. These features include:
      </p>

      <ul>
        <li>
          Use of JSON-LD keywords in the `@context` value that globally modify document
          value processing, such as global settings of `@base`
        </li>
        <li>
          In-line declaration of JSON-LD contexts in the `@context` property.
        </li>
        <li>
          Use of full URLs for JSON-LD terms and types (e.g.,
          `https://www.w3.org/2018/credentials#VerifiableCredential` or
          `https://vocab.example/myvocab#SomeNewType`) instead of the short forms of
          any such values (e.g., `VerifiableCredential` or `SomeNewType`) that are
          either explicitly defined as JSON-LD `@context` mappings (e.g.,
          `https://www.w3.org/ns/credentials/v2`) or are implicitly defined via the
          `@vocab` feature that applies to all undefined terms.
        </li>
      </ul>

      </p>

      <section>
        <h3>Syntactic Sugar</h3>

        <p>
          In general, the data model and syntaxes described in this document are
          designed such that developers can copy and paste examples to incorporate
          [=verifiable credentials=] into their software systems. The design goal of
          this approach is to provide a low barrier to entry while still ensuring global
          interoperability between a heterogeneous set of software systems. This section
          describes some of these approaches, which will likely go unnoticed by most
          developers, but whose details will be of interest to implementers. The most
          noteworthy syntactic sugars provided by [[!JSON-LD11]] are:
        </p>

        <ul>
          <li>
            The `@id` and `@type` keywords are aliased to
            `id` and `type` respectively, enabling developers to use
            this specification as idiomatic JSON.
          </li>
          <li>
            Data types, such as integers, dates, units of measure, and URLs, are
            automatically typed to provide stronger type guarantees for use cases that
            require them.
          </li>
          <li>
            The `verifiableCredential` [=property=]
            is defined as a
            <a href="https://www.w3.org/TR/json-ld11/#graph-containers">JSON-LD 1.1 graph
              container</a>. This requires the creation of [=named graphs=], used to isolate
            sets of data asserted by different entities. This ensures, for example, proper
            cryptographic separation between the data graph provided by each [=issuer=]
            and the one provided by the [=holder=] presenting the [=verifiable
            credential=] to ensure the provenance of the information for each graph is
            preserved.
          </li>
          <li>
            The `@protected` properties feature of [[!JSON-LD11]] 1.1 is used to
            ensure that terms defined by this specification cannot be overridden. This means
            that as long as the same `@context` declaration is made at the top of
            a [=verifiable credential=] or [=verifiable presentation=],
            interoperability is guaranteed for all terms understood by users of the data
            model whether or not they use a [[!JSON-LD11]] processor.
          </li>
        </ul>
      </section>
      <section>
        <h3>Lists and Arrays</h3>
        <p>
          Lists, arrays, and even lists of lists, are possible when using [[JSON-LD11]] 1.1.
          We encourage those who want RDF semantics in use
          cases requiring lists and arrays to follow the guidance on
          <a href="https://www.w3.org/TR/json-ld11/#lists">lists in JSON-LD 1.1</a>.
        </p>
        <p>
          In general, a JSON array is ordered, while a JSON-LD array is not ordered unless
          that array uses the `@list` keyword.
        </p>
        <p class="note">
          While it is possible to use this data model without any JSON-LD processing,
          those who do so and make use of arrays need to be aware that unless the above
          guidance is followed, the order of items in an array cannot be guaranteed in
          JSON-LD. This might lead to unexpected behavior.
        </p>
        <p>
          If JSON structure or ordering is important to your application,
          we recommend you mark such elements as `@json` via an `@context`.
        </p>
        <pre class="example" title="A @context file that defines a matrix as an embedded JSON data structure">
{
  "@context":
    {
      "matrix": {
        "@id": "https://website.example/vocabulary#matrix",
        "@type": "@json"
      }
    }
}
          </pre>
        <pre class="example" title="A verifiable credential with an embedded JSON data structure">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    "https://website.example/matrix/v1"
  ],
  "id": "http://university.example/credentials/1872",
  "type": [
    "VerifiableCredential",
    "ExampleMatrixCredential"
  ],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "matrix": [
      [1,2,3,4,5,6,7,8,9,10,11,12],
      [1,1,1,1,1,1,1,1,0,0,0,0],
      [0,0,1,1,1,1,1,1,1,0,0,0]
    ]
  }
}
          </pre>
      </section>
    </section>
    <section>
      <h3>Media Types</h3>

      <p>
        Media types, as defined in [[RFC6838]], identify the syntax used to express a
        [=verifiable credential=] as well as other useful processing guidelines.
      </p>
      <p>
        Syntaxes used to express the data model in this specification SHOULD be
        identified by a media type, and conventions outlined in this section SHOULD be
        followed when defining or using media types with [=verifiable credentials=].
      </p>
      <p>
        There are two media types associated with the core data model, which are
        listed in the Section <a href="#iana-considerations"></a>:
        `application/vc+ld+json` and `application/vp+ld+json`.
      </p>
      <p>
        The `application/vc+ld+json` and `application/vp+ld+json` media types do not
        imply any particular securing mechanism, but are intended to be used in
        conjunction with securing mechanisms. A securing mechanism needs to be applied
        to protect the integrity of these media types. Do not assume security of content
        regardless of the media type used to communicate it.
      </p>

      <section class="informative">
        <h3>Media Type Precision</h3>

        <p>
          At times, developers or systems might use lower precision media types to convey
          [=verifiable credentials=] or [=verifiable presentations=]. Some of the
          reasons for use of lower precision media types include:
        </p>

        <ul>
          <li>
            A web server defaults to `text/plain` or `application/octet-stream` when a file
            extension is not available and it cannot determine the media type.
          </li>
          <li>
            A developer adds a file extension that leads to a media type that is less
            specific than the content of the file. For example, `.json` could result in a
            media type of `application/json` and `.jsonld` might result in a media type of
            `application/ld+json`.
          </li>
          <li>
            A protocol requires a less precise media type for a particular transaction; for
            example, `application/json` instead of `application/vp+ld+json`,
          </li>
        </ul>

        <p>
          Implementers are urged to not raise errors when it is possible to determine the
          intended media type from a payload, provided that the media type used is
          acceptable in the given protocol. For example, if an application only accepts
          payloads that conform to the rules associated with the `application/vc+ld+json`
          media type, but the payload is tagged with `application/json` or
          `application/ld+json` instead, the application might perform the following
          steps to determine whether the payload also conforms to the higher precision
          media type:
        </p>

        <ol>
          <li>
            Parse the payload as a JSON document.
          </li>
          <li>
            Ensure that the first element of the `@context` field matches
            `https://www.w3.org/2018/credentials/v2`.
          </li>
          <li>
            Assume an `application/vp+ld+json` media type if the JSON document contains a
            top-level `type` field containing a `VerifiablePresentation` element. Additional
            subsequent checks are still expected to be performed (according to this
            specification) to ensure the payload expresses a conformant Verifiable
            Presentation.
          </li>
          <li>
            Assume an `application/vc+ld+json` media type if the JSON document contains a
            top-level `type` field containing a `VerifiableCredential` element. Additional
            subsequent checks are still expected to be performed (according to this
            specification) to ensure the payload expresses a conformant Verifiable
            Credential.
          </li>
        </ol>

        <p>
          Whenever possible, implementers are advised to use the most precise (the highest
          precision) media type for all payloads defined by this specification.
          Implementers are also advised to recognize that a payload tagged with a lower
          precision media type does not mean that the payload does not meet the rules
          necessary to tag it with a higher precision type. Similarly, a payload tagged
          with a higher precision media type does not mean that the payload will meet the
          requirements associated with the media type. Receivers of payloads, regardless
          of their associated media type, are expected to perform appropriate checks to
          ensure that payloads conform with the requirements for their use in a given
          system.
        </p>
      </section>
      <section class="informative">
        <h2>HTTP</h2>
        <p>
          It is expected that HTTP endpoints will use the media types associated with
          [=verifiable credentials=] and [=verifiable presentations=] in accept
          headers and when indicating content types.
        </p>
        <p>
          Nonetheless, HTTP servers might ignore the accept header and return another
          content type, or return an error code such as
          <a data-cite="RFC7231#section-6.5.13">`415 Unsupported Media Type`</a>.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>Credential Type-Specific Processing</h2>

      <p>
        <dfn>General JSON-LD processing</dfn> is defined as a mechanism that utilizes a
        JSON-LD software library to process a [=conforming document=] by performing
        various <a data-cite="?JSON-LD11#forms-of-json-ld">transformations</a>.
        <dfn>Credential type-specific processing</dfn> is defined as a lighter-weight
        mechanism for processing [=conforming documents=], that doesn't require
        a JSON-LD software library. Some consumers of [=verifiable credentials=]
        only need to consume credentials with specific types. These consumers can use
        credential-type-specific processing instead of generalized processing. Scenarios
        where credential-type-specific processing can be desirable include, but are not
        limited to, the following:
      </p>

      <ul>
        <li>
          Before applying a securing mechanism to a [=conforming document=], or after
          verifying a [=conforming document=] protected by a securing mechanism, to
          ensure
          <a href="https://csrc.nist.gov/glossary/term/data_integrity">data integrity</a>.
        </li>
        <li>
          When performing JSON Schema validation, as described in Section
          <a href="#data-schemas"></a>.
        </li>
        <li>
          When serializing or deserializing [=verifiable credentials=] or
          [=verifiable presentations=] into systems that store or index their contents.
        </li>
        <li>
          When operating on [=verifiable credentials=] or [=verifiable
          presentations=] in a software application, after verification or validation
          is performed for securing mechanisms that require
          [=general JSON-LD processing=].
        </li>
        <li>
          When an application chooses to process the media type using the `+json`
          structured media type suffix.
        </li>
      </ul>

      <p>
        That is, [=credential type-specific processing=] is allowed as long as the
        document being consumed or produced is a [=conforming document=]. If this
        type of processing is desired, an implementer is advised to follow this rule:
      </p>

      <ul>
        <li>
          Ensure that all values associated with a `@context` property are in the
          expected order, the contents of the context files match known good
          cryptographic hashes for each file, and domain experts have deemed that the
          contents are appropriate for the intended use case.
        </li>
      </ul>

      <p>
        Using static context files with a JSON Schema is one acceptable approach to
        implementing the rule above. This can ensure proper term identification,
        typing, and order, when performing [=credential type-specific processing=].
      </p>

      <p>
        The rule above guarantees semantic interoperability between the two processing
        mechanisms for mapping literal JSON keys to URIs via the `@context` mechanism.
        While [=general JSON-LD processing=] can use previously unseen `@context`
        values provided in its algorithms to verify that all terms are correctly
        specified, implementations that perform [=credential type-specific
        processing=] only accept specific `@context` values which the implementation
        is engineered ahead of time to understand, resulting in the same semantics
        without invoking any JSON-LD APIs. In other words, the context in which the data
        exchange happens is explicitly stated for both processing mechanisms by using
        `@context` in a way that leads to the same [=conforming document=] semantics.
      </p>

    </section>

  </section>

  <section class="normative">
    <h2>Algorithms</h2>

    <p>
      This section contains algorithms that can be used by implementations to perform
      common operations, such as verification. Conformance requirements phrased as
      algorithms utilize normative concepts from the [[[INFRA]]] [[INFRA]]. See the
      section on <a data-cite="INFRA#conformance">Conformance</a> in the [[[INFRA]]]
      for more guidance on implementation requirements.
    </p>

    <p class="issue atrisk" title="Issues need resolution before Candidate Recommendation">
      There is one issue that is associated with this section that will need
      to be resolved before the Working Group can enter the Candidate Recommendation
      phase. This entire section is at risk until those issues are resolved.
    </p>

    <p class="issue" data-number="1377"></p>

    <p class="note" title="Implementers can include additional checks, warnings, and errors.">
      Implementers are advised that the algorithms in this section contain the bare
      minimum set of checks used by implementations to test conformance to this
      specification. Implementations are expected to provide additional checks that
      report helpful warnings for developers to help debug potential issues.
      Similarly, implementations are likely to provide additional checks that
      could result in new types of errors being reported in order to stop harmful
      content. Any of these additional checks might be integrated into future
      versions of this specification.
    </p>

    <section class="normative">
      <h3>Verification</h3>

      <p>
        This section contains an algorithm that [=conforming verifier
        implementations=] MUST run when verifying a [=verifiable credential=] or a
        [=verifiable presentation=]. This algorithm takes a sequence of bytes
        ([=byte sequence=] |inputBytes|) or a document
        ([=map=] |inputDocument|) and a media type
        ([=string=] |inputMediaType|) as inputs, and returns a [=map=]
        that contains the following:
      </p>

      <ul>
        <li>
          a status ([=boolean=] |status|)
        </li>
        <li>
          a [=conforming document=] ([=map=] |document|)
        </li>
        <li>
          a media type ([=string=] |mediaType|)
        </li>
        <li>
          a controller of the verification method associated with the securing mechanism
          ([=string=] |controller|)
        </li>
        <li>
          a controller document that is associated with the verification method used
          to verify the securing mechanism ([=map=] |controllerDocument|)
        </li>
        <li>
          zero or more warnings ([=list=] of [=ProblemDetails=] |warnings|)
        </li>
        <li>
          zero or more errors ([=list=] of [=ProblemDetails=] |errors|)
        </li>
      </ul>

      <p>
        The verification algorithm is as follows:
      </p>

      <ol class="algorithm">
        <li>
          Ensure that the securing mechanism has properly protected the
          [=conforming document=] by performing the following steps:
          <ol class="algorithm">
            <li>
              Set the |verifyProof| function by using the |inputMediaType| and the
              <a data-cite="?VC-SPECS#securing-mechanisms">Securing Mechanisms</a> section of
              the [[[?VC-SPECS]]] [[?VC-SPECS]], or other mechanisms known to the
              implementation, to determine the cryptographic suite to use when verifying
              the securing mechanism. The |verifyProof| function MUST implement the interface
              described in <a href="#securing-mechanisms"></a>.
              <div class="issue" title="Mechanism for 'determining' is being detailed">
                At present, the Working Group is concerned that the algorithm for "determining"
                might need to be more formally defined. At present, no implementation has
                had an issue determining the proper |verifyProof| algorithm to use, but the
                Working Group is attempting to see if saying more here would be worthwhile.
                Additional example language could be added that says that an implementation
                might have an allow list of acceptable cryptosuites -- and these will be used as
                inputs for finding matching proofs to be verified.
              </div>
            </li>
            <li>
              Set |result| to the result of passing |inputBytes| and
              |inputMediaType| to the |verifyProof| function. If the call was
              successful, |result| will contain the |status|,
              |document|, |mediaType|, |controller|,
              |controllerDocument|, |warnings|, and |errors|
              properties.
            </li>
            <li>
              If |result|.|status| is set to `false`, add a
              <a href="#CRYPTOGRAPHIC_SECURITY_ERROR">CRYPTOGRAPHIC_SECURITY_ERROR</a> to
              |result|.|errors|.
            </li>
          </ol>
        </li>
        <li>
          If |result|.|status| is set to `true`, ensure that
          |result|.|document| is a [=conforming document=]. If it is
          not, set |result|.|status| to `false`, remove the
          |document| property from |result|, and add at least
          one <a href="#MALFORMED_VALUE_ERROR">MALFORMED_VALUE_ERROR</a> to
          |result|.|errors|. Other warnings and errors MAY be included
          to aid any debugging process.
        </li>
        <li>
          Return |result|.
        </li>
      </ol>

      <p>
        The steps for verifying the state of the securing mechanism and verifying
        that the input document is a [=conforming document=] MAY be performed in
        a different order than that provided above as long as the
        implementation returns errors for the same invalid inputs.
        Implementations MAY produce different errors than described above.
      </p>

    </section>

    <section>
      <h3>Problem Details</h3>

      <p>
        When an implementation detects an anomaly while processing a document, a
        <dfn>ProblemDetails</dfn> object can be used to report the issue to other
        software systems. The interface for these types of objects follows [[RFC9457]]
        to encode the data. A [=ProblemDetails=] object consists of the following
        properties:
      </p>

      <dl>
        <dt>type</dt>
        <dd>
          The `type` [=property=] MUST be present and its value MUST be a [=URL=]
          identifying the type of problem.
        </dd>
        <dt>code</dt>
        <dd>
          The `code` [=property=] is OPTIONAL.
          present, its value MUST be an integer that identifies the type of the problem.
          Integer codes are useful in systems that only provide integer return values.
        </dd>
        <dt>title</dt>
        <dd>
          The `title` [=property=] MUST be present and its value SHOULD provide a short
          but specific human-readable string for the problem.
        </dd>
        <dt>detail</dt>
        <dd>
          The `detail` [=property=] MUST be present and its value SHOULD provide a
          longer human-readable string for the problem.
        </dd>
      </dl>

      <p>
        The following problem description types and codes are defined by this
        specification:
      </p>

      <dl>
        <dt id="PARSING_ERROR">
          https://www.w3.org/TR/vc-data-model#PARSING_ERROR
          (-64)
        </dt>
        <dd>
          There was an error while parsing input.
        </dd>
        <dt id="CRYPTOGRAPHIC_SECURITY_ERROR">
          https://www.w3.org/TR/vc-data-model#CRYPTOGRAPHIC_SECURITY_ERROR
          (-65)
        </dt>
        <dd>
          The securing mechanism for the document has detected a
          modification in the contents of the document since it was created;
          potential tampering detected. See Section
          <a href="#verification"></a>.
        </dd>
        <dt id="MALFORMED_VALUE_ERROR">
          https://www.w3.org/TR/vc-data-model#MALFORMED_VALUE_ERROR
          (-66)
        </dt>
        <dd>
          The value associated with a particular [=property=] is malformed. The
          name of the [=property=] and the path to the property SHOULD be provided
          in the [=ProblemDetails=] object. See Section
          <a href="#verification"></a>.
        </dd>
        <dt id="RANGE_ERROR">
          https://www.w3.org/TR/vc-data-model#RANGE_ERROR
          (-67)
        </dt>
        <dd>
          A provided value is outside of the expected range of an associated value,
          such as a given index value for an array being larger than the current size
          of the array.
        </dd>
      </dl>

      <p>
        Implementations MAY extend the [=ProblemDetails=] object by specifying
        additional types, codes, or properties. See the
        <a data-cite="RFC9457#name-extension-members">Extension Member</a> section
        in [[RFC9457]] for further guidance on using this mechanism.
      </p>

    </section>

  </section>

  <section class="informative">
    <h2>Privacy Considerations</h2>

    <p>
      This section details the general privacy considerations and specific privacy
      implications of deploying the Verifiable Credentials Data Model into production
      environments.
    </p>

    <section class="informative">
      <h3>Spectrum of Privacy</h3>

      <p>
        It is important to recognize there is a spectrum of privacy ranging from
        pseudonymous to strongly identified. Depending on the use case, people have
        different comfort levels about what information they are willing to provide
        and what information can be derived from what is provided.
      </p>

      <figure>
        <img style="margin: auto; display: block; width: 80%;" src="diagrams/privacy-spectrum.svg" alt="Horizontal bar with
            red on the left, orange in the middle, and green on the
            right.  The red has the text 'Highly correlatable (global
            IDs), e.g., government ID, shipping address, credit card
            number'.  The orange has the text 'Correlatable via collusion
            (personally identifiable info), e.g., name, birthday, zip
            code'.  The green has the text 'Non-correlatable
            (pseudonyms), e.g., age over 21'.">
        <figcaption style="text-align: center;">
          Privacy spectrum ranging from pseudonymous to fully identified.
        </figcaption>
      </figure>

      <p>
        For example, most people probably want to remain anonymous when purchasing
        alcohol because the regulatory check required is solely based on whether a
        person is above a specific age. Alternatively, for medical prescriptions
        written by a doctor for a patient, the pharmacy fulfilling the prescription is
        required to more strongly identify the medical professional and the patient.
        Therefore there is not one approach to privacy that works for all use cases.
        Privacy solutions are use case specific.
      </p>

      <p class="note">
        Even for those wanting to remain anonymous when purchasing alcohol, photo
        identification might still be required to provide appropriate assurance to the
        merchant. The merchant might not need to know your name or other details (other
        than that you are over a specific age), but in many cases just proof of age
        might still be insufficient to meet regulations.
      </p>

      <p>
        The Verifiable Credentials Data Model strives to support the full privacy
        spectrum and does not take philosophical positions on the correct level of
        anonymity for any specific transaction. The following sections provide guidance
        for implementers who want to avoid specific scenarios that are hostile to
        privacy.
      </p>
    </section>

    <section class="informative">
      <h3>Software Trust Boundaries</h3>

      <p>
        A variety of trust relationships exist in the
        <a href="#ecosystem-overview">ecosystem described by this specification</a>. An
        individual using a web browser trusts the web browser, also known as a <a
          href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a>, to preserve
        that trust by not uploading their personal information to a data broker;
        similarly, entities filling the roles in the ecosystem described by this
        specification trust the software that operates on behalf of each of those roles.
        Examples include the following:
      </p>

      <ul>
        <li>
          An [=issuer's=]
          <a href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a>
          (issuer software), such as an online education platform, is expected to only
          issue [=verifiable credentials=] to individuals that the issuer asserts
          have completed their educational program.
        </li>
        <li>
          A [=verifier's=]
          <a href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a>
          (verification software), such as a hiring website, is expected to only allow
          access to individuals with a valid verification status for
          [=verifiable credentials=] and [=verifiable presentations=] provided to
          the platform by such individuals.
        </li>
        <li>
          A [=holder's=]
          <a href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a>
          (holder software), such as a digital wallet, is expected to only divulge
          information to a [=verifier=] when the [=holder=] has consented to
          the release of that information.
        </li>
      </ul>

      <p>
        The examples above are not exhaustive, and the users in these roles can also
        expect a variety of other things from the software they use to achieve their
        goals. In short, the software is expected to operate in the best interests
        of the user, and a violation of that expectation is a violation of trust
        that will result in the software being replaced by something that does not
        violate that trust. Implementers are strongly advised to write software that
        does not violate the trust of the users it will serve. Implementers are
        also advised to provide auditing features in the software that they create
        such that the users, or trusted third parties, can check whether the software
        is indeed behaving in their best interests.
      </p>

      <p>
        Readers are advised that some software, such as a website that provides services
        to a single [=verifier=] and multiple [=holders=], might operate as a
        <a href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a> to both
        roles, but might not always be able to simultaneously operate in the best
        interests of all parties. For example, if that website detects an attempt at
        fraudulent [=verifiable credential=] use among multiple [=holders=], it
        might report such an anomaly to the [=verifier=], which might be considered
        to not be in the best interest of the [=holder=] committing the violation,
        but would be in the best interest of the [=verifier=] as well as any
        [=holders=] <em>not</em> committing such a violation. It is strongly advised
        that when software operates in this manner, that it is made clear in whose best
        interest the software is operating through mechanisms such as a website usage
        policy.
      </p>
    </section>

    <section class="informative">
      <h3>Personally Identifiable Information</h3>

      <p>
        Data associated with [=verifiable credentials=] stored in the
        `credential.credentialSubject` field is susceptible to privacy
        violations when shared with [=verifiers=]. Personally identifying data, such
        as a government-issued identifier, shipping address, and full name, can be
        easily used to determine, track, and correlate an [=entity=]. Even
        information that does not seem personally identifiable, such as the
        combination of a birthdate and a postal code, has very powerful correlation
        and de-anonymizing capabilities.
      </p>

      <p>
        Implementers are strongly advised to warn [=holders=] when they share data
        with these kinds of characteristics. [=Issuers=] are strongly advised to
        provide privacy-protecting [=verifiable credentials=] when possible. For
        example, issuing `ageOver` [=verifiable credentials=] instead of
        date of birth [=verifiable credentials=] when a [=verifier=] wants to
        determine whether an [=entity=] is over the age of 18.
      </p>

      <p>
        Because a [=verifiable credential=] often contains personally identifiable
        information (PII), implementers are strongly advised to use mechanisms while
        storing and transporting [=verifiable credentials=] that protect the data
        from those who should not access it. Mechanisms that could be considered include
        Transport Layer Security (TLS) or other means of encrypting the data while in
        transit, as well as encryption or data access control mechanisms to protect
        the data in a [=verifiable credential=] while at rest.
      </p>
    </section>

    <section class="informative">
      <h3>Identifier-Based Correlation</h3>

      <p>
        [=Subjects=] of [=verifiable credentials=] are identified using the
        `credential.credentialSubject.id` field. The identifiers used to
        identify a [=subject=] create a greater risk of correlation when the
        identifiers are long-lived or used across more than one web domain.
      </p>

      <p>
        Similarly, disclosing the [=credential=] identifier
        (`credential.id`) leads to situations where multiple
        [=verifiers=], or an [=issuer=] and a [=verifier=], can collude to
        correlate the [=holder=]. If [=holders=] want to reduce correlation, they
        should use [=verifiable credential=] schemes that allow hiding the
        identifier during [=verifiable presentation=]. Such schemes expect the
        [=holder=] to generate the identifier and might even allow hiding the
        identifier from the [=issuer=], while still keeping the identifier embedded
        and signed in the [=verifiable credential=].
      </p>

      <p>
        If strong anti-correlation properties are a requirement in a
        [=verifiable credentials=] system, it is strongly advised that identifiers
        are either:
      </p>

      <ul>
        <li>
          Bound to a single origin
        </li>
        <li>
          Single-use
        </li>
        <li>
          Not used at all, but instead replaced by short-lived, single-use bearer tokens.
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>Signature-Based Correlation</h3>

      <p>
        The contents of a [=credential=] are secured using a securing mechanism.
        Values used to represent the securing mechanism
        create a greater risk of correlation when the same values are used across more
        than one session or domain and the value does not change.
      </p>

      <p>
        If strong anti-correlation properties are required, it is advised that
        signature values and metadata are regenerated each time using technologies like
        third-party pairwise signatures, zero-knowledge proofs, or group signatures.
      </p>

      <p class="note">
        Even when using anti-correlation signatures, information might still be
        contained in a [=verifiable credential=] that defeats the anti-correlation
        properties of the cryptography used.
      </p>
    </section>

    <section class="informative">
      <h3>Long-Lived Identifier-Based Correlation</h3>

      <p>
        [=Verifiable credentials=] might contain long-lived identifiers that could
        be used to correlate individuals. These types of identifiers include
        [=subject=] identifiers, email addresses, government-issued identifiers,
        organization-issued identifiers, addresses, healthcare vitals,
        [=verifiable credential=]-specific JSON-LD contexts, and many other sorts of
        long-lived identifiers.
      </p>

      <p>
        Organizations providing software to [=holders=] should strive to identify
        fields in [=verifiable credentials=] containing information that could be
        used to correlate individuals and warn [=holders=] when this information is
        shared.
      </p>
    </section>

    <section class="informative">
      <h3>Metadata-based Correlation</h3>

      <p>
        The use of different extension points described in Section
        <a href="#basic-concepts"></a> and Section <a href="#advanced-concepts"></a>
        can serve as an unintentional or unwanted correlation mechanism if the number
        of [=issuers=] using a specific extension type or combination of types
        is relatively small.
        For example, the use of certain types of cryptography that are only used by
        particular nation states, or revocation formats used by specific jurisdictions,
        or credential types used by specific localities, can be used as a mechanism
        to reduce the pseudonymity that a [=holder=] might expect to have when
        performing a selective disclosure of information to a [=verifier=].
      </p>

      <p>
        [=Issuers=] are urged to reduce metadata-based correlation possibilities when
        issuing [=verifiable credentials=] that are expected to be used in a
        pseudonymous fashion by reducing the types of extensions that can be used to
        narrow the pseudonymity of the [=holder=]. Using credential types,
        extensions, and technology profiles that have global use is preferred over ones
        that have national use, which are preferred over ones that only have local use.
      </p>
    </section>

    <section class="informative">
      <h3>Device Tracking and Fingerprinting</h3>

      <p>
        There are mechanisms external to [=verifiable credentials=] that are used to
        track and correlate individuals on the Internet and the Web. Some of these
        mechanisms include Internet protocol (IP) address tracking, web browser
        fingerprinting, evercookies, advertising network trackers, mobile network
        position information, and in-application Global Positioning System (GPS) APIs.
        Using [=verifiable credentials=] cannot prevent the use of these other
        tracking technologies. Also, when these technologies are used in conjunction
        with [=verifiable credentials=], new correlatable information could be
        discovered. For example, a birthday coupled with a GPS position can be used to
        strongly correlate an individual across multiple websites.
      </p>

      <p>
        It is recommended that privacy-respecting systems prevent the use of these
        other tracking technologies when [=verifiable credentials=] are being used.
        In some cases, tracking technologies might need to be disabled on devices that
        transmit [=verifiable credentials=] on behalf of a [=holder=].
      </p>

      <p>
        The Oblivious HTTP protocol [[?OHTTP]] is one mechanism that implementers might
        consider using when fetching external resources that are associated with a
        [=verifiable credential=] or a [=verifiable presentation=].
        Oblivious HTTP allows a client to make multiple requests to an origin server
        without that server being able to link those requests to that client or even to
        identify those requests as having come from a single client, while placing only
        limited trust in the nodes used to forward the messages. Hence, Oblivious HTTP
        is one privacy-preserving mechanism that can be used to reduce the possibility
        of device tracking and fingerprinting. Concrete examples for how Oblivious HTTP
        can benefit ecosystem participants are included below.
      </p>

      <ul>
        <li>
          A [=holder=] using a digital wallet can reduce the chances that they
          will be tracked by a 3rd party when accessing external links within a
          [=verifiable credential=] stored in their digital wallet.
          For example, a digital wallet might fetch and render linked images, or
          check the validity of a [=verifiable credential=] by fetching an
          externally linked revocation list.
        </li>
        <li>
          A [=verifier=] can reduce signalling to an [=issuer=] that the
          [=verifier=] has received a specific [=verifiable credential=].
          For example, a [=verifier=] might fetch an externally linked revocation
          list while performing status checks on a [=verifiable credential=].
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>Favor Abstract Claims</h3>

      <p>
        To enable recipients of [=verifiable credentials=] to use them in a variety
        of circumstances without revealing more PII than necessary for transactions,
        [=issuers=] should consider limiting the information published in a
        [=credential=] to a minimal set needed for the expected purposes. One way to
        avoid placing PII in a [=credential=] is to use an abstract [=property=]
        that meets the needs of [=verifiers=] without providing specific information
        about a [=subject=].
      </p>
      <p>
        For example, this document uses the `ageOver` [=property=]
        instead of a specific birthdate, which constitutes much stronger PII. If
        retailers in a specific market commonly require purchasers to be older than a
        certain age, an [=issuer=] trusted in that market might choose to offer a
        [=verifiable credential=] claiming that [=subjects=] have met that
        requirement instead of offering [=verifiable credentials=] containing
        [=claims=] about specific birthdates. This enables individual customers to
        make purchases without revealing specific PII.
      </p>
    </section>

    <section class="informative">
      <h3>The Principle of Data Minimization</h3>

      <p>
        Privacy violations occur when information divulged in one context leaks into
        another. Accepted best practice for preventing such violations is to limit the
        information requested, and received, to the absolute minimum necessary. This
        data minimization approach is required by regulation in multiple jurisdictions,
        including the Health Insurance Portability and Accountability Act (HIPAA) in the
        United States and the General Data Protection Regulation (GDPR) in the European
        Union.
      </p>
      <p>
        With [=verifiable credentials=], data minimization for [=issuers=] means
        limiting the content of a [=verifiable credential=] to the minimum required
        by potential [=verifiers=] for expected use. For [=verifiers=], data
        minimization means limiting the scope of the information requested or
        required for accessing services.
      </p>
      <p>
        For example, a driver's license containing a driver's ID number, height, weight,
        birthday, and home address is a [=credential=] containing more information
        than is necessary to establish that the person is above a certain age.
      </p>

      <p>
        It is considered best practice for [=issuers=] to atomize information or use
        a signature scheme that allows for [=selective disclosure=]. For example, an
        [=issuer=] of driver's licenses could issue a [=verifiable credential=]
        containing every attribute that appears on a driver's license, as well as a set
        of [=verifiable credentials=] where every [=verifiable credential=]
        contains only a single attribute, such as a person's birthday. It could also
        issue more abstract [=verifiable credentials=] (for example, a
        [=verifiable credential=] containing only an `ageOver` attribute).
        One possible adaptation would be for [=issuers=] to provide secure HTTP
        endpoints for retrieving single-use [=bearer credentials=] that promote the
        pseudonymous usage of [=verifiable credentials=]. Implementers that find this
        impractical or unsafe, should consider using [=selective disclosure=] schemes
        that eliminate dependence on [=issuers=] at proving time and reduce temporal
        correlation risk from [=issuers=].
      </p>

      <p>
        [=Verifiers=] are urged to only request information that is absolutely
        necessary for a specific transaction to occur. This is important for at least
        two reasons. It:
      </p>

      <ul>
        <li>
          Reduces the liability on the [=verifier=] for handling highly sensitive
          information that it does not need to.
        </li>
        <li>
          Enhances the privacy of the individual by only asking for information required
          for a specific transaction.
        </li>
      </ul>

      <p class="note">
        While it is possible to practice the principle of minimum disclosure, it might
        be impossible to avoid the strong identification of an individual for
        specific use cases during a single session or over multiple sessions. The
        authors of this document cannot stress how difficult it is to meet this
        principle in real-world scenarios.
      </p>
    </section>

    <section class="informative">
      <h3>Bearer Credentials</h3>

      <p>
        A <dfn data-lt="bearer credentials">bearer credential</dfn> is a
        privacy-enhancing piece of information, such as a concert ticket, which entitles
        the [=holder=] of the bearer credential to a specific resource without
        divulging sensitive information about the [=holder=]. Bearer credentials are
        often used in low-risk use cases where the sharing of the bearer credential is
        not a concern or would not result in large economic or reputational losses.
      </p>

      <p>
        [=Verifiable credentials=] that are [=bearer credentials=] are made
        possible by not specifying the [=subject=] identifier, expressed using the
        `id` [=property=], which is nested in the
        `credentialSubject` [=property=]. For example, the following
        [=verifiable credential=] is a [=bearer credential=]:
      </p>

      <pre class="example nohighlight vc" title="Usage of issuer properties"
        data-vc-vm="https://university.example/issuers/14#keys-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/temporary/28934792387492384",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2017-10-22T12:23:48Z",
  "credentialSubject": {
    <span class="comment">// note that the 'id' property is not specified for bearer credentials</span>
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        While [=bearer credentials=] can be privacy-enhancing, they must be carefully
        crafted so as not accidentally divulge more information than the [=holder=]
        of the [=bearer credential=] expects. For example, repeated use of the same
        [=bearer credential=] across multiple sites enables these sites to
        potentially collude to unduly track or correlate the [=holder=]. Likewise,
        information that might seem non-identifying, such as a birthdate and postal
        code, can be used to statistically identify an individual when used together in
        the same [=bearer credential=] or session.
      </p>

      <p>
        [=Issuers=] of [=bearer credentials=] should ensure that the
        [=bearer credentials=] provide privacy-enhancing benefits that:
      </p>

      <ul>
        <li>
          Are single-use, where possible.
        </li>
        <li>
          Do not contain personally identifying information.
        </li>
        <li>
          Are not unduly correlatable.
        </li>
      </ul>

      <p>
        [=Holders=] should be warned by their software if [=bearer credentials=]
        containing sensitive information are issued or requested, or if there is a
        correlation risk when combining two or more [=bearer credentials=] across one
        or more sessions. While it might be impossible to detect all correlation risks,
        some might certainly be detectable.
      </p>

      <p>
        [=Verifiers=] should not request [=bearer credentials=] that can be used
        to unduly correlate the [=holder=].
      </p>
    </section>

    <section class="informative">
      <h3>Validation</h3>

      <p>
        When processing [=verifiable credentials=], [=verifiers=]
        evaluate any relevant [=claims=] before relying upon them. This
        evaluation might be done in any manner desired, as long as it satisfies
        the requirements of the [=verifier=] doing the validation.
        Many verifiers will perform the checks listed in Appendix <a href="#validation-0"></a> as well as a variety of
        specific business process
        checks such as:
      </p>

      <ul>
        <li>
          The professional licensure status of the [=holder=].
        </li>
        <li>
          A date of license renewal or revocation.
        </li>
        <li>
          The sub-qualifications of an individual.
        </li>
        <li>
          If a relationship exists between the [=holder=] and the [=entity=]
          with whom the [=holder=] is attempting to interact.
        </li>
        <li>
          The geolocation information associated with the [=holder=].
        </li>
      </ul>

      <p>
        The process of performing these checks might result in information leakage that
        leads to a privacy violation of the [=holder=]. For example, a simple
        operation, such as checking an improperly configured revocation list, can
        notify the [=issuer=] that a specific business is likely interacting
        with the [=holder=]. This could
        enable [=issuers=] to collude to correlate individuals without their
        knowledge.
      </p>

      <p>
        [=Issuers=] are urged to not use mechanisms, such as [=credential=]
        revocation lists that are unique per [=credential=], during the
        [=verification=] process that could lead to privacy violations. Organizations
        providing software to [=holders=] should warn when [=credentials=] include
        information that could lead to privacy violations during the verification
        process. [=Verifiers=] should consider rejecting [=credentials=] that
        produce privacy violations or that enable bad privacy practices.
      </p>
    </section>

    <section class="informative">
      <h3>Storage Providers and Data Mining</h3>

      <p>
        When a [=holder=] receives a [=verifiable credential=] from an
        [=issuer=], the [=verifiable credential=] needs to be stored somewhere
        (for example, in a [=credential=] repository). [=Holders=] are warned that
        the information in a [=verifiable credential=] is sensitive in nature and
        highly individualized, making it a high value target for data mining. Services
        that advertise free storage of [=verifiable credentials=] might in fact be
        mining personal data and selling it to organizations wanting to build
        individualized profiles on people and organizations.
      </p>
      <p>
        [=Holders=] need to be aware of the terms of service for their
        [=credential=] repository, specifically the correlation and data mining
        protections in place for those who store their [=verifiable credentials=]
        with the service provider.
      </p>
      <p>
        Some effective mitigations for data mining and profiling include using:
      </p>

      <ul>
        <li>
          Service providers that do not sell your information to third parties.
        </li>
        <li>
          Software that encrypts [=verifiable credentials=] such that a service
          provider cannot view the contents of the [=credential=].
        </li>
        <li>
          Software that stores [=verifiable credentials=] locally on a device that you
          control and that does not upload or analyze your information beyond your
          expectations.
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>Aggregation of Credentials</h3>

      <p>
        Holding two pieces of information about the same [=subject=] almost always
        reveals more about the [=subject=] than just the sum of the two pieces, even
        when the information is delivered through different channels. The aggregation of
        [=verifiable credentials=] is a privacy risk and all participants in
        the ecosystem need to be aware of the risks of data aggregation.
      </p>

      <p>
        For example, if two [=bearer credentials=], one for an email address and then
        one stating the [=holder=] is over the age of 21, are provided across
        multiple sessions, the [=verifier=] of the information now has a unique
        identifier as well as age-related information for that individual. It is now
        easy to create and build a profile for the [=holder=] such that more and more
        information is leaked over time. Aggregation of [=credentials=] can also be
        performed across multiple sites in collusion with each other, leading to privacy
        violations.
      </p>

      <p>
        From a technological perspective, preventing aggregation of information is a
        very difficult privacy problem to address. While new cryptographic techniques,
        such as zero-knowledge proofs, are being proposed as solutions to the problem
        of aggregation and correlation, the existence of long-lived identifiers and
        browser tracking techniques defeats even the most modern cryptographic
        techniques.
      </p>

      <p>
        The solution to the privacy implications of correlation or aggregation tends not
        to be technological in nature, but policy driven instead. Therefore, if a
        [=holder=] does not want information about them to be aggregated, they must
        express this in the [=verifiable presentations=] they transmit.
      </p>
    </section>

    <section class="informative">
      <h3>Usage Patterns</h3>

      <p>
        Despite the best efforts to assure privacy, actually using
        [=verifiable credentials=] can potentially lead to de-anonymization and a
        loss of privacy. This correlation can occur when:
      </p>

      <ul>
        <li>
          The same [=verifiable credential=] is presented to the same [=verifier=]
          more than once. The [=verifier=] could infer that the [=holder=] is the
          same individual.
        </li>
        <li>
          The same [=verifiable credential=] is presented to different
          [=verifiers=], and either those [=verifiers=] collude or a third party
          has access to transaction records from both [=verifiers=]. An observant
          party could infer that the individual presenting the
          [=verifiable credential=] is the same person at both services. That is, the
          accounts are controlled by the same person.
        </li>
        <li>
          A [=subject=] identifier of a [=credential=] refers to the same
          [=subject=] across multiple [=presentations=] or [=verifiers=]. Even
          when different [=credentials=] are presented, if the [=subject=]
          identifier is the same, [=verifiers=] (and those with access to
          [=verifier=] logs) could infer that the [=holder=] of the
          [=credential=] is the same person.
        </li>
        <li>
          The underlying information in a [=credential=] can be used to identify an
          individual across services. In this case, using information from other sources
          (including information provided directly by the [=holder=]), [=verifiers=]
          can use information inside the [=credential=] to correlate the individual
          with an existing profile. For example, if a [=holder=] presents
          [=credentials=] that include postal code, age, and gender, a [=verifier=]
          can potentially correlate the [=subject=] of that [=credential=] with an
          established profile. For more information, see [[DEMOGRAPHICS]].
        </li>
        <li>
          Passing the identifier of a [=credential=] to a centralized revocation
          server. The centralized server can correlate the [=credential=] usage across
          interactions. For example, if a [=credential=] is used for proof of age in
          this manner, the centralized service could know everywhere that
          [=credential=] was presented (all liquor stores, bars, adult stores, lottery
          purchases, and so on).
        </li>
      </ul>

      <p>
        In part, it is possible to mitigate this de-anonymization and loss of privacy
        by:
      </p>

      <ul>
        <li>
          Using a globally-unique identifier as the [=subject=] for any given
          [=credential=] and never re-use that [=credential=].
        </li>
        <li>
          If the [=credential=] supports revocation, using a globally-distributed
          service for revocation.
        </li>
        <li>
          Designing revocation APIs that do not depend on submitting the ID of the
          [=credential=]. For example, use a revocation list instead of a query.
        </li>
        <li>
          Avoiding the association of personally identifiable information with any
          specific long-lived [=subject=] identifier.
        </li>
      </ul>

      <p>
        It is understood that these mitigation techniques are not always practical
        or even compatible with necessary usage. Sometimes correlation is a
        requirement.
      </p>
      <p>
        For example, in some prescription drug monitoring programs, usage monitoring is
        a requirement. Enforcement entities need to be able to confirm that individuals
        are not cheating the system to get multiple prescriptions for controlled
        substances. This statutory or regulatory need to correlate usage overrides
        individual privacy concerns.
      </p>

      <p>
        [=Verifiable credentials=] will also be used to intentionally correlate
        individuals across services, for example, when using a common persona to log in
        to multiple services, so all activity on each of those services is
        intentionally linked to the same individual. This is not a privacy issue as
        long as each of those services uses the correlation in the expected manner.
      </p>

      <p>
        Privacy risks of [=credential=] usage occur when unintended or unexpected
        correlation arises from the presentation of [=credentials=].
      </p>
    </section>

    <section class="informative">
      <h3>Sharing Information with the Wrong Party</h3>

      <p>
        When a [=holder=] chooses to share information with a [=verifier=], it
        might be the case that the [=verifier=] is acting in bad faith and requests
        information that could be used to harm the [=holder=]. For example, a
        [=verifier=] might ask for a bank account number, which could then be used
        with other information to defraud the [=holder=] or the bank.
      </p>

      <p>
        [=Issuers=] should strive to tokenize as much information as possible such
        that if a [=holder=] accidentally transmits [=credentials=] to the wrong
        [=verifier=], the situation is not catastrophic.
      </p>

      <p>
        For example, instead of including a bank account number for the purpose of
        checking an individual's bank balance, provide a token that enables the
        [=verifier=] to check if the balance is above a certain amount. In this
        case, the bank could issue a [=verifiable credential=] containing a balance
        checking token to a [=holder=]. The [=holder=] would then include the
        [=verifiable credential=] in a [=verifiable presentation=] and bind the
        token to a credit checking agency using a digital signature. The
        [=verifier=] could then wrap the [=verifiable presentation=] in their
        digital signature, and hand it back to the issuer to dynamically check the
        account balance.
      </p>

      <p>
        Using this approach, even if a [=holder=] shares the account balance token
        with the wrong party, an attacker cannot discover the bank account number, nor
        the exact value in the account. And given the validity period for the
        counter-signature, does not gain access to the token for more than a few
        minutes.
      </p>
    </section>

    <section class="informative">
      <h3>Data Theft</h3>

      <p>
        The data expressed in [=verifiable credentials=] and
        [=verifiable presentations=] are valuable since they contain authentic
        statements made by trusted third parties, such as [=issuers=], or
        individuals, such as [=holders=] and [=subjects=]. Storing this data
        can create honeypots of sensitive data that attackers are motivated to
        break into in order to acquire and exchange that data for financial gain.
      </p>
      <p>
        [=Issuers=] are advised to retain the minimum amount of data
        necessary to issue [=verifiable credentials=] to [=holders=] and
        manage the status and revocation of those credentials.
      </p>
      <p>
        [=Holders=] are advised to use implementations that appropriately
        encrypt their data both in transit and at rest, and protect sensitive
        material (such as cryptographic secrets) in ways that cannot be easily
        extracted from hardware devices. Furthermore, it is suggested that
        [=holders=] store and manipulate their data only on devices that they
        control, away from centralized systems, to reduce the likelihood of
        attack on their data, or large-scale theft if an attack is successful.
      </p>
      <p>
        [=Verifiers=] are advised to only ask for data necessary for a particular
        transaction and to not retain any data beyond the needs of any particular
        transaction.
      </p>
      <p>
        Regulators are advised to rethink audit requirements such that more
        privacy-preserving mechanisms can be used to achieve similar levels of
        enforcement and audit capabilities. For example, audit-focused regulations
        that insist on collection and long-term retention of personally identifiable
        information can cause harm to individuals and organizations if that same
        information is compromised and accessed by an attacker. The technologies
        described by this specification enable [=holders=] to more-readily prove
        attributes about themselves and others, reducing the need for long-term data
        retention by [=verifiers=]. Alternatives include keeping logs that the
        information was collected and checked, as well as random tests to ensure
        that compliance regimes are operating as expected.
      </p>
    </section>

    <section class="informative">
      <h3>Frequency of Claim Issuance</h3>

      <p>
        As detailed in Section <a href="#usage-patterns"></a>, usage patterns can be
        correlated into certain types of behavior. Part of this correlation is
        mitigated when a [=holder=] uses a [=verifiable credential=] without the
        knowledge of the [=issuer=]. [=Issuers=] can defeat this protection
        however, by making their [=verifiable credentials=] short lived and renewal
        automatic.
      </p>

      <p>
        For example, an `ageOver` [=verifiable credential=] is useful for
        gaining access to a bar. If an [=issuer=] issues such a
        [=verifiable credential=] with a very short validity period and an automatic
        renewal mechanism, then the [=issuer=] could possibly correlate the behavior
        of the [=holder=] in a way that negatively impacts the [=holder=].
      </p>

      <p>
        Organizations providing software to [=holders=] should warn them if they
        repeatedly use [=credentials=] with short lifespans, which could result in
        behavior correlation. [=Issuers=] should avoid issuing [=credentials=] in
        a way that enables them to correlate usage patterns.
      </p>
    </section>

    <section class="informative">
      <h3>Prefer Single-Use Credentials</h3>

      <p>
        An ideal privacy-respecting system would require only the information necessary
        for interaction with the [=verifier=] to be disclosed by the [=holder=].
        The [=verifier=] would then record that the disclosure requirement was met
        and forget any sensitive information that was disclosed. In many cases,
        competing priorities, such as regulatory burden, prevent this ideal system from
        being employed. In other cases, long-lived identifiers prevent single use. The
        design of any [=verifiable credentials=] ecosystem, however, should strive
        to be as privacy-respecting as possible by preferring single-use
        [=verifiable credentials=] whenever possible.
      </p>

      <p>
        Using single-use [=verifiable credentials=] provides several benefits. The
        first benefit is to [=verifiers=] who can be sure that the data in a
        [=verifiable credential=] is fresh. The second benefit is to [=holders=],
        who know that if there are no long-lived identifiers in the
        [=verifiable credential=], the [=verifiable credential=] itself cannot be
        used to track or correlate them online. Finally, there is nothing for attackers
        to steal, making the entire ecosystem safer to operate within.
      </p>
    </section>

    <section class="informative">
      <h3>Private Browsing</h3>

      <p>
        In an ideal private browsing scenario, no PII will be revealed. Because many
        [=credentials=] include PII, organizations providing software to
        [=holders=] should warn them about the possibility of revealing this
        information if they wish to use [=credentials=] and [=presentations=]
        while in private browsing mode. As each browser vendor handles private browsing
        differently, and some browsers might not have this feature at all, it is
        important for implementers to be aware of these differences and implement
        solutions accordingly.
      </p>
    </section>

    <section class="informative">
      <h3>Issuer Cooperation Impacts on Privacy</h3>

      <p>
        It cannot be overstated that [=verifiable credentials=] rely on a high degree
        of trust in [=issuers=]. The degree to which a [=holder=] might take
        advantage of possible privacy protections often depends strongly on the support
        an [=issuer=] provides for such features. In many cases, privacy protections
        which make use of zero-knowledge proofs, data minimization techniques, bearer
        credentials, abstract claims, and protections against signature-based
        correlation, require the [=issuer=] to actively support such capabilities and
        incorporate them into the [=verifiable credentials=] they issue.
      </p>
      <p>
        It should also be noted that, in addition to a reliance on [=issuer=]
        participation to provide [=verifiable credential=] capabilities that help
        preserve [=holder=] and [=subject=] privacy, [=holders=] rely on
        [=issuers=] to not deliberately subvert privacy protections. For example, an
        [=issuer=] might sign [=verifiable credentials=] using a signature scheme
        that protects against signature-based correlation. This would protect the
        [=holder=] from being correlated by the signature value as it is shared among
        [=verifiers=]. However, if the [=issuer=] creates a unique key for each
        issued [=credential=], it might be possible for the [=issuer=] to track
        [=presentations=] of the [=credential=], regardless of a [=verifier=]'s
        inability to do so.
      </p>
      <p>
        In addition to previously described privacy protections an [=issuer=] might
        use, [=issuers=] need to also be aware of data they leak associated with
        identifiers and claim types they use when issuing [=credentials=]. One
        example of this would be an [=issuer=] issuing drivers licenses which reveal
        both the location(s) in which they have jurisdiction and the location of the
        [=subject's=] residence. [=Verifiers=] might take advantage of this by
        requesting a [=credential=] to check that the [=subject=] is licensed to
        drive, when in fact they are interested in metadata <em>about</em> the
        credential, such as which [=issuer=] issued the credential, and tangential
        information that might have been leaked by the [=issuer=], such as the
        subject's home address. To mitigate such leakage, [=issuers=] might choose to
        use common identifiers to mask specific location information or other sensitive
        metadata; for example, a shared issuer identifier at a state or nation level,
        instead of at the level of a county, city, town, or other smaller municipality.
        Further, [=holder=] attestation mechanisms can be used by [=verifiers=] to
        preserve privacy, by providing proofs that an [=issuer=] exists in a set of
        trusted entities, without needing to disclose the exact [=issuer=].
      </p>
    </section>
  </section>

  <section class="informative">
    <h2>Security Considerations</h2>

    <p>
      There are a number of security considerations that [=issuers=],
      [=holders=], and [=verifiers=] should be aware of when processing data
      described by this specification. Ignoring or not understanding the implications
      of this section can result in security vulnerabilities.
    </p>

    <p>
      While this section attempts to highlight a broad set of security considerations,
      it is not a complete list. Implementers are urged to seek the advice of security
      and cryptography professionals when implementing mission critical systems using
      the technology outlined in this specification.
    </p>

    <section class="informative">
      <h3>Cryptography Suites and Libraries</h3>

      <p>
        Some aspects of the data model described in this specification can be
        protected through the use of cryptography. It is important for implementers to
        understand the cryptography suites and libraries used to create and process
        [=credentials=] and [=presentations=]. Implementing and auditing
        cryptography systems generally requires substantial experience. Effective
        <a href="https://en.wikipedia.org/wiki/Red_team">red teaming</a> can also
        help remove bias from security reviews.
      </p>

      <p>
        Cryptography suites and libraries have a shelf life and eventually fall to
        new attacks and technology advances. Production quality systems need to take
        this into account and ensure mechanisms exist to easily and proactively upgrade
        expired or broken cryptography suites and libraries, and to invalidate
        and replace existing [=credentials=]. Regular monitoring is important to
        ensure the long term viability of systems processing [=credentials=].
      </p>
    </section>

    <section class="informative">
      <h3>Key Management</h3>
      <p>
        The security of most digital signature algorithms, which are used to secure
        [=verifiable credentials=] and [=verifiable presentations=], is dependent
        on the quality and protection of their <em>private signing keys</em>. Guidance
        in the management of cryptographic keys is a large subject and the reader is
        referred to [[NIST-SP-800-57-Part-1]] for more extensive recommendations and
        discussion. As strongly recommended in both [[FIPS-186-5]] and
        [[NIST-SP-800-57-Part-1]], a private signing key is not to be used for multiple
        purposes, e.g., a private signing key is not to be used for encryption as well
        as signing.
      </p>
      <p>
        [[NIST-SP-800-57-Part-1]] strongly advises that private signing keys and
        <em>public verification keys</em> have limited <em>cryptoperiods</em>, where
        a <em>cryptoperiod</em> is &quot;the time span during which a specific key is
        authorized for use by legitimate entities or the keys for a given system will
        remain in effect.&quot; [[NIST-SP-800-57-Part-1]] gives extensive
        guidance on cryptoperiods for different key types under different situations,
        and generally recommends a 1-3 year cryptoperiod for a private signing key.
      </p>
      <p>
        To deal with potential private key compromises, [[NIST-SP-800-57-Part-1]]
        provides recommendations for protective measures, harm reduction, and
        revocation. Although this section focuses primarily on the security of the
        private signing key, [[NIST-SP-800-57-Part-1]] also highly recommends
        confirmation of the validity of all [=verification material=] before using it.
      </p>
    </section>

    <section class="informative">
      <h3>Content Integrity Protection</h3>

      <p>
        [=Verifiable credentials=] often contain URLs to data that resides outside of
        the [=verifiable credential=] itself. Linked content that exists outside a
        [=verifiable credential=], such as images, JSON-LD Contexts, JSON Schemas,
        and other machine-readable data, are often not protected against tampering
        because the data resides outside of the protection of the
        <a href="#securing-mechanisms">securing mechanism</a> on the
        [=verifiable credential=]. For example, the content retrievable by
        dereferencing the following highlighted links is not integrity protected, but
        probably ought to be:
      </p>

      <pre class="example nohighlight" title="Non-content-integrity protected links">
{
  "@context": [
    <span class="highlight">"https://www.w3.org/ns/credentials/v2"</span>,
    <span class="highlight">"https://www.w3.org/ns/credentials/examples/v2"</span>
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://university.example/images/58473"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

      <p>
        While this specification does not recommend any specific content integrity
        protection, document authors who want to ensure links to content are integrity
        protected are advised to use URL schemes that enforce content integrity.
      </p>

      <pre class="example nohighlight" title="Content-integrity protection for links to external data">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2<span class="highlight">?hl=z3aq31uzgnZBuWNzUB</span>",
    "https://www.w3.org/ns/credentials/examples/v2<span class="highlight">?hl=z8guWNzUBnZBu3aq31</span>"
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://example.com/image"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

      <p class="note">
        It is debatable whether the JSON-LD Contexts above need protection because
        production implementations are expected to ship with static copies of important
        JSON-LD Contexts.
      </p>

      <p>
        While the example above is one way to achieve content integrity protection,
        there are other solutions that might be better suited for certain applications.
        Implementers are urged to understand how links to external machine-readable
        content that are not content-integrity protected could result in successful
        attacks against their applications.
      </p>

    </section>

    <section class="informative">
      <h3>Unsigned Claims</h3>

      <p>
        This specification allows [=credentials=] to be produced that are not secured by
        signatures or proofs of any kind. These types of [=credentials=] are often
        useful for intermediate storage, or self-asserted information, which is
        analogous to filling out a form on a web page. Implementers should be aware that
        these types of [=credentials=] are not [=verifiable=] because the
        authorship either is not known or cannot be trusted.
      </p>
    </section>

    <section class="informative">
      <h3>Man-in-the-Middle (MITM), Replay, and Cloning Attacks</h3>

      <p>
        The data model does not inherently prevent
        <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-in-the-Middle (MITM)</a>,
        <a href="https://en.wikipedia.org/wiki/Replay_attack">replay</a>, and
        <a href="https://en.wikipedia.org/wiki/Spoofing_attack">spoofing</a> attacks.
        Both online and offline use cases might be susceptible to these types of
        attacks, where an adversary intercepts, modifies, re-uses, and/or replicates the
        [=verifiable credential=] data during transmission or storage.
      </p>
      <h4>Man-in-the-Middle (MITM) Attack</h4>

      <p>
        A [=verifier=] might need to ensure it is the intended recipient of a
        [=verifiable presentation=] and not the target of a
        <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">
          man-in-the-middle attack</a>. Some <a href="#securing-mechanisms">securing
          mechanisms</a>, like [[VC-JOSE-COSE]] or [[VC-DATA-INTEGRITY]], provide an
        option to specify the intended audience or domain of a [=presentation=],
        which can help reduce this risk.
      </p>
      <p>
        Alternate approaches such as token binding [[RFC8471]], which ties the request
        for a [=verifiable presentation=] to the response, can secure the protocol.
        Any unsecured protocol is susceptible to man-in-the-middle attacks.
      </p>
      <h4>Replay Attack</h4>

      <p>
        A [=verifier=] might wish to ensure that a [=verifiable presentation=] is
        not used more than a certain number of times. For example, a [=verifiable
        credential=] representing an event ticket, might allow entry to multiple
        individuals if presented multiple times, undermining the purpose of the ticket
        from the perspective of its issuer. To prevent against such attacks,
        [=holders=] can make use of techniques such as including a
        <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a> during
        presentation, or adding an expiry timestamp to reduce the window of attack.
      </p>
      <h4>Spoofing Attack</h4>

      <p>
        A [=verifier=] has a vested interest in knowing that a [=holder=] is
        authorized to present the claims inside of a [=verifiable presentation=].
        While the data model outlines the structure and data elements necessary for a
        [=verifiable credential=], it does not include a mechanism to ascertain the
        authorization of presented [=credentials=]. To address this concern,
        implementers might need to explore supplementary methods, such as binding
        [=verifiable credentials=] to strong authentication mechanisms or using
        additional attributes in [=verifiable presentations=]
        to enable proof of control.
      </p>
    </section>
    <section class="informative">
      <h3>Bundling Dependent Claims</h3>

      <p>
        It is considered best practice for [=issuers=] to atomize information in a
        [=credential=], or use a signature scheme that allows for selective
        disclosure. In the case of atomization, if it is not done securely by the
        [=issuer=], the [=holder=] might bundle together different
        [=credentials=] in a way that was not intended by the [=issuer=].
      </p>

      <p>
        For example, a university might issue two [=verifiable credentials=] to a
        person, each containing two [=properties=], which must be taken together
        to designate the "role" of that person in a given "department", such as "Staff
        Member" in the "Department of Computing", or "Post Graduate Student" in the
        "Department of Economics". If these [=verifiable credentials=] are atomized
        to put only one of these [=properties=] into each [=credential=] , then
        the university would issue four [=credentials=] to the person, each
        containing one of the following designations: "Staff Member", "Post Graduate
        Student", "Department of Computing", and "Department of Economics". The
        [=holder=] might then transfer the "Staff Member" and "Department of
        Economics" [=verifiable credentials=] to a [=verifier=], which together
        would comprise a false [=claim=].
      </p>
    </section>

    <section class="informative">
      <h3>Highly Dynamic Information</h3>

      <p>
        When [=verifiable credentials=] are issued for highly dynamic information,
        implementers should ensure the validity periods are set appropriately. Validity
        periods longer than the timeframe where the [=verifiable credential=] is
        meant for use might create exploitable security vulnerabilities. Validity
        periods shorter than the timeframe where the information expressed by the
        [=verifiable credential=] is expected to be used creates a burden on
        [=holders=] and [=verifiers=]. It is therefore important to set validity
        periods for [=verifiable credentials=] that are appropriate to the use case
        and the expected lifetime for the information contained in the
        [=verifiable credential=].
      </p>
    </section>

    <section class="informative">
      <h3>Device Theft and Impersonation</h3>

      <p>
        When [=verifiable credentials=] are stored on a device and that
        device is lost or stolen, it might be possible for an attacker to gain access
        to systems using the victim's [=verifiable credentials=]. Ways to mitigate
        this type of attack include:
      </p>

      <ul>
        <li>
          Enabling password, pin, pattern, or biometric screen unlock protection on the
          device.
        </li>
        <li>
          Enabling password, biometric, or multi-factor authentication for the
          [=credential=] [=repository=].
        </li>
        <li>
          Enabling password, biometric, or multi-factor authentication when accessing
          cryptographic keys.
        </li>
        <li>
          Using a separate hardware-based signature device.
        </li>
        <li>
          All or any combination of the above.
        </li>
      </ul>

      <p>
        Furthermore, instances of impersonation can manifest in various forms, including
        situations where an [=entity=] attempts to disavow their actions. Elevating
        the level of trust and security within the realm of [=verifiable
        credentials=] entails more than just averting impersonation; it involves the
        implementation of non-repudiation mechanisms. These mechanisms solidify an
        [=entity=]'s responsibility for their actions or transactions, thereby
        reinforcing accountability and deterring malicious behaviors. The attainment of
        non-repudiation is a multifaceted endeavor, encompassing an array of techniques
        ranging from <a href="#securing-mechanisms">securing mechanisms</a>, proofs of
        possession, and authentication schemes in a variety of protocols designed to
        foster trust and reliability.
      </p>
    </section>
    <section class="informative">
      <h3>Acceptable Use</h3>

      <p>
        Ensuring that there is alignment between an [=entity=]'s actions, such as
        [=presentation=], and the intended purpose of those actions, is of
        importance. It involves having the authorization to make use of [=verifiable
        credentials=] as well as using [=credentials=] in a manner that adheres to
        their designated scope(s) and objective(s). Two critical aspects that arise
        within this context are <i>Unauthorized Use</i> and <i>Inappropriate Use</i>.
      </p>
      <h4>Unauthorized Use</h4>
      <p>
        Any attempt by entities to make use of [=verifiable credentials=] and
        [=verifiable presentations=] outside of their intended use can be seen as
        unauthorized. One class of unauthorized use is a <i>confidentiality
          violation</i>. Consider an example where a [=holder=] shares a [=verifiable
        presentation=] with a [=verifier=] to establish their age and residency
        status. If the [=verifier=] then proceeds to exploit the [=holder's=] data
        without proper consent, such as by selling the data to a data broker, that would
        constitute an unauthorized use of the data, violating an expectation of privacy
        that the [=holder=] might have in the transaction.
      </p>
      <p>
        Similarly, an [=issuer=] could make use of a
        <a href="#terms-of-use">termsOfUse</a> property to stipulate how and when a
        credential might be used. A [=holder=] using credentials outside of the
        scopes defined in the `termsOfUse` would be considered unauthorized
        use.
      </p>
      <p class="note">
        Further study is required to determine how a [=holder=] can assert and
        enforce authorized use of their data after [=presentation=].
      </p>
      <h4>Inappropriate Use</h4>
      <p>
        While valid cryptographic signatures and successful status checks signify the
        reliability of [=credentials=], they do not signify that all
        [=credentials=] are interchangeable for all contexts. It is crucial that
        [=verifiers=] also <a href="#validation-0">validate</a> any claims which
        might be relevant, considering the source and nature of the claim as well as
        privilege or service for which the credential is presented.
      </p>
      <p>
        For instance, in scenarios where a certified medical diagnosis is required, a
        self-asserted [=credential=] carrying the necessary data might not suffice
        because it lacks validity from an authoritative medical source. To ensure the
        propriety of [=credential=] use, stakeholders are urged to assess the
        <a href="#dfn-credential">credential's</a> relevance and authority within the
        specific context of their intended application.
      </p>
    </section>
  </section>

  <section class="informative">
    <h2>Accessibility Considerations</h2>

    <p>
      There are a number of accessibility considerations implementers should be
      aware of when processing data described in this specification. As with
      implementation of any web standard or protocol, ignoring accessibility issues
      makes this information unusable by a large subset of the population. It is
      important to follow accessibility guidelines and standards, such as [[WCAG21]],
      to ensure that all people, regardless of ability, can make use of this data.
      This is especially important when establishing systems utilizing cryptography,
      which have historically created problems for assistive technologies.
    </p>

    <p>
      This section details the general accessibility considerations to take into
      account when utilizing this data model.
    </p>

    <section class="informative">
      <h3>Data First Approaches</h3>

      <p>
        Many physical [=credentials=] in use today, such as government identification
        cards, have poor accessibility characteristics, including, but not limited to,
        small print, reliance on small and high-resolution images, and no affordances
        for people with vision impairments.
      </p>

      <p>
        When utilizing this data model to create [=verifiable credentials=], it is
        suggested that data model designers use a <em>data first</em> approach. For
        example, given the choice of using data or a graphical image to depict a
        [=credential=], designers should express every element of the image, such as
        the name of an institution or the professional [=credential=], in a
        machine-readable way instead of relying on a viewer's interpretation of the
        image to convey this information. Using a data first approach is preferred
        because it provides the foundational elements of building different interfaces
        for people with varying abilities.
      </p>
    </section>
  </section>

  <section class="informative">
    <h2>Internationalization Considerations</h2>

    <p>
      Implementers are advised to be aware of a number of internationalization
      considerations when publishing data described in this specification.
      As with any web standards or protocols implementation, ignoring
      internationalization makes it difficult for data to be produced and consumed
      across a disparate set of languages and societies, which limits the
      applicability of the specification and significantly diminishes its value as a
      standard.
    </p>

    <p>
      Implementers are strongly advised to read the
      <em>Strings on the Web: Language and Direction Metadata</em> document
      [[STRING-META]], published by the W3C Internationalization Activity, which
      elaborates on the need to provide reliable metadata about text to support
      internationalization. For the latest information on internationalization
      considerations, implementers are also urged to read the Verifiable Credentials
      Implementation Guidelines [[VC-IMP-GUIDE]] document.
    </p>

    <p>
      This section outlines general internationalization considerations to take into
      account when utilizing this data model and is intended to highlight specific
      parts of the <em>Strings on the Web: Language and Direction Metadata</em>
      document [[STRING-META]] that implementers might be interested in reading.
    </p>

    <section>
      <h3>Language and Base Direction</h3>

      <p>
        Data publishers are strongly encouraged to read the section on
        Cross-Syntax Expression in the <em>Strings on the Web: Language and Direction
          Metadata</em> document [[STRING-META]] to ensure that the expression of
        language and <dfn data-cite="i18n-glossary">base direction</dfn> information is
        possible across multiple expression syntaxes, such as [[JSON-LD11]], [[JSON]],
        and CBOR [[?RFC7049]].
      </p>

      <p>
        The general design pattern is to use the following markup template when
        expressing a text string that is tagged with a language and, optionally, a
        specific base direction.
      </p>

      <pre class="example nohighlight" title="Design pattern for natural language strings">
"myProperty": {
  "@value": "<span class="highlight">The string value</span>",
  "@language": "LANGUAGE"
  "@direction": "DIRECTION"
}
        </pre>

      <p>
        When the language value object is used in place of a string value, the object
        MUST contain a `@value` property whose value is a string, and SHOULD contain a
        `@language` property whose value is a string containing a well-formed
        `Language-Tag` as defined by [[BCP47]], and MAY contain a `@direction` property
        whose value is a [=base direction=] string defined by the `@direction`
        attribute in [[JSON-LD11]]. The language value object MUST NOT include any other
        keys beyond `@value`, `@language`, and `@direction`.
      </p>

      <p>
        Using the design pattern above, the following example expresses the title of a
        book in the English language without specifying a text direction.
      </p>

      <pre class="example nohighlight" title="Expressing natural language text as English">
"title": {
  "@value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
  "@language": "en"
}
        </pre>

      <p>
        The next example uses a similar title expressed in the Arabic language with a
        base direction of right-to-left.
      </p>

      <pre class="example nohighlight" title="Arabic text with a base direction of right-to-left">
"title": {
  "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
  "@language": "ar",
  "@direction": "rtl"
}
        </pre>

      <p class="note">
        The text above would most likely be rendered incorrectly as left-to-right
        without the explicit expression of language and direction because many systems
        use the first character of a text string to determine its [=base direction=].
      </p>

      <p>
        Multiple language value objects MAY be provided as an array value for the
        property:
      </p>

      <pre class="example nohighlight" title="Multiple language texts provided for title">
"title": [
  {
    "@value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
    "@language": "en"
  },
  {
    "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
    "@language": "ar",
    "@direction": "rtl"
  }
]
        </pre>
    </section>

    <section class="substantive">
      <h3>Providing Default Language and Direction</h3>

      <p>
        The language and base direction of each natural language string property value
        SHOULD be provided, either via the language value structure for each property
        value, or via a default language and base direction for all values in the entire
        credential. Using the per-value language value structure is preferred, because
        using document defaults can result in a requirement that downstream processors
        perform JSON-LD expansion-based transformation which is otherwise optional. See
        the <a data-cite="JSON-LD11#string-internationalization">
          String Internationalization</a> section of the [[JSON-LD11]] specification for
        more information. Natural language string values that do not have a language
        associated with them SHOULD be treated as if the language value is `undefined`
        (language tag "`und`"). Natural language string values that do not have a base
        direction associated with them SHOULD be treated as if the direction value is
        "`auto`".
      </p>
    </section>

    <section class="informative">
      <h3>Complex Language Markup</h3>

      <p>
        When a single natural language string contains multiple languages or
        annotations, the contents of the string might require additional structure or
        markup in order to be presented correctly. It is possible to use markup
        languages, such as HTML, to label spans of text in different languages or to
        supply string-internal markup needed for proper display of [=bidirectional
        text=]. It is also possible to use the `rdf:HTML` datatype to
        encode such values accurately in JSON-LD.
      </p>

      <p>
        Despite the ability to encode information as HTML, implementers are strongly
        discouraged from doing this because it:
      </p>

      <ul>
        <li>
          Requires some version of an HTML processor, which increases the burden of
          processing language and base direction information.
        </li>
        <li>
          Increases the security attack surface when utilizing this data model because
          blindly processing HTML could result in executing a `script` tag that
          an attacker injected at some point during the data production process.
        </li>
      </ul>

      <p>
        If implementers feel they must use HTML, or other markup languages capable of
        containing executable scripts, to address a specific use case, they are advised
        to analyze how an attacker would use the markup to mount injection attacks
        against a consumer of the markup and then deploy mitigations against the
        identified attacks.
      </p>
    </section>

  </section>

  <section class="appendix informative">
    <h2>Validation</h2>

    <p>
      While this specification does not provide conformance criteria for the process
      of the [=validation=] of [=verifiable credentials=] or
      [=verifiable presentations=], readers might be curious about how the
      information in this data model is expected to be utilized by [=verifiers=]
      during the process of [=validation=]. This section captures a selection of
      conversations held by the Working Group related to the expected usage of the
      data fields in this specification by [=verifiers=].
    </p>

    <section class="informative">
      <h3>Credential Type</h3>

      <p>
        When a [=verifier=] requests one or more [=verifiable credentials=]
        from a [=holder=], they can specify the type of credential(s) that they would
        like to receive. The type of a credential is expressed via the
        <a href="#types">type</a> property. A [=verifiable credential=] of a specific
        type is expected to contain specific [=properties=] that can be used to
        determine whether or not the [=presentation=] meets a set of processing rules
        that the [=verifier=] is executing. By requesting
        [=verifiable credentials=] of a particular `type`, the
        [=verifier=] is able to gather specific information from the [=holder=],
        which originated with the [=issuer=] of each [=verifiable credential=],
        that will enable it to determine the next stage of an interaction with a
        [=holder=].
      </p>
    </section>

    <section class="informative">
      <h3>Credential Subject</h3>

      <p>
        In the [=verifiable credentials=] presented by a [=holder=], the value
        associated with the `id` [=property=] for each
        `credentialSubject` is expected to identify a [=subject=] to the
        [=verifier=]. If the [=holder=] is also the [=subject=], then
        the [=verifier=] could authenticate the [=holder=] if they have
        [=verification=] metadata related to the [=holder=]. The [=verifier=]
        could then authenticate the [=holder=] using a signature generated by the [=holder=]
        contained in the [=verifiable presentation=]. The `id`
        [=property=] is optional. [=Verifiers=] could use other [=properties=]
        in a [=verifiable credential=] to uniquely identify a [=subject=].
      </p>

      <p class="note">
        For information on how authentication and WebAuthn might work with
        [=verifiable credentials=], see the Verifiable Credentials Implementation
        Guidelines [[VC-IMP-GUIDE]] document.
      </p>

    </section>

    <section class="informative">
      <h3>Issuer</h3>

      <p>
        The value associated with the `issuer` [=property=] is expected
        to identify an [=issuer=] that is known to and trusted by the
        [=verifier=].
      </p>

      <p>
        Metadata related to the `issuer` [=property=] is available to the
        [=verifier=] through the <a href="#verification">verification
          algorithm</a> as defined in Section <a href="#verification"></a>.
        This metadata includes identification of the verified controller of the
        verification method used by the securing mechanism to secure each [=verifiable
        credential=] or [=verifiable presentation=], of which the controller is
        typically the respective `issuer` or `holder`.
      </p>

      <p>
        Some ecosystems might have more complex relationships between [=issuers=]
        and controllers of verification methods and might use lists of verified
        issuers in addition to, or instead of, the mapping described above.
      </p>
    </section>

    <section class="informative">
      <h4>Holder</h4>
      <p>
        The value associated with the `holder` [=property=] is expected
        to be usable to identify the [=holder=] to the [=verifier=].
      </p>
      <p>
        Often relevant metadata about the [=holder=], as identified by the value of
        the `holder` [=property=], is available to, or retrievable by, the
        [=verifier=]. For example, a [=holder=] can publish information containing
        the [=verification material=] used to secure [=verifiable presentations=]. This
        metadata is expected to be used when checking proofs on [=verifiable presentations=].
        Some cryptographic identifiers contain all necessary metadata in the identifier itself.
        In those cases, no additional metadata is required. Other identifiers use verifiable data
        registries where such metadata is automatically published for use by
        [=verifiers=], without any additional action by the [=holder=].
      </p>
      <p>
        See the <a data-cite="VC-IMP-GUIDE/#subject-holder-relationships"></a> and
        <a data-cite="VC-USE-CASES#user-tasks"></a> for additional examples related to
        [=subject=] and [=holder=].
      </p>

      <p class="note">
        Validation is the process by which verifiers apply business rules to
        evaluate the propriety of a particular use of a [=verifiable credential=].
      </p>
      <ul>
        <li>
        </li>
      </ul>
      <p>
        A [=verifier=] might need to validate a given [=verifiable presentation=]
        against complex business rules; for example, the verifier might need confidence
        that the [=holder=] is the same entity as a [=subject=] of a [=verifiable
        credential=]. In such a situation, the following factors can provide a
        [=verifier=] with reasonable confidence that the claims expressed regarding
        that identifier, in included [=verifiable credentials=], are, in fact, about
        the current presenter:
      </p>
      <ul>
        <li>
          The [=verifiable presentation=] is secured, using a mechanism the
          [=verifier=] trusts to protect the integrity of the content.
        </li>
        <li>
          The [=verifiable presentation=] includes one or more [=verifiable
          credentials=] that are secured, using a mechanism the [=verifier=] trusts
          to protect the integrity of the content.
        </li>
        <li>
          The identifier in the `holder` property of the [=verifiable presentation=]
          and at least one identifier property of at least one object in the
          `credentialSubject` array are the same.
        </li>
        <li>
          That common identifier can be used to discover or derive the verification
          material used to verify the integrity of that [=verifiable presentation=].
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>Issuance Date</h3>

      <p>
        The `validFrom` is expected to be within an expected range for the
        [=verifier=]. For example, a [=verifier=] can check that the start of
        the validity period for a [=verifiable credential=] is not in the future.
      </p>
    </section>

    <section class="informative">
      <h3>Proofs (Signatures)</h3>

      <p>
        The cryptographic mechanism used to prove that the information in a
        [=verifiable credential=] or [=verifiable presentation=] was not tampered
        with is called a <em>proof</em>. There are many types of cryptographic proofs
        including, but not limited to, digital signatures and zero-knowledge proofs. In
        general, when verifying proofs, implementations are expected to ensure:
      </p>

      <ul>
        <li>
          The proof is available in the form of a known proof suite.
        </li>
        <li>
          All required proof suite [=properties=] are present.
        </li>
        <li>
          The proof suite [=verification=] algorithm, when applied to the data, results
          in an acceptable proof.
        </li>
      </ul>

      <p>
        Some proofs are digital signatures. In general, when verifying digital
        signatures, implementations are expected to ensure:
      </p>

      <ul>
        <li>
          Acceptably recent metadata regarding the [=verification material=] associated
          with the signature is available. For example, the metadata might include
          [=properties=] related to validity periods, key owner, or key purpose.
        </li>
        <li>
          The key is not suspended, revoked, or expired.
        </li>
        <li>
          The cryptographic signature is expected to verify.
        </li>
        <li>
          Any additional requirements defined by the securing mechanism are satisfied.
        </li>
      </ul>

      <p class="note">
        The digital signature provides a number of protections, other than tamper
        resistance, which are not immediately obvious. For example, a Linked Data
        Signature `created` [=property=] establishes a date and time
        before which the [=credential=] should not be considered [=verified=],
        distinct from the validity period of the credential. This property describes the
        validity of the proof, not of the credential.
        The JWT `iat` claim likewise provides the time that the signature was made.
        <br /><br />
        The `verificationMethod` [=property=] specifies, for example, the
        public key that can be used to verify the digital signature. Dereferencing a
        public key URL reveals information about the controller of the key, which can
        be checked against the issuer of the [=credential=]. The
        `proofPurpose` [=property=] clearly expresses the purpose for
        the proof and ensures this information is protected by the signature. A proof is
        typically attached to a [=verifiable presentation=] for authentication
        purposes and to a [=verifiable credential=] as a method of assertion.
      </p>
    </section>

    <section class="informative">
      <h3>Validity Periods</h3>

      <p>
        The [=verifier=] expects that the `validFrom` and
        `validUntil` properties will be within a certain range. For example,
        a [=verifier=] can check that the end of the validity period of a
        [=verifiable credential=] is not in the past. Because some credentials can be
        useful for secondary purposes even if their original validity period has
        expired, validity period, as expressed using the `validFrom` and
        `validUntil` properties, is always considered a component of
        validation, which is performed <em>after</em> verification.
      </p>
    </section>

    <section class="informative">
      <h3>Status</h3>

      <p>
        If the `credentialStatus` property is available, the status of a
        [=verifiable credential=] is expected to be evaluated by the [=verifier=]
        according to the `credentialStatus` [=type=] definition for the
        [=verifiable credential=] and the [=verifier's=] own status evaluation
        criteria. For example, a [=verifier=] can ensure the status of the
        [=verifiable credential=] is not "withdrawn for cause by the [=issuer=]".
      </p>
    </section>

    <section class="informative">
      <h3>Schema</h3>

      <p>
        If the `credentialSchema` property is available, the schema of a
        [=verifiable credential=] is expected to be evaluated by the [=verifier=]
        according to the `credentialSchema` [=type=] definition for the
        [=verifiable credential=] and the [=verifier's=] own schema evaluation
        criteria. For example, if the `credentialSchema`'s `type`
        value is [[?VC-JSON-SCHEMA]], then a [=verifier=] can ensure a credential's
        data is valid against the given JSON Schema.
      </p>
    </section>

    <section class="informative">
      <h3>Fitness for Purpose</h3>

      <p>
        Fitness for purpose is about whether the custom [=properties=] in the
        [=verifiable credential=] are appropriate for the [=verifier's=] purpose.
        For example, if a [=verifier=] needs to determine whether a [=subject=] is
        older than 21 years of age, they might rely on a specific `birthdate`
        [=property=], or on more abstract [=properties=], such as
        `ageOver`.
      </p>

      <p>
        The [=issuer=] is trusted by the [=verifier=] to make the [=claims=] at
        hand. For example, a franchised fast food restaurant location trusts the
        discount coupon [=claims=] made by the corporate headquarters of the
        franchise. Policy information expressed by the [=issuer=] in the
        [=verifiable credential=] should be respected by [=holders=] and
        [=verifiers=] unless they accept the liability of ignoring the policy.
      </p>
    </section>
  </section>

  <section class="appendix">
    <h2>Contexts, Vocabularies, Types, and Credential Schemas</h2>

    <section class="normative">
      <h3>Base Context</h3>

      <p class="issue" title="(AT RISK) Hash values might change during Candidate Recommendation">
        This section lists cryptographic hash values that might change during the
        Candidate Recommendation phase based on implementer feedback that requires
        the referenced files to be modified.
        <br><br>
        The Working Group is expecting all of the terms and URLs supplied in the
        JSON-LD Context to be either stabilized, or removed, before the publication of
        this specification as a Proposed Recommendation. While that means that this
        specification could be delayed if dependencies such as [[?VC-DATA-INTEGRITY]],
        [[?VC-JOSE-COSE]], SD-JWT, [[?VC-JSON-SCHEMA]], or status list
        do not enter the Proposed Recommendation phase around the same time frame, the
        Working Group is prepared to remove the dependencies if an undue burden is
        placed on transitioning to the Recommendation phase. This is a calculated
        risk that the Working Group is taking and has a mitigation strategy in place
        to ensure the timely transition of this specification to a Recommendation.
      </p>
      <p>
        Implementations MUST treat the base context value, located at
        `https://www.w3.org/ns/credentials/v2`, as already retrieved;
        the following value is the SHA-384 digest of the resource
        computed and encoded according to the [[SRI]] definition of `digest`:
        <strong>`vxRgTREj3/ZmDabpiTX+Au4UXY8GDhyCSFNw+UQtdtISDyO/znDUY+FTg8rNsGXJ`</strong>.
        It is strongly advised that all JSON-LD Context URLs used by an
        application utilize the same mechanism, or a functionally equivalent mechanism,
        to ensure end-to-end security. Implementations are expected to throw errors
        if a cryptographic hash value for a resource does not match the expected hash
        value.
      </p>
      <p>
        Implementations that apply the base context above, as well as other contexts
        and values in any `@context` property, during operations such as
        <a href="https://www.w3.org/TR/json-ld11-api/#expansion-algorithm">
          JSON-LD Expansion</a> or
        <a href="https://www.w3.org/TR/json-ld11/#serializing-deserializing-rdf">
          transformation to RDF</a>, are expected to do so without experiencing any
        errors. If such operations are performed and result in an error,
        the [=verifiable credential=] or [=verifiable presentation=] MUST result
        in a verification failure.
      </p>
      <p>
        It is possible to confirm the SHA-384 digest above by running the following
        command from a modern Unix command interface line:
        `curl -s https://www.w3.org/ns/credentials/v2 | openssl dgst -sha384 -binary | openssl base64 -A`
      </p>
      <p>
        More details regarding this hash encoding method can be found in the <a
          href="https://www.w3.org/TR/SRI/#integrity-metadata">integrity metadata</a>
        section of [[SRI]].
      </p>
      <p class="note" title="See errata if hash value changes are detected">
        It is extremely unlikely that the files that have associated cryptographic hash
        values in this specification will change. However, if critical errata are
        found in the specification and corrections are required to ensure
        ecosystem stability the cryptographic hash values might change. As such, the
        HTTP cache times for the files are not set to infinity and implementers are
        advised to check for errata if a cryptographic hash value change is detected.
      </p>
      <p>
        This section serves as a reminder of the importance of ensuring that, when
        verifying [=verifiable credentials=] and [=verifiable presentations=], the
        [=verifier=] has information that is consistent with what the [=issuer=]
        or [=holder=] had when securing the [=credential=] or [=presentation=].
        This information might include at least:
      </p>
      <ol>
        <li>
          The contents of the credential itself, which is secured in
          [=verifiable credentials=] and [=verifiable presentations=] by using
          mechanisms such as [[VC-JOSE-COSE]] and [[VC-DATA-INTEGRITY]].
        </li>
        <li>
          The content in a credential whose meaning depends on a link to an external URL,
          such as a JSON-LD Context, which can be secured by using a local static copy
          or a cryptographic digest of the file.
        </li>
      </ol>
      <p>
        Verifiers are warned that other data that is referenced from within a
        credential, such as resources that are linked to via URLs, are not
        cryptographically protected by default. It is considered a best practice to
        ensure that the same sorts of protections are provided for any URL that is
        critical to the security of the [=verifiable credential=] through the use of
        permanently cached files and/or cryptographic hashes. See the
        <a data-cite="?vc-imp-guide/#content-integrity">Content Integrity</a>
        section of the Verifiable Credential Implementation Guide for further
        information. Ultimately, knowing the cryptographic digest of any linked external
        content enables a [=verifier=] to confirm that the content is the same
        as what the [=issuer=] or [=holder=] intended.
      </p>
    </section>

    <section class="normative">
      <h3>词汇表</h3>

      <p class="issue" title="(有风险) URL 值可能在候选推荐阶段发生变化">
        本节列出了在候选推荐阶段可能发生变化的 URL 值，这取决于将文档迁移到时间戳位置、将文档迁移到 W3C 技术报告命名空间以及需要修改引用的 URL 的实施者反馈。
      </p>

      <p>
        依赖 RDF 词汇处理的实现必须确保基本上解析到以下文件的词汇 URL，这些文件是规范的。实现可以使用其他语义等效的词汇文件的序列化。为了确保开发人员可以验证每个文件的内容是否正确，提供了所有内容的加密哈希。
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>URL and Media Type</th>
            <th>Content and Hashes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              https://www.w3.org/2018/credentials#<br>
              `application/ld+json`
            </td>
            <td>
              https://www.w3.org/2018/credentials/index.jsonld<br><br>
              sha256: `z52TgKqh2nqTCuACI8lCvhRdjwxQjeVmuOMCDCEijq4=`<br><br>
              sha3-512: `m8Ss+jgZiyL2Ws/ICJcWjHFd9PccJWsXPvMatBOhrH<wbr>
h0qCBrzfgO2zO1OQQbTL7zoPgLseIbcxJJpunD2bkoRA==`
            </td>
          </tr>
          <tr>
            <td>
              https://w3id.org/security#<br>
              `application/ld+json`
            </td>
            <td>
              https://w3c.github.io/vc-data-integrity/vocab/security/vocabulary.jsonld<br><br>
              sha256: `LEaoTyf796eTaSlYWjfPe3Yb+poCW9TjWYTbFDmC0tc=`<br><br>
              sha3-512: `f4DhJ3xhT8nT+GZ8UUZi4QC+HT//wXE2fRTgUP4UNw<wbr>
e4kvel2PFfd6jcofHBm9BjwEiGzVFGv4K+fFTKXRD2NA==`
            </td>
          </tr>
        </tbody>
      </table>

      <p>
        可以通过在现代Unix命令界面中运行以下命令来确认上述加密摘要：
        `curl -sL -H "Accept: &lt;MEDIA_TYPE>" &lt;DOCUMENT_URL> | openssl dgst -&ltDIGEST_ALGORITHM> -binary | openssl
        base64 -nopad -a`
      </p>

      <p class="note" title="schema.org定期更改，但被认为是稳定的">
        实施者和文档作者可能注意到，`schema.org`的加密摘要未提供。这是因为`schema.org`词汇经常更改；任何提供的摘要在发布几周后就会过时。工作组讨论了这个问题，并得出结论，本规范使用的`schema.org`词汇的语义含义多年来一直稳定，并且极不可能发生变化。
      </p>

      <p>
        本规范为处理器和其他受益于此类定义的规范定义了以下基类：
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>Base Class</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr id="bc-credential-evidence">
            <td>
              `CredentialEvidence`
            </td>
            <td>
              Serves as a superclass for specific evidence types that are placed into the
              <a href="#evidence">evidence</a> property. <span class="issue atrisk">This
                superclass is at risk and will be removed if at least two independent
                implementations for the superclass are not identified by the end of the
                Candidate Recommendation phase.</span>
            </td>
          </tr>
          <tr id="bc-credential-schema">
            <td>
              `CredentialSchema`
            </td>
            <td>
              Serves as a superclass for specific schema types that are placed into the
              <a href="#data-schemas">credentialSchema</a> property.
            </td>
          </tr>
          <tr id="bc-credential-status">
            <td>
              `CredentialStatus`
            </td>
            <td>
              Serves as a superclass for specific credential status types that are placed into
              the <a href="#status">credentialStatus</a> property.
            </td>
          </tr>
          <tr id="bc-confidence-method">
            <td>
              `ConfidenceMethod`
            </td>
            <td>
              Serves as a superclass for specific confidence method types that are placed into
              the `confidenceMethod` property.
              <span class="issue atrisk">This superclass is at risk and will be removed if
                at least two independent implementations for the superclass are not identified
                by the end of the Candidate Recommendation phase.
              </span>
            </td>
          </tr>
          <tr id="bc-refresh-service">
            <td>
              `RefreshService`
            </td>
            <td>
              Serves as a superclass for specific refresh service types that are placed into
              the <a href="#refreshing">credentialRefresh</a> property.
              <span class="issue atrisk">This superclass is at risk and will be removed if
                at least two independent implementations for the superclass are not identified
                by the end of the Candidate Recommendation phase.
              </span>
            </td>
          </tr>
          <tr id="bc-render-method">
            <td>
              `RenderMethod`
            </td>
            <td>
              Serves as a superclass for specific render method types that are placed into
              the `renderMethod` property.
              <span class="issue atrisk">This superclass is at risk and will be removed if
                at least two independent implementations for the superclass are not identified
                by the end of the Candidate Recommendation phase.
              </span>
            </td>
          </tr>
          <tr id="bc-terms-of-use">
            <td>
              `TermsOfUse`
            </td>
            <td>
              Serves as a superclass for specific terms of use types that are placed into
              the <a href="#terms-of-use">termsOfUse</a> property.
              <span class="issue atrisk">This superclass is at risk and will be removed if
                at least two independent implementations for the superclass are not identified
                by the end of the Candidate Recommendation phase.
              </span>
            </td>
          </tr>
        </tbody>
      </table>

    </section>

    <section>
      <h3>数据类型</h3>
      <p>
        本节定义了该规范使用的数据类型。
      </p>

      <section>
        <h4>`sriString` 数据类型</h4>

        <p>
          字符串使用[[SRI]]规范中指定的方法为资源提供完整性信息。
        </p>

        <p>
          `sriString` 数据类型定义如下：
        </p>

        <dl>
          <dt>表示此数据类型的URL</dt>
          <dd>`https://www.w3.org/2018/credentials#sriString`</dd>
          <dt>词法空间</dt>
          <dd>
            请参阅[[SRI]]规范中定义的`integrity`属性的<a href="https://www.w3.org/TR/SRI/#the-integrity-attribute">ABNF
              语法</a>，了解字符串格式的限制。
          </dd>
          <dt>值空间</dt>
          <dd>
            一个（可能为空的）<i>(alg,val)</i>对列表，其中<i>alg</i>标识哈希函数，<i>val</i>是标准数学概念中的整数。
          </dd>
          <dt>词法到值的映射</dt>
          <dd>
            通过根据[[SRI]]规范中的<a href="https://www.w3.org/TR/SRI/#parse-metadata">解析元数据算法</a>和<a
              href="https://www.w3.org/TR/SRI/#the-integrity-attribute">ABNF
              语法</a>，将词法空间中的任何元素映射到值空间。
          </dd>
          <dt>规范映射</dt>
          <dd>
            规范映射包括词法到值的映射。
          </dd>
        </dl>
      </section>


    </section>

    <section class="informative">
      <h3>上下文、类型和凭证模式的区别</h3>

      <p>
        [=可验证凭证=]和[=可验证展示=]数据模型利用了包括[[JSON-LD11]]和[[?VC-JSON-SCHEMA]]在内的各种底层技术。本节将对`@context`、`type`和`credentialSchema`属性进行比较，并介绍一些更具体的使用情况，其中可以使用数据模型的这些特性。
      </p>

      <p>
        `type`属性用于唯一标识出现在其中的[=可验证凭证=]的类型，即指示[=可验证凭证=]包含的声明集合。该属性及其值集合中的`VerifiableCredential`值是强制性的。虽然在数组中包含一个额外的值来描述该[=可验证凭证=]的唯一子类型是良好的实践，但可以省略或包含其他类型值。许多验证者将请求特定子类型的[=可验证凭证=]，因此省略子类型值可能会使验证者更难告知持有者他们需要哪个[=可验证凭证=]。当一个[=可验证凭证=]具有多个子类型时，在`type`属性中列出所有子类型是明智的。在[=可验证凭证=]的[[JSON-LD11]]表示中使用`type`属性可以强制执行[=可验证凭证=]的语义，因为机器能够检查语义。在[[JSON-LD11]]中，技术不仅描述了声明集合的分类，还传达了图中属性子图的结构和语义。在[[JSON-LD11]]中，这表示图中节点的类型，这就是为什么一些[=可验证凭证=]的[[JSON-LD11]]表示将在许多对象上使用`type`属性的原因。
      </p>

      <p>
        `@context`属性的主要目的是以[[JSON-LD11]]的视角传达数据的含义和数据的术语定义，以机器可读的方式。`@context`属性用于将[=可验证凭证=]和[=可验证展示=]中属性的全局唯一URL映射为短形式的别名，使[[JSON-LD11]]表示更易于阅读。从[[JSON-LD11]]的视角来看，这种映射还允许在一个机器可读数据图中对[=可验证凭证=]或[=可验证展示=]中的数据进行建模，通过增强[=可验证凭证=]或[=可验证展示=]中的数据与更大的机器可读数据图的关系。这对于告诉机器如何将数据的含义与无法协调的各方的其他数据相关联非常有用。这个属性的第一个值是`https://www.w3.org/ns/credentials/v2`，是强制性的。
      </p>

      <p>
        由于`@context`属性用于将数据映射到图数据模型中，而[[JSON-LD11]]中的`type`属性用于描述图中的节点，当同时使用这两个属性时，`type`属性变得更加重要。例如，如果在使用[[JSON-LD11]]解析的`@context`资源中不包含`type`属性，可能会导致声明被丢弃和/或其完整性在[=可验证凭证=]的生成和消费过程中不再受到保护。或者，在[=可验证凭证=]的生成或消费过程中可能会引发错误。这将取决于实现的设计选择，今天的实现中都使用了这两种路径，因此在使用[=可验证凭证=]或[=可验证展示=]的[[JSON-LD11]]表示时，注意这些属性非常重要。
      </p>

      <p>
        `credentialSchema`属性的主要目的是定义[=可验证凭证=]的结构以及每个属性值的数据类型。`credentialSchema`对于定义[=可验证凭证=]中一组声明的内容和结构非常有用，而[[JSON-LD11]]和[=可验证凭证=]中的`@context`最好只用于传达数据的语义和术语定义，并且也可以用于定义[=可验证凭证=]的结构。
      </p>

      <p>
        虽然可以使用一些[[JSON-LD11]]的特性来暗示[=可验证凭证=]的内容，但通常不建议使用`@context`来限制数据模型的数据类型。例如，`"@type":
        "@json"`对于保持语义开放和不严格定义是有用的。如果实现者希望限制[=凭证=]中声明的数据类型，并且不希望使用该属性，这可能是危险的。
      </p>

      <p>
        当`credentialSchema`和`@context`属性结合使用时，生产者和消费者都可以更加确信[=可验证凭证=]和[=可验证展示=]的预期内容和数据类型。
      </p>
    </section>
  </section>

  <section class="appendix informative">
    <h2>IANA注意事项</h2>

    <p>
      本节将提交给互联网工程指导组（IESG）进行审查、批准，并在IANA注册。
    </p>

    <section id="vc-ld-media-type">
      <h2>application/vc+ld+json</h2>
      <p>
        本规范专门为识别符合可验证凭证格式的文档注册了`application/vc+ld+json`媒体类型。
      </p>
      <table>
        <tr>
          <td>类型名称：</td>
          <td>应用程序</td>
        </tr>
        <tr>
          <td>子类型名称：</td>
          <td>vc+ld+json</td>
        </tr>
        <tr>
          <td>必需参数：</td>
          <td>无</td>
        </tr>
        <tr>
          <td>编码注意事项：</td>
          <td>
            使用"`application/vc+ld+json`"媒体类型的资源
            必须符合所有"`application/ld+json`"媒体类型的要求，因此受到[[RFC7159]]第11节中指定的相同编码注意事项的约束。
          </td>
        </tr>
        <tr>
          <td>安全性考虑：</td>
          <td>按照本规范定义。</td>
        </tr>
        <tr>
          <td>联系方式：</td>
          <td>
            W3C 可验证凭证工作组
            <a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
          </td>
        </tr>
      </table>

      <p>
        请注意，虽然可验证凭证格式使用了JSON-LD约定，
        但是对于可验证凭证实现有一些约束和额外要求，这就证明了使用特定媒体类型的必要性。
      </p>

      <p>
        这种媒体类型可以用于使用[=封装证明=]保护的凭证。
      </p>
      <p>
        期望在文档的主体中存在一个[[JSON-LD11]]上下文，并且如媒体类型中的`ld+json`所示，期望凭证是一个有效的
        <a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document">JSON-LD
          文档</a>。
      </p>
    </section>

    <section id="vp-ld-media-type">
      <h2>application/vp+ld+json</h2>
      <p>
        本规范专门为符合可验证呈现格式的文档注册了`application/vp+ld+json`媒体类型。
      </p>
      <table>
        <tr>
          <td>类型名称：</td>
          <td>application</td>
        </tr>
        <tr>
          <td>子类型名称：</td>
          <td>vp+ld+json</td>
        </tr>
        <tr>
          <td>必需参数：</td>
          <td>无</td>
        </tr>
        <tr>
          <td>编码注意事项：</td>
          <td>
            使用"`application/vp+ld+json`"媒体类型的资源需要遵守
            "`application/ld+json`"媒体类型的所有要求，因此需要遵循[[RFC7159]]第11节中规定的相同编码注意事项。
          </td>
        </tr>
        <tr>
          <td>安全注意事项：</td>
          <td>按照本规范定义。</td>
        </tr>
        <tr>
          <td>联系方式：</td>
          <td>
            W3C 可验证凭证工作组
            <a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
          </td>
        </tr>
      </table>

      <p>
        请注意，虽然可验证凭证格式使用 JSON-LD 约定，但可验证凭证实现有许多限制和额外要求，这些限制和要求足以证明使用特定媒体类型是合理的。
      </p>

      <p>
        该媒体类型可用于使用[=enveloping proof=]保护的演示文稿。
      </p>
      <p>
        预计文档正文中会存在一个[[JSON-LD11]]上下文，并且如媒体类型中的`ld+json`所示，凭证预计将是一个有效的
        <a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document">JSON-LD
          文档</a>。
      </p>
    </section>

  </section>

  <section class="appendix informative">
    <h2>Additional Diagrams for Verifiable Presentations</h2>

    <p>
      <a href="#info-graph-vp-mult-creds"></a> below is a variant of <a href="#info-graph-vp"></a>:
      a [=verifiable presentation=] referring to two [=verifiable credentials=], and using [=embedded proofs=]
      based on [[?VC-DATA-INTEGRITY]].
      Each [=verifiable credential graph=] is connected to
      its own separate [=proof graph=]; the `verifiableCredential` property is used
      to connect the [=verifiable presentation=] to the [=verifiable credential graphs=].
      The [=presentation=] [=proof graph=] represents the digital signature of the [=verifiable presentation graph=],
      both [=verifiable credential graphs=], and the [=proof graphs=] linked from the [=verifiable credential graphs=].
      The complete [=verifiable presentation=]
      consists, in this case, of six information [=graphs=].
    </p>

    <figure id="info-graph-vp-mult-creds">
      <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-graph-mult-creds.svg" alt="
Diagram with a 'verifiable presentation graph' on top, connected via a
'proof' to a 'verifiable presentation proof graph' on the bottom. The
verifiable presentation graph has an object, 'Presentation ABC', with 3
properties: 'type' with value 'VerifiablePresentation'; 'termsOfUse' with
value 'Do Not Archive'; and two instances of 'verifiableCredential',
detailed below. This graph is annotated with a parenthetical remark, '(the
default graph)'. This graph is connected, through 'verifiableCredential',
to the part of the figure that consists two variants of Figure 6 (one is
identical; the other has minor differences in the labels referring to
validity dates, the name of the person, and the values for the nonce and
the signature), except that these verifiable credential graphs are
annotated to be named graphs instead of a default graph. The verifiable
presentation proof graph has an object labeled 'Signature 8920' with 5
properties: 'type' with value 'DataIntegrityProof'; 'verificationMethod'
with value 'Example Presenter Public Key 11'; 'created' with value
'2024-01-02T12:43:56Z'; 'nonce' with value 'hasdkyruod87j'; and
'proofValue' with value 'zpewJHoan87='. This graph is annotated with the
parenthetical remark '(a named graph)'
            ">
      <figcaption style="text-align: center;">
        A variant of <a href="#info-graph-vp"></a>: information [=graphs=] associated with a [=verifiable presentation=]
        referring to two
        verifiable credentials, using an [=embedded proof=] based on [[[VC-DATA-INTEGRITY]]] [[?VC-DATA-INTEGRITY]].
      </figcaption>
    </figure>

    <p>
      <a href="#info-graph-vp-jwt-mult-creds"></a> below shows the same [=verifiable presentation=]
      as <a href="#info-graph-vp-mult-creds"></a>, but using an [=enveloping proof=] based on [[?VC-JOSE-COSE]].
      Each [=verifiable credential graph=] contains a single
      <a href="#defn-EnvelopedVerifiableCredential">`EnvelopedVerifiableCredential`</a> instance,
      referring, via a `data:` URL [[RFC2397]], to a verifiable credential secured via
      an [=enveloping proof=]</a>.
    </p>

    <figure id="info-graph-vp-jwt-mult-creds">
      <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-jwt-mult-creds.svg" alt="
Diagram with, on the left, a box, labeled as 'JWT (Decoded)', and with
three textual labels stacked vertically, namely 'Header', 'Payload', and
'Signature'. The 'Header' label is connected, with an arrow, to a
separate rectangle on the right hand side containing six text fields:
'kid: aB8J-_Z', 'alg: ES384', and 'cty: vc+ld+json', iss:
https://example.com, iat: 1704690029, and typ: vp+ld+json+sd-jwt The
'Payload' label of the left side is connected, with an arrow, to a
separate rectangle, consisting of three related graphs (stacked
vertically) connected by two arrows labeled 'verifiableCredential'
starting from the top graph and connecting it to the two other graphs,
respectively. The top graph has a label 'verifiable presentation graph
(serialized in JSON)'; the other two are both labeled by 'verifiable
credential graph (serialized in JSON)'. The top graph in the rectangle
has and object 'Presentation ABC' with 3 properties: 'type' of value
VerifiablePresentation, 'termsOfUse' of value 'Do Not Archive'. One of
the the bottom graphs includes
'data:application/vc+ld+json+sd-jwt;QzVjV...RMjU' as a subject with a
single property: 'type' of value `EnvelopedVerifiableCredential`. The
last bottom graph is identical other, except for the subject which is
labeled as 'data:application/vc+ld+json+sd-jwt;RkOyT...KjOl'. Finally,
the 'Signature' label on the left side is connected, with an arrow, to a
separate rectangle, containing a single text field:
'cYjaSdfIoJH45NIqw3MYnasGIba...'.
        ">
      <figcaption style="text-align: center;">
        A variant of <a href="#info-graph-vp-jwt"></a>: information [=graphs=] associated with a [=verifiable
        presentation=]
        referring to two verifiable credentials using [=enveloping proofs=] based on JOSE [[?VC-JOSE-COSE]].
      </figcaption>
    </figure>


  </section>

  <section>
    <h2>修订历史</h2>

    <p>
      本节包含了此规范随时间所做的实质性更改。
    </p>

    <p>
      自
      <a href="https://www.w3.org/TR/2022/REC-vc-data-model-20220303/">
        v1.1 推荐规范</a>以来的变更：
    </p>
    <ul>
      <li>
        进行了许多编辑更新和修复，以使规范现代化并更容易理解特定概念。
      </li>
      <li>
        在数据完整性和本规范之间删除了关于 `proof` 的重复声明。
      </li>
      <li>
        澄清了发行者验证的过程。
      </li>
      <li>
        澄清了保护机制扩展点的要求。
      </li>
      <li>
        在算法部分添加了对 [[?INFRA]] 的依赖。
      </li>
      <li>
        添加了保护机制规范的要求。
      </li>
      <li>
        澄清了执行特定凭证类型处理的方法。
      </li>
      <li>
        添加了在可验证演示中嵌入封装的可验证凭证的机制。
      </li>
      <li>
        添加验证算法、安全机制接口和问题详细信息对象。
      </li>
      <li>
        调整`issuer`属性的允许值。
      </li>
      <li>
        提供更具体的指导，以表达语言信息以及默认语言和方向。
      </li>
      <li>
        为发行者和验证者实现添加新的符合类。
      </li>
      <li>
        添加有关密钥管理的新的安全注意事项。
      </li>
      <li>
        添加有关信任边界、基于元数据的关联、数据盗窃和使用Oblivious HTTP的隐私注意事项。
      </li>
      <li>
        正式定义词汇的基类和属性。
      </li>
      <li>
        提供警告，不要使用高级JSON-LD功能，以最大程度地提高互操作性。
      </li>
      <li>
        提供更明确的指导，涉及集合和数组。
      </li>
      <li>
        为发行者和凭证添加`name`和`description`字段的支持。
      </li>
      <li>
        添加有关拦截、重放和欺骗攻击的安全注意事项。
      </li>
      <li>
        在基本JSON-LD上下文中添加JWT和SD-JWT声明。
      </li>
      <li>
        澄清“凭证”和“可验证凭证”的区别。
      </li>
      <li>
        添加关于如何确保生态系统兼容性的部分。
      </li>
      <li>
        添加关于特定凭证类型处理的部分。
      </li>
      <li>
        添加关于验证和与持有者的相关性的部分。
      </li>
      <li>
        添加关于媒体类型精度和解释的部分。
      </li>
      <li>
        确保使用`dateTimeStamp`作为时间值。提供有关时间值和时区的正确使用的进一步指导。
      </li>
      <li>
        使`validFrom`变为可选。
      </li>
      <li>
        添加`relatedResource`功能。
      </li>
      <li>
        使基本上下文和词汇成为规范，并为其内容提供加密哈希。
      </li>
      <li>
        将`renderMethod`和`confidenceMethod`添加到保留属性列表中。
      </li>
      <li>
        更新规范中的示例。
      </li>
      <li>
        添加“入门指南”部分。
      </li>
      <li>
        添加保留属性的属性表，这些属性尚未标准化或有可能被删除。
      </li>
      <li>
        将数据模型序列化限制为紧凑文档形式的JSON-LD。
      </li>
      <li>
        更新ZKP部分以删除旧内容。
      </li>
      <li>
        在v2上下文中为演示文稿添加`termsOfUse`。
      </li>
      <li>
        在v2上下文中为未定义术语添加默认词汇。
      </li>
      <li>
        添加`application/vc+ld+json`和`application/vp+ld+json`的媒体类型。
      </li>
      <li>
        提供有关如何将符合要求的文档与其他数字凭证格式进行转换的指导。
      </li>
      <li>
        将对URI/IRI的引用更改为使用WHATWG URL规范。
      </li>
      <li>
        在数据完整性和JOSE/COSE安全机制上添加规范依赖。
      </li>
      <li>
        将`issuanceDate`/`expirationDate`重命名为`validFrom`/`validUntil`。
      </li>
      <li>
        添加JSON Schema支持，并更新示例以使用新格式。
      </li>
      <li>
        澄清`credentialSubject`值不能为字符串。
      </li>
      <li>
        创建更正式的词汇文档，引用此规范。
      </li>
      <li>
        定义v2.0 JSON-LD上下文。
      </li>
      <li>
        将VC-JWT部分迁移到单独的安全规范。
      </li>
      <li>
        将主题-持有者关系移至可验证凭证实现指南。
      </li>
      <li>
        将版本号增加到v2.0，并删除之前的REC跟踪评论。
      </li>
      <li>
        在可验证凭证数据完整性规范[[VC-DATA-INTEGRITY]]中添加规范依赖。
      </li>
      <li>
        由于v1.0和v1.1中缺乏实现，删除了关于“争议”的部分。
      </li>
    </ul>

    <p>
      自
      <a href="https://www.w3.org/TR/2019/REC-vc-data-model-20191119/">
        v1.0 推荐</a>以来的变化：
    </p>
    <ul>
      <li>
        添加此修订历史部分。
      </li>

      <li>
        更新先前的规范参考，将指向 RFC3339 的日期时间详细信息改为规范参考 XMLSCHEMA11-2，这更准确地反映了示例和库中的使用情况。
      </li>

      <li>
        放宽要求，允许在数据模型的 `credentialStatus` 和 `refreshService` 部分的 `id` 属性中使用无法解引用的 [=URLs=]。
      </li>

      <li>
        放宽零知识证明部分的规范性陈述，以支持新的零知识证明方案，例如 BBS+，这些方案是在 v1.0 规范作为推荐标准发布之后创建的。
      </li>

      <li>
        更新所有引用，指向所引用规范的最新版本。修复指向已不可用的论文的损坏链接，将其更新为可用论文的新位置。
      </li>

      <li>
        提高 SVG 图表的可访问性。
      </li>

      <li>
        修复一些示例中与 `issuer`、`issuanceDate`、`credentialStatus`、日期、失效链接和次要语法错误相关的编辑错误。
      </li>

      <li>
        将致谢从“文档状态”部分移至致谢附录。
      </li>
    </ul>
  </section>

  <section class="appendix informative">
    <h2>致谢</h2>

    <p>
      工作组感谢以下个人不仅对本文档内容的贡献，还对这个标准社区的辛勤工作，推动了变革、讨论和共识，尽管意见各异：Matt Stone、Gregg Kellogg、Ted Thibodeau Jr、Oliver Terbu、Joe
      Andrieu、David I. Lehn、Matthew Collier和Adrian Gropper。
    </p>

    <p>
      本规范的工作得到了由Christopher Allen、Shannon Appelcline、Kiara Robles、Brian Weller、Betty Dhamers、Kaliya Young、Manu
      Sporny、Drummond Reed、Joe Andrieu、Heather Vescent、Kim Hamilton Duffy、Samantha Chase和Andrew Hughes组织的Rebooting the
      Web of Trust社区的支持。由Phil Windley、Kaliya Young、Doc Searls和Heidi Nobantu Saul组织的Internet Identity
      Workshop的参与者也通过众多工作会议的设计来支持这项工作的完善，旨在教育、辩论和改进本规范。
    </p>

    <p>
      工作组还感谢我们的主席Dan Burnett、Matt Stone、Brent Zundel、Wayne Chang和Kristina Yasuda，以及我们的W3C工作人员联系人Kazuyuki Ashimura和Ivan
      Herman，他们在W3C标准化过程中的专业管理和稳定指导。
    </p>

    <p>
      本规范的部分工作得到了美国国土安全部科学与技术总局根据合同HSHQDC-17-C-00019的资助。本规范的内容不一定反映美国政府的立场或政策，不应推断出任何官方认可。
    </p>

    <p>
      工作组要感谢以下个人对规范进行审查并提供反馈意见（按字母顺序排列）：
    </p>

    <p>
      Christopher Allen, David Ammouial, Joe Andrieu, Bohdan Andriyiv, Ganesh
      Annan, Kazuyuki Ashimura, Tim Bouma, Pelle Braendgaard, Dan Brickley,
      Allen Brown, Jeff Burdges, Daniel Burnett, ckennedy422, David Chadwick,
      Chaoxinhu, Kim (Hamilton) Duffy, Lautaro Dragan, enuoCM, Ken Ebert, Eric
      Elliott, William Entriken, David Ezell, Nathan George, Reto Gmür, Ryan
      Grant, glauserr, Adrian Gropper, Joel Gustafson, Amy Guy, Lovesh
      Harchandani, Daniel Hardman, Dominique Hazael-Massieux, Jonathan Holt,
      David Hyland-Wood, Iso5786, Renato Iannella, Richard Ishida, Ian Jacobs,
      Anil John, Tom Jones, Rieks Joosten, Gregg Kellogg, Kevin, Eric Korb,
      David I. Lehn, Michael Lodder, Dave Longley, Christian Lundkvist, Jim
      Masloski, Pat McBennett, Adam C. Migus, Liam Missin, Alexander Mühle,
      Anthony Nadalin, Clare Nelson, Mircea Nistor, Grant Noble, Darrell
      O'Donnell, Nate Otto, Matt Peterson, Addison Phillips, Eric Prud'hommeaux,
      Liam Quin, Rajesh Rathnam, Drummond Reed, Yancy Ribbens, Justin Richer,
      Evstifeev Roman, RorschachRev, Steven Rowat, Pete Rowley, Markus
      Sabadello, Kristijan Sedlak, Tzviya Seigman, Reza Soltani, Manu Sporny,
      Orie Steele, Matt Stone, Oliver Terbu, Ted Thibodeau Jr, John Tibbetts,
      Mike Varley, Richard Varn, Heather Vescent, Christopher Lemmer Webber,
      Benjamin Young, Kaliya Young, Dmitri Zagidulin, and Brent Zundel.
    </p>
  </section>
</body>

</html>