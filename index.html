<!DOCTYPE html>
<html>

<head>
  <title>Verifiable Credentials Data Model v2.0</title>
  <meta http-equiv='Content-Type' content='text/html;charset=utf-8' />
  <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
  <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
  <script src="./common.js" class="remove"></script>
  <script class="remove" src="https://cdn.jsdelivr.net/gh/digitalbazaar/respec-vc@2.0.1/dist/main.js"></script>
  <script class="removeOnSave" src="https://unpkg.com/reqlist/lib/reqlist.js"></script>
  <link class="removeOnSave" rel="stylesheet" type="text/css" href="https://unpkg.com/reqlist/lib/reqlist.css" />

  <script class="remove">
    var respecConfig = {
      group: "vc",

      // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus: "CRD",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "vc-data-model-2.0",

      // subtitle for the spec
      //subtitle: "Expressing information with verifiable provenance",

      // if you wish the publication date to be other than today, set this
      //publishDate: "2024-01-23",
      crEnd: "2024-03-23",
      //prEnd: "2019-10-01",
      implementationReportURI: "https://w3c.github.io/vc-data-model-2.0-test-suite/",
      //errata: "https://w3c.github.io/vc-data-model/errata.html",
      previousMaturity: "REC",
      previousPublishDate: "2022-03-03",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate:  "1977-03-15",
      // previousMaturity:  "WD",

      // extend the bibliography entries
      localBiblio: vcwg.localBiblio,
      doJsonLd: true,

      // Uncomment these to use the respec extension that generates a list of
      //   normative statements:
      preProcess: [/*prepare_reqlist*/],
      postProcess: [
        restrictRefs,
        window.respecVc.createVcExamples
        /*add_reqlist_button*/
      ],

      github: "https://github.com/w3c/vc-data-model/",
      includePermalinks: false,

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI: "https://w3c.github.io/vc-data-model/",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      // editors, add as many as you like
      // only "name" is required
      editors: [
        {
          name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          note: "v1.0, v1.1, v2.0", w3cid: 41758
        },
        {
          name: "Ted Thibodeau Jr", url: "https://github.com/TallTed",
          company: "OpenLink Software", companyURL: "https://www.openlinksw.com/",
          note: "v2.0", w3cid: 42501
        },
        {
          name: "Ivan Herman", url: "https://www.w3.org/People/Ivan/",
          company: "W3C", companyURL: "https://www.w3.org",
          note: "v2.0", w3cid: 7382, orcid: "0000-0003-0782-2704"
        },
        {
          name: "Michael B. Jones", url: "https://self-issued.info/",
          company: "Invited Expert",
          note: "v2.0", w3cid: 38745
        },
        {
          name: "Gabe Cohen", url: "https://github.com/decentralgabe",
          company: "Block", companyURL: "https://block.xyz/",
          note: "v2.0", w3cid: 116851
        },
      ],
      formerEditors: [
        {
          name: "Grant Noble", url: "https://www.linkedin.com/in/grant-noble-8253994a/",
          company: "ConsenSys", companyURL: "https://consensys.net/",
          note: "v1.0", w3cid: 110600
        },
        {
          name: "Dave Longley", url: "https://github.com/dlongley",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          note: "v1.0", w3cid: 48025
        },
        {
          name: "Daniel C. Burnett", url: "https://www.linkedin.com/in/daburnett/",
          company: "ConsenSys", companyURL: "https://consensys.net/",
          note: "v1.0", w3cid: 37473
        },
        {
          name: "Brent Zundel", url: "https://www.linkedin.com/in/bzundel/",
          company: "Evernym", companyURL: "https://www.evernym.com/",
          note: "v1.0", w3cid: 102128
        },
        {
          name: "Kyle Den Hartog", url: "https://www.linkedin.com/in/kyledenhartog/",
          company: "MATTR", companyURL: "https://mattr.global/",
          note: "v1.1", w3cid: 103517
        },
        {
          name: "Orie Steele", url: "https://github.com/OR13",
          company: "Transmute",
          companyURL: "https://transmute.industries/",
          note: "v2.0", w3cid: 109171
        },
        {
          name: "Oliver Terbu", url: "https://github.com/awoie",
          company: "Spruce Systems", companyURL: "https://spruceid.com/",
          note: "v2.0", w3cid: 110059
        }
      ],
      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:
        [
          {
            name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 41758
          },
          {
            name: "Dave Longley", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 48025
          },
          {
            name: "David Chadwick",
            url: "https://www.linkedin.com/in/davidwchadwick/",
            company: "Crossword Cybersecurity PLC",
            companyURL: "https://www.crosswordcybersecurity.com/",
            w3cid: 46156
          },
          {
            name: "Orie Steele", url: "https://github.com/OR13",
            company: "Transmute",
            companyURL: "https://www.transmute.industries/",
            note: "v2.0", w3cid: 109171
          }
        ],
      xref: ["URL", "I18N-GLOSSARY", "INFRA"],
      lint: { "informative-dfn": false },
      maxTocLevel: 2,
      inlineCSS: true
    };
  </script>
  <style>
    code {
      color: rgb(199, 73, 0);
      font-weight: bold;
    }

    pre {
      overflow-x: auto;
      white-space: pre-wrap;
    }

    pre .highlight {
      font-weight: bold;
      color: Green;
    }

    pre .subject {
      font-weight: bold;
      color: RoyalBlue;
    }

    pre .property {
      font-weight: bold;
      color: DarkGoldenrod;
    }

    pre .comment {
      font-weight: bold;
      color: SteelBlue;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    ol.algorithm {
      counter-reset: numsection;
      list-style-type: none;
    }

    ol.algorithm li {
      margin: 0.5em 0;
    }

    ol.algorithm li:before {
      font-weight: bold;
      counter-increment: numsection;
      content: counters(numsection, ".") ") ";
    }
  </style>
</head>

<body>
  <section id='abstract'>
    <p>
      [=凭证=]是我们日常生活的一部分；驾驶执照用于证明我们有驾驶汽车的能力，大学学位可以用来证明我们的教育水平，政府颁发的护照使我们能够在各国之间旅行。这个规范提供了一种在网络上表达这些类型的[=凭证=]的机制，这种机制是加密安全的，尊重隐私，且可由机器验证。
    </p>
  </section>

  <section id='sotd'>
    <p>
      工作组正在积极寻求对此规范的实施反馈。为了退出候选推荐阶段，工作组已设定了每个规范中的每个强制性功能至少需要两个独立实施的要求。请查看<a
        href="https://w3c.github.io/vc-data-model-2.0-test-suite/">
        实施报告</a>以获取更多详细信息。
    </p>

    <p>
      欢迎随时对此规范提出评论。
      请直接在
      <a href="https://github.com/w3c/vc-data-model/issues/">GitHub</a>上提交问题，
      或者，如果无法做到这一点，请发送到
      <a href="mailto:public-vc-comments@w3.org">public-vc-comments@w3.org</a>
      (<a href="mailto:public-vc-comments-request@w3.org?subject=subscribe">订阅</a>,
      <a href="https://lists.w3.org/Archives/Public/public-vc-comments/">档案</a>)。
    </p>

  </section>

  <section class="informative">
    <h2>简介</h2>

    <p>
      凭证是我们日常生活的一部分；驾驶执照用于证明我们有能力操作机动车辆，大学学位可用于证明我们的教育水平，政府颁发的护照使我们能够在国家之间旅行。这些凭证在现实世界中为我们提供了便利，但在网络上使用它们仍然难以捉摸。
    </p>

    <p>
      目前，在网络上表达教育资格、医疗数据、财务账户详细信息以及其他类型的第三方验证的机器可读个人信息是很困难的。在网络上表达数字凭证的困难使得在网络上获得与现实世界中相同的利益变得具有挑战性。
    </p>

    <p>
      本规范为在网络上表达凭证提供了一种标准方法，这种方法在密码学上是安全的，尊重隐私且可供机器验证。
    </p>

    <p>
      对于那些不熟悉与可验证凭证相关的概念的人，以下部分提供了一个概述：
    </p>

    <ul>
      <li>
        构成可验证凭证的组件
      </li>
      <li>
        构成可验证展示的组件
      </li>
      <li>
        可验证凭证和可验证展示预期有用的生态系统
      </li>
      <li>
        为本规范提供指导的用例和要求。
      </li>
    </ul>

    <section class="informative">
      <h3>什么是可验证凭证？</h3>

      <p>
        在现实世界中，凭证可能包括：
      </p>

      <ul>
        <li>
          与凭证主体相关的身份信息（例如，照片、姓名或身份证号）
        </li>
        <li>
          与颁发机构相关的信息（例如，市政府、国家机构或认证机构）
        </li>
        <li>
          与此凭证类型相关的信息（例如，荷兰护照、美国驾驶执照或健康保险卡）
        </li>
        <li>
          由颁发机构关于主体的特定属性或属性的相关信息（例如，国籍、有资格驾驶的车辆类别或出生日期）
        </li>
        <li>
          与凭证衍生的证据相关的信息
        </li>
        <li>
          与凭证约束相关的信息（例如，有效期或使用条款）。
        </li>
      </ul>

      <p>
        可验证凭证可以表示与实体凭证相同的所有信息。数字签名等技术的添加使可验证凭证比实体凭证更具篡改证据和更值得信赖。
      </p>

      <p>
        可验证凭证的持有者可以生成可验证的展示，然后与验证者共享这些可验证的展示，以证明他们具有某些特征的可验证凭证。
      </p>

      <p>
        可验证凭证和可验证展示可以快速传输，使它们在远程建立信任时比实体凭证更方便。
      </p>

      <p>
        虽然本规范试图改进表达数字凭证的便利性，但它还试图平衡这一目标与一系列保护隐私的目标。数字信息的持久性以及不同数字数据来源的收集和关联的便利性，构成了使用可验证且易于机器阅读的凭证可能加剧的隐私问题。本文档在<a
          href="#privacy-considerations"></a>部分概述并试图解决这些问题。本文档还提供了如何使用保护隐私的技术（例如零知识证明）使用此数据模型的示例。
      </p>

      <p>
        术语可验证凭证和可验证展示中的“可验证”是指凭证或展示具有可由验证者验证的特性，如本文档所定义。凭证的可验证性并不意味着其中编码的声明是真实的。相反，在建立可验证凭证或可验证展示的真实性和时效性后，验证者使用自己的业务规则验证包含的声明，然后才依赖它们。这种依赖仅在评估发行者、证明、主题和声明之后，根据一个或多个验证者策略进行。
      </p>
    </section>

    <section class="informative">
      <h3>生态系统概述</h3>

      <p>
        本节描述了核心参与者的角色以及在可验证凭证预期有用的生态系统中它们之间的关系。角色是一个抽象，可以用许多不同的方式实现。角色的分离表明了可能的接口和协议标准化。本规范引入了以下角色：
      </p>

      <dl>
        <dt>[=holder=]（持有者）</dt>
        <dd>
          通过拥有一个或多个可验证凭证并从中生成可验证展示来执行的实体角色。示例持有者包括学生、员工和客户。
        </dd>
        <dt>[=issuer=]（发行者）</dt>
        <dd>
          实体执行的角色，通过对一个或多个主体进行声明，从这些声明中创建可验证凭证，并将可验证凭证传输给持有者。示例发行者包括公司、非营利组织、行业协会、政府和个人。
        </dd>
        <dt>[=subject=]（主体）</dt>
        <dd>
          进行声明的实体。示例主体包括人类、动物和事物。在许多情况下，可验证凭证的持有者是主体，但在某些情况下不是。例如，父母（持有者）可能持有孩子（主体）的可验证凭证，或者宠物主人（持有者）可能持有他们宠物（主体）的可验证凭证。有关这些特殊情况的更多信息，请参阅可验证凭证实施指南[[VC-IMP-GUIDE]]中的
          <a href="https://www.w3.org/TR/vc-imp-guide/#subject-holder-relationships">
            主体-持有者关系</a>部分。
        </dd>
        <dt>[=verifier=]（验证者）</dt>
        <dd>
          通过接收一个或多个可验证凭证（可选地在可验证展示中）进行处理的实体角色。示例验证者包括雇主、安全人员和网站。
        </dd>
        <dt>[=verifiable data registry=]（可验证数据注册表）</dt>
        <dd>
          系统可能通过调解创建和验证标识符、密钥和其他相关数据（如可验证凭证模式、撤销注册表、发行者公钥等）来执行的角色，这些数据可能需要使用可验证凭证。某些配置可能需要可关联的主体标识符。示例可验证数据注册表包括可信数据库、分布式数据库、政府ID数据库和分布式分类帐。通常，在生态系统中会使用多种类型的可验证数据注册表。
        </dd>
      </dl>

      <figure id="roles">
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/ecosystem.svg" alt="示意图显示了
               凭证从发行者流向持有者，
               展示从持有者流向验证者，所有
               三方均可使用来自逻辑
               可验证数据注册表的信息">
        <figcaption style="text-align: center;">
          构成本规范基础的角色和信息流。
        </figcaption>
      </figure>

      <p class="note">
        上面的<a href="#roles"></a>提供了一个示例生态系统，以便将本规范的其他概念固定下来。其他生态系统（如受保护的环境或专有系统）也存在，其中可验证凭证也具有优势。
      </p>
    </section>

    <section class="informative">
      <h3>用例和要求</h3>

      <p>
        可验证凭证用例文档[[VC-USE-CASES]]概述了一些关键主题，读者可能会发现这些主题很有用，包括：
      </p>

      <ul>
        <li>
          对上述引入的
          <a href="https://www.w3.org/TR/vc-use-cases/#user-roles">角色</a>
          的更详细解释
        </li>
        <li>
          在市场垂直领域（如教育、金融、医疗、零售、专业许可和政府）中确定的
          <a href="https://www.w3.org/TR/vc-use-cases/#user-needs">需求</a>
        </li>
        <li>
          生态系统中角色执行的常见
          <a href="https://www.w3.org/TR/vc-use-cases/#user-tasks">任务</a>
          以及与之相关的要求
        </li>
        <li>
          工作组确定的常见
          <a href="https://www.w3.org/TR/vc-use-cases/#user-sequences">序列和流程</a>。
        </li>
      </ul>

      <p>
        通过记录和分析用例文档，为本规范确定了以下理想的生态系统特征：
      </p>
      <!-- 要求列表开始 -->
      <ul>
        <li>
          可验证凭证代表发行者以防篡改和尊重隐私的方式所作的声明。
        </li>
        <li>
          持有者可以将来自不同发行者的可验证凭证集合组装成一个单一的工件，即可验证展示。
        </li>
        <li>
          发行者可以颁发关于任何主体的可验证凭证。
        </li>
        <li>
          执行发行者、持有者或验证者的角色不需要任何权威机构的注册或批准，因为涉及的信任是双方之间的。
        </li>
        <li>
          可验证展示允许任何验证者验证来自任何发行者的可验证凭证的真实性。
        </li>
        <li>
          持有者可以从任何人那里接收可验证凭证。
        </li>
        <li>
          持有者可以通过任何用户代理与任何发行者和任何验证者互动。
        </li>
        <li>
          持有者可以共享可验证展示，然后可以验证它们，而无需向发行者透露验证者的身份。
        </li>
        <li>
          验证者可以验证可验证展示的真实性，而无需向发行者透露验证者的身份。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，而不需要共享主体的唯一标识符。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时尊重主体的隐私。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体选择性地披露信息。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体保留对披露给验证者的信息的控制。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行最小化。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行选择性披露。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行选择性披露，而无需泄露其他信息。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行选择性披露，而无需泄露其他信息，且不需要向发行者透露验证者的身份。
        </li>
      </ul>
      <!-- 要求列表结束 -->
    </section>
  </section>
  <section class="normative">
    <h2>术语</h2>

    <p>
      以下术语用于描述本规范中的概念。
    </p>

    <dl class="termlist definitions">
      <dt><dfn class="export" data-lt="claims">声明</dfn></dt>
      <dd>
        关于某个[=主体=]的断言。
      </dd>
      <dt><dfn class="export" data-lt="credential|credentials">凭证</dfn></dt>
      <dd>
        由一个[=发行者=]做出的一个或多个[=声明=]的集合。凭证中的[=声明=]
        可以关于不同的[=主体=]。本规范中使用的凭证的定义与
        <a href="https://csrc.nist.gov/glossary/term/credential">NIST的凭证定义</a>不同。
      </dd>
      <dt><dfn>数据最小化</dfn></dt>
      <dd>
        限制共享数据的行为，严格限制到完成任务或目标所必需的最小量。
      </dd>
      <dt><dfn data-lt="decentralized identifiers|DID|DIDs">去中心化标识符</dfn></dt>
      <dd>
        一种便携式基于URL的标识符，也被称为<strong><em>DID</em></strong>，
        与[=实体=]相关联。这些标识符最常用于
        [=可验证的凭证=]，并与[=主体=]关联，使得一个
        [=可验证的凭证=]可以轻易地从一个
        [=仓库=]迁移到另一个，而无需重新发行[=凭证=]。
        DID的一个例子是`did:example:123456abcdef`。
      </dd>
      <dt><dfn class="lint-ignore" data-lt="decentralized identifier documents|DID document|DID documents">去中心化
          标识符文档</dfn></dt>
      <dd>
        也被称为<strong><em>DID文档</em></strong>，这是一个可以通过[=可验证数据注册表=]访问的文档，
        包含与特定[=去中心化标识符=]相关的信息，如相关的[=仓库=]和公钥信息。
      </dd>
      <dt><dfn data-lt="default graph">默认图</dfn></dt>
      <dd>
        包含所有不明确属于
        [=命名图=]的[=声明=]的[=图=]。
      </dd>
      <dt><dfn data-lt="predicates|derived predicates">派生谓词</dfn></dt>
      <dd>
        关于[=可验证凭证=]中另一个属性值的可验证的布尔断言。
        这些在零知识证明风格的
        [=可验证呈现=]中很有用，因为它们可以限制信息的披露。
        例如，如果一个[=可验证的凭证=]包含一个用于表示特定高度（以厘米为单位）的属性，
        一个派生谓词可能会引用[=可验证凭证=]中的高度属性，证明
        [=发行者=]确认高度值满足最低高度要求，
        而实际上并未披露具体的高度值。例如，[=主体=]的身高超过150厘米。
      </dd>
      <dt><dfn class="lint-ignore">数字签名</dfn></dt>
      <dd>
        用于证明数字消息真实性的数学方案。
      </dd>
      <dt><dfn data-lt="entities|entity's">实体</dfn></dt>
      <dd>
        可以在陈述中作为抽象或具体名词引用的任何事物。
        实体包括但不限于人、组织、实物、文档、抽象概念、虚构角色和任意文本。任何
        实体都可能在生态系统中扮演角色，如果它有能力这样做。请注意，有些实体从根本上无法采取行动，例如，字符串"abc"
        不能发行凭证。
      </dd>
      <dt><dfn data-lt="graphs">图</dfn></dt>
      <dd>
        一组声明，形成一个由[=主体=]
        及其与其他[=主体=]或数据的关系组成的信息网络。每个[=声明=]
        都是图的一部分；在[=命名图=]的情况下，这是明确的，或者
        在[=默认图=]的情况下是隐含的。
      </dd>
      <dt><dfn class="export" data-lt="holders|holder's|holders'">持有者</dfn></dt>
      <dd>
        通过持有一个或多个
        [=可验证凭证=]并从中生成[=可验证呈现=]来执行的角色。持有者通常是，但不总是，他们持有的
        [=可验证凭证=]的[=主体=]。持有者将其
        [=凭证=]存储在[=凭证仓库=]中。
      </dd>
      <dt><dfn class="lint-ignore" data-lt="identities|identity's">身份</dfn></dt>
      <dd>
        跨上下文跟踪[=实体=]的手段。数字
        身份使得跟踪和定制[=实体=]在数字上下文中的交互成为可能，通常使用标识符和属性。身份信息的意外分发或使用可能会损害隐私。收集和使用此类信息应遵循
        [=数据最小化=]原则。
      </dd>
      <dt><dfn data-lt="identity providers|idp">身份提供者</dfn></dt>
      <dd>
        身份提供者，有时缩写为<em>IdP</em>，是一个为[=持有者=]创建、维护和管理身份信息的系统，
        同时为联盟或分布式网络中的[=依赖方=]应用程序提供身份验证服务。在这种情况下，[=持有者=]始终是[=主体=]。即使[=可验证凭证=]是持票人
        [=凭证=]，也假设[=可验证凭证=]仍然随着
        [=主体=]，如果没有，它们是被攻击者窃取的。本规范不使用此术语，除非将本文档中的概念与其他规范进行比较或映射。本规范将
        [=身份提供者=]概念拆分为两个独立的概念：[=发行者=]
        和[=持有者=]。
      </dd>
      <dt><dfn class="export" data-lt="issuers|issuer's">发行者</dfn></dt>
      <dd>
        一个[=实体=]可以通过对一个或多个[=主体=]进行[=声明=]，
        从这些[=声明=]中创建一个[=可验证凭证=]，
        并将[=可验证凭证=]传输给
        [=持有者=]来执行的角色。
      </dd>
      <dt><dfn data-lt="named graphs">命名图</dfn></dt>
      <dd>
        与特定属性相关联的[=图=]，例如
        `verifiableCredential`。这些属性
        导致独立的[=图=]，其中包含在相应的JSON对象中定义的所有[=声明=]。
      </dd>
      <dt><dfn class="export" data-lt="presentation|presentations">呈现</dfn></dt>
      <dd>
        从一个或多个[=可验证凭证=]，由一个或多个[=发行者=]发行的数据派生出来，
        并与特定的[=验证者=]共享。
      </dd>
      <dt><dfn class="export" data-lt="credential repository|credential repositories|repositories">仓库</dfn></dt>
      <dd>
        一个程序，如存储库或个人[=可验证凭证=]
        钱包，存储并保护对[=持有者的=]
        [=可验证凭证=]的访问。
      </dd>
      <dt><dfn class="export">选择性披露</dfn></dt>
      <dd>
        [=持有者=]做出关于分享哪些信息的细粒度决策的能力。
      </dd>
      <dt><dfn class="export" data-lt="subjects|subject's">主体</dfn></dt>
      <dd>
        制作[=声明=]的对象。
      </dd>
      <dt><dfn class="lint-ignore">用户代理</dfn></dt>
      <dd>
        一个程序，如浏览器或其他Web客户端，它调解
        [=持有者=]、[=发行者=]和[=验证者=]之间的
        通信。
      </dd>
      <dt><dfn class="export" data-lt="claim validation|validate">验证</dfn></dt>
      <dd>
        确保特定[=发行者=]的[=声明=]满足[=验证者=]对特定用途的业务要求的保证。本规范定义了验证者如何验证[=可验证凭证=]和
        [=可验证呈现=]。<br />
        它还规定[=验证者=]在依赖它们之前应验证[=可验证
        凭证=]中的声明。然而，这种验证的方法各不相同，超出了本规范的范围。预计[=验证者=]将信任某些[=发行者=]对某些声明，并
        应用他们自己的规则来确定哪些声明在哪些[=凭证=]
        对他们的系统来说是适合使用的。
      </dd>
      <dt><dfn class="export" data-lt="vc|vcs">可验证凭证</dfn></dt>
      <dd>
        可验证凭证是一种防篡改的凭证，其作者身份可以通过密码验证。可验证凭证可以用来构建[=可验证呈现=]，这也可以通过密码验证。
      </dd>
      <dt><dfn class="export" data-lt="verifiable data registries">可验证数据注册表</dfn></dt>
      <dd>
        一个系统可能通过调解识别符、密钥和其他相关数据（如
        [=可验证凭证=]模式、撤销注册表、发行者公钥等）的创建和[=验证=]
        来执行的角色，这些可能是使用[=可验证凭证=]所必需的。某些配置可能需要可关联的识别符对于[=主体=]。某些注册表，如UUID和公钥的注册表，可能只是识别符的命名空间。
      </dd>
      <dt><dfn class="export" data-lt="vp|vps">可验证呈现</dfn></dt>
      <dd>
        可验证呈现是一种防篡改的呈现，以这样一种方式编码，以便在密码学验证过程之后可以信任数据的作者身份。某些类型的可验证呈现可能包含从[=可验证
        凭证=]（例如，零知识证明）合成的数据，但不包含原始[=可验证
        凭证=]。
      </dd>
      <dt><dfn class="export" data-lt="verify|verified|verifying|verifiable|verifiability">验证</dfn></dt>
      <dd>
        评估一个[=可验证凭证=]或[=可验证
        呈现=]是否是发行者或
        呈现者的真实和当前陈述。这包括检查：凭证（或
        呈现）是否符合规范；证明方法是否满足；以及（如果存在）状态检查是否成功。验证凭证并不意味着评估凭证中编码的[=声明=]的真实性。
      </dd>
      <dt><dfn class="export"
          data-lt="verifier|verifiers|verifier's|credential verifiers|credential verifier's">验证者</dfn></dt>
      <dd>
        一个[=实体=]通过接收一个或多个
        [=可验证凭证=]，可选择地在
        [=可验证呈现=]中进行处理来执行的角色。其他规范可能将这个概念称为<dfn data-lt="relying parties">依赖方</dfn>。
      </dd>
      <dt><dfn data-lt="verification material">验证材料</dfn></dt>
      <dd>
        可能是一个密码公钥或用于验证证据的任何其他数据。
      </dd>
      <dt><dfn data-lt="URL|URLs">URL</dfn></dt>
      <dd>
        统一资源定位符，如[[URL]]所定义。URL可以被解引用，
        从而导致一个资源，如文档。解引用或获取URL的规则由URL [=url/scheme=]定义。本规范不使用术语URI或IRI，因为这些术语被认为对Web开发者来说很混乱。
      </dd>
    </dl>
  </section>

  <section class="informative">
    <h2>核心数据模型</h2>

    <p>
      以下部分概述了核心数据模型概念，如 [=claims=]、[=credentials=]、[=presentations=]、[=verifiable credentials=] 和 [=verifiable
      presentations=]，这些概念构成了本规范的基础。
    </p>

    <p class="note" title="凭证和可验证凭证之间的区别">
      读者可能会注意到，本节中描述的一些概念，如 [=credential=] 和 [=presentation=]，在本规范中没有定义媒体类型。然而，[=verifiable credential=] 或 [=verifiable
      presentation=] 这些概念被定义为 [=conforming documents=]，并且具有相关联的媒体类型。这些概念之间的具体区别 &mdash; 即 [=credential=] 和
      [=presentation=] 与 [=verifiable credential=] 和 [=verifiable presentation=] 之间的区别 &mdash; 仅仅在于 "可验证"
      对象以加密可验证的方式进行保护，而其他对象则没有。有关详细信息，请参见<a href="#securing-mechanisms">安全机制部分</a>。
    </p>

    <section class="informative">
      <h3>声明</h3>

      <p>
        一个[=claim=]是关于一个[=subject=]的陈述。一个[=subject=]是可以对其进行[=claims=]的事物。[=Claims=]使用<strong><em>主体</em></strong>-<dfn
          data-lt="property|properties">
          属性</dfn>-<dfn class="lint-ignore">值</dfn>关系来表示。
      </p>

      <figure id="basic-structure">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/claim.svg" alt="主体具有一个属性，该属性具有一个值">
        <figcaption style="text-align: center;">
          声明的基本结构。
        </figcaption>
      </figure>

      <p>
        如上图<a href="#basic-structure"></a>所示，[=claims=]的数据模型非常强大，可以用来表示各种各样的陈述。例如，某人是否从某个特定大学毕业，可以如下图<a
          href="#basic-example"></a>所示表示。
      </p>

      <figure id="basic-example">
        <img style="margin: auto; display: block; width: 60%;" src="diagrams/claim-example.svg"
          alt="Pat具有一个alumniOf属性，其值为Example University">
        <figcaption style="text-align: center;">
          一个基本的声明，表示Pat是“Example University”的校友。
        </figcaption>
      </figure>

      <p>
        单个[=claims=]可以合并在一起，以表达关于[=subject=]的信息[=graph=]。下图<a
          href="#multiple-claims"></a>中的示例通过添加Pat认识Sam的[=claims=]以及Sam被雇佣为教授的[=claims=]来扩展之前的[=claim=]。
      </p>

      <figure id="multiple-claims">
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/claim-extended.svg"
          alt="扩展先前的图表，添加一个名为knows的属性，其值为Sam，Sam具有一个名为jobTitle的属性，其值为Professor">
        <figcaption style="text-align: center;">
          多个声明可以组合在一起，以表达信息图。
        </figcaption>
      </figure>

      <p>
        到目前为止，已经介绍了[=claim=]和信息[=graph=]的概念。为了能够信任[=claims=]，预计将向图中添加更多信息。
      </p>
    </section>

    <section class="informative">
      <h3>凭证</h3>

      <p>
        一个[=credential=]是由相同的[=entity=]做出的一个或多个[=claims=]的集合。[=Credentials=]还可能包括一个标识符和元数据，用于描述[=credential=]的属性，如[=issuer=]、有效日期和时间段、代表性图像、[=verification
        material=]、吊销机制等。元数据可能由[=issuer=]签名。一个[=verifiable credential=]是一个防篡改的[=claims=]和元数据的集合，可以加密地证明谁发行了它。
      </p>

      <figure id="basic-vc">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/vc.svg" alt="一个可验证的凭证包含凭证元数据、声明和证明">
        <figcaption style="text-align: center;">
          可验证凭证的基本组件。
        </figcaption>
      </figure>

      <p>
        [=verifiable credentials=]的示例包括数字员工身份证、数字出生证明和数字教育证书。
      </p>

      <p class="note">
        [=Credential=]标识符通常用于识别特定实例的[=credential=]。这些标识符也可以用于关联。希望最小化关联的[=holder=]建议使用一种选择性披露方案，该方案不会泄露[=credential=]标识符。
      </p>

      <p>
        <a href="#basic-vc"></a>上面显示了一个[=verifiable
        credential=]的基本组件，但抽象了关于如何将[=claims=]组织成信息[=graphs=]的细节，然后将其组织成[=verifiable credentials=]。
      </p>
      <p>
        <a href="#info-graph-vc"></a>下面显示了一个使用基于[[?VC-DATA-INTEGRITY]]的[=embedded proof=]的更完整的[=verifiable
        credential=]描述。它由至少两个信息[=graphs=]组成。
        这些信息[=graphs=]中的第一个，即[=verifiable credential graph=]（它是[=default
        graph=]），通过[=credential=]元数据和其他[=claims=]来表达[=verifiable credential=]本身。
        第二个信息[=graph=]，由`proof`属性引用，是[=verifiable credential=]的<dfn>proof graph</dfn>，是一个单独的[=named graph=]。
        [=proof graph=]表达了数字证明，这种情况下是数字签名。
      </p>

      <figure id="info-graph-vc">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vc-graph.svg" alt="Diagram with a collections of
claims for a 'verifiable credential graph' on top
connected via a proof property (or predicate) to a 'verifiable credential proof
graph' on the bottom. The claims for a verifiable credential include 'Credential
123' as a subject with 4 properties: 'type' of value ExampleAlumniCredential,
'issuer' of Example University, 'validFrom' of 2010-01-01T19:23:24Z, and
credentialSubject of Pat, who also has an alumniOf property with value of
Example University.  The verifiable credential proof graph has an object
'Signature 456' subject with 5 properties: 'type' of DataIntegrityProof,
'verificationMethod' of Example University Public Key 7, 'created' of
2017-06-18T21:19:10Z, a 'nonce' of 34dj239dsj328, and 'proofValue' of
'zBavE110…3JT2pq'. The verifiable credential graph is also annotated with the
parenthetical remark '(the default graph)', the verifiable credential proof
graph is annotated with the parenthetical remark '(a named graph)'.">
        <figcaption style="text-align: center;">
          使用基于[[[VC-DATA-INTEGRITY]]]的[=embedded proof=]的基本可验证凭证的相关信息图。
        </figcaption>
      </figure>

      <p>
        <a href="#info-graph-vc-jwt"></a>下面显示了与<a href="#info-graph-vc"></a>相同的可验证凭证，
        但使用基于[[?VC-JOSE-COSE]]的JOSE。负载包含一个信息图，即可验证凭证图，其中包含凭证元数据和其他声明。
      </p>

      <figure id="info-graph-vc-jwt">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vc-jwt.svg" alt="Diagram with, on the left, a box, labeled as
'SD-JWT (Decoded)', and with three textual labels stacked vertically,
namely 'Header', 'Payload', and 'Signature'. The 'Header' label is
connected, with an arrow, to a separate rectangle on the right hand
side containing six text fields: 'kid: aB8J-_Z', 'alg: ES384', and
'cty: vc+ld+json', iss: https://example.com, iat: 1704690029, and typ:
vc+ld+json+sd-jwt The 'Payload' label on the left side is connected,
with an arrow, to a separate rectangle, containing a single graph. The
rectangle has a label: 'verifiable credential graph (serialized in
JSON)' The claims in the graph include 'Credential 123' as a subject
with 4 properties: 'type' with value 'ExampleAlumniCredential',
'issuer' with value 'Example University', 'validFrom' with value
'2010-01-01T19:23:24Z', and 'credentialSubject' with value 'Pat', who
also has an 'alumniOf' property with value 'Example University'.
Finally, the 'Signature' label on the left side is connected, with an
arrow, to a separate rectangle, containing a single text field:
'DtEhU3ljbEg8L38VWAfUA...'.
          ">
        <figcaption style="text-align: center;">
          使用基于[[[VC-JOSE-COSE]]] [[?VC-JOSE-COSE]]的[=enveloping proof=]的基本可验证凭证相关的信息图。
        </figcaption>
      </figure>

      <p class="note">
        可以有一个[=credential=]，例如婚姻证书，其中包含关于不同[=subjects=]的多个[=claims=]，这些主题不需要相关。
      </p>
      <p class="note">
        可以有一个[=credential=]，其中不包含关于发行[=credential=]的[=entity=]的任何[=claims=]。例如，一个只包含关于特定狗的[=claims=]，但发给其所有者的[=credential=]。
      </p>
    </section>

    <section class="informative">
      <h3>演示</h3>

      <p>
        增强隐私是本规范的一个关键设计特性。因此，对于使用这项技术的[=实体=]来说，能够仅表达适用于特定情境的个人形象的部分非常重要。一个人形象的子集被称为[=可验证的演示=]。不同形象的例子包括一个人的专业形象、他们的在线游戏形象、他们的家庭形象或匿名形象。
      </p>

      <p>
        [=可验证的演示=]可以表达来自多个[=可验证的凭证=]的数据，并包含编码为JSON-LD的任意附加数据。它们由[=持有人=]用于向[=验证者=]展示[=声明=]。也可以直接展示[=可验证的凭证=]。
      </p>

      <p>
        [=演示=]中的数据通常与同一个[=主题=]有关，但可能是由多个[=发行者=]发布的。这些信息的汇总通常表达了一个人、组织或[=实体=]的某个方面。
      </p>

      <figure id="basic-vp">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/presentation.svg"
          alt="可验证的演示包含演示元数据、可验证的凭证和证明">
        <figcaption style="text-align: center;">
          可验证演示的基本组件。
        </figcaption>
      </figure>

      <p>
        <a href="#basic-vp"></a>上面显示了[=可验证的演示=]的组件，但抽象了关于如何将[=可验证的凭证=]组织成信息[=图=]的细节，然后将这些信息[=图=]组织成[=可验证的演示=]。
      </p>
      <p id="info-graph-vp-explanation">
        <a
          href="#info-graph-vp"></a>下面显示了一个使用基于[[?VC-DATA-INTEGRITY]]的[=嵌入式证明=]的[=可验证的演示=]的更完整描述。它由至少四个信息[=图=]组成。其中第一个信息[=图=]，即[=可验证的演示图=]（它是[=默认图=]），通过[=演示=]元数据表达[=可验证的演示=]本身。[=可验证的演示=]通过`verifiableCredential`属性引用一个[=可验证的凭证=]。这个[=凭证=]是一个包含[=凭证=]元数据和其他[=声明=]的独立[=可验证的凭证图=]。这个[=凭证=]通过`proof`属性引用一个[=可验证的凭证=]的[=证明图=]，表达了[=凭证=]的证明（通常是数字签名）。这个[=可验证的凭证图=]及其链接的[=证明图=]分别构成第二和第三个信息[=图=]，每个都是一个单独的[=命名图=]。[=演示=]还通过`proof`属性引用[=演示=]的[=证明图=]，这是第四个信息[=图=]（另一个[=命名图=]）。这个[=演示=]的[=证明图=]表示[=可验证的演示图=]、[=可验证的凭证图=]以及从[=可验证的凭证图=]链接的[=证明图=]的数字签名。
      </p>
      <p>
        为了创建一个[=可验证的演示=]，[=持有人=]需要将一个或多个[=可验证的凭证=]组合在一起，并在需要时添加其他相关信息。然后，[=持有人=]需要对整个[=可验证的演示=]进行签名，以确保接收方可以验证其来源和完整性。这样，[=验证者=]就可以确信这些[=声明=]是真实的，并且是由相应的[=发行者=]颁发的。
      </p>

      <p>
        为了验证一个[=可验证的演示=]，[=验证者=]需要执行以下步骤：
      </p>

      <ol>
        <li>检查[=可验证的演示=]的数字签名以确保其来源和完整性。</li>
        <li>检查每个包含在[=可验证的演示=]中的[=可验证的凭证=]的数字签名。</li>
        <li>确保每个[=可验证的凭证=]都是由可信的[=发行者=]颁发的。</li>
        <li>确保每个[=可验证的凭证=]都没有过期或被撤销。</li>
        <li>根据需要，确保[=可验证的演示=]和[=可验证的凭证=]满足特定的业务规则和策略。</li>
      </ol>

      <p>
        一旦[=验证者=]完成了这些步骤，他们就可以信任[=可验证的演示=]中的[=声明=]，并据此做出决策。例如，根据所提供的年龄证明，他们可以决定是否允许用户访问年龄受限的内容。
      </p>

      <p>
        请注意，[=可验证的演示=]和[=可验证的凭证=]的验证过程可能会涉及与多个[=发行者=]和其他参与者的交互，以检查证书状态、获取公钥等。为了保护用户隐私，这些交互应尽可能地减少，并遵循最小披露原则，即仅披露验证所需的最少信息。
      </p>

      <p>
        本规范描述了创建和验证[=可验证的演示=]和[=可验证的凭证=]的通用方法和原则。实际应用中可能会有多种实现方式和技术，以满足不同场景和需求。这些实现应遵循本规范的核心原则，以确保互操作性和安全性。
      </p>

      <figure id="info-graph-vp">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-graph.svg" alt="Diagram with a
'verifiable presentation graph' on top connected via a 'proof' to
a 'verifiable presentation proof graph on the bottom.  The verifiable
presentation graph has and object 'Presentation ABC' with 3 properties: 'type'
of value VerifiablePresentation, 'termsOfUse' of value 'Do Not Archive'. The
graph is annotated with the parenthetical remark '(the default graph)'. This
graph is connected, through 'verifiableCredential', to the part of the figure
which is identical to Figure 6, except that the verifiable credential graph is
annotated to be a named graph instead of a default graph.
The verifiable presentation proof graph has an object with 'Signature 8910'
with 5 properties: 'type' with value 'DataIntegrityProof'; 'verificationMethod' with value 'Example
Presenter Public Key 11'; 'created' with value '2018-01-15T12:43:56Z';
'nonce' with value 'd28348djsj3239'; and 'proofValue' with value
'zp2KaZ...8Fj3K='. This graph is annotated with the parenthetical remark '(a
named graph)'">
        <figcaption style="text-align: center;">
          与基本的[=可验证呈现=]相关联的信息[=图=]，该呈现使用基于[[[VC-DATA-INTEGRITY]]] [[?VC-DATA-INTEGRITY]]的[=嵌入式证明=]。
        </figcaption>
      </figure>

      <p>
        <a href="#info-graph-vp-jwt"></a> 下面显示的是与 <a href="#info-graph-vp"></a> 相同的 [=可验证呈现=]，但使用基于 [[?VC-JOSE-COSE]] 的
        [=封装证明=]。有效负载仅包含两个信息图：通过呈现元数据表达 [=可验证呈现=] 本身的 [=可验证呈现图=]；以及相应的 [=可验证凭证图=]，由 `verifiableCredential`
        属性引用。[=可验证凭证图=] 包含单个 <a href="#defn-EnvelopedVerifiableCredential">`EnvelopedVerifiableCredential`</a> 实例，通过
        `data:` URL [[RFC2397]] 引用，指向通过 <a href="#info-graph-vc-jwt"></a> 上显示的 [=封装证明=] 保护的可验证凭证。
      </p>

      <figure id="info-graph-vp-jwt">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-jwt.svg" alt="Diagram with, on the left, a box, labeled as
'JWT (Decoded)', and with three textual labels stacked vertically,
namely 'Header', 'Payload', and 'Signature'. The 'Header' label is
connected, with an arrow, to a separate rectangle on the right hand
side containing six text fields: 'kid: aB8J-_Z', 'alg: ES384', and
'cty: vc+ld+json', iss: https://example.com, iat: 1704690029, and typ:
vp+ld+json+sd-jwt The 'Payload' label of the left side is connected,
with an arrow, to a separate rectangle, consisting of two related
graphs (stacked vertically) connected by a an arrow labeled
'verifiableCredential'. The two graphs have each a label 'verifiable
presentation graph (serialized in JSON)' and 'verifiable credential
graph (serialized in JSON)', respectively. The top graph in the
rectangle has and object 'Presentation ABC' with 3 properties: 'type'
of value VerifiablePresentation, 'termsOfUse' of value 'Do Not
Archive'. The bottom graph includes
'data:application/vc+ld+json+sd-jwt;QzVjV...RMjU' as a subject with a
single property: 'type' of value `EnvelopedVerifiableCredential`.
Finally, the 'Signature' label on the left side is connected, with an
arrow, to a separate rectangle, containing a single text field:
'XaOOh4ljklxH7L99RTVSfOl...'.
          ">
        <figcaption style="text-align: center;">
          与基本[=可验证呈现=]相关的信息图，该呈现使用基于JOSE [[?VC-JOSE-COSE]]的[=封装证明=]。
          `data:` URL指向<a href="#info-graph-vc-jwt"></a>上显示的[=可验证凭证=]。
        </figcaption>
      </figure>


      <p class="note">
        可以有一个[=呈现=]，例如一组大学凭证，它们依赖于关于不同[=主题=]的多个[=凭证=]，这些主题通常是相关的，但不是必须的。
        这是通过使用`verifiableCredential`属性来引用多个[=可验证凭证=]来实现的。
        有关更多详细信息，请参见附录<a href="#additional-diagrams-for-verifiable-presentations"></a>。
      </p>

    </section>

    <section class="informative">
      <h3>具体生命周期示例</h3>

      <p>
        前面的章节使用图形描述介绍了[=claims=]、[=verifiable credentials=]和[=verifiable
        presentations=]的概念。本节提供了一个具体的简单但完整的生命周期示例，用本规范支持的一种具体语法表示数据模型。在
        <a href="#ecosystem-overview">可验证凭证生态系统</a>中，[=credentials=]和[=presentations=]的生命周期通常遵循以下路径：
      </p>

      <ol>
        <li>
          发行一个或多个[=verifiable credentials=]。
        </li>
        <li>
          将[=verifiable credentials=]存储在[=credential repository=]（如数字钱包）中。
        </li>
        <li>
          将[=verifiable credentials=]组合成一个[=verifiable presentation=]，供[=verifiers=]使用。
        </li>
        <li>
          [=verifier=]对[=verifiable presentation=]进行[=Verification=]。
        </li>
        <li>
          [=verifier=]对包含在[=verifiable presentation=]中的相关[=claims=]进行[=Validation=]。
        </li>
      </ol>

      <p>
        为了说明这个生命周期，我们将使用从大学兑换校友折扣的例子。在下面的例子中，Pat从一所大学获得了一份校友[=verifiable credential=]，并将这个[=verifiable
        credential=]存储在一个数字钱包中。
      </p>

      <pre class="example nohighlight" title="一个可验证凭证内容的简单示例">
{
  <span class='comment'>// 设置上下文，建立我们将使用的特殊术语
  // 如'issuer'和'alumniOf'。</span>
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class='comment'>// 指定凭证的标识符</span>
  "id": "http://university.example/credentials/1872",
  <span class='comment'>// 凭证类型，声明凭证中期望的数据</span>
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  <span class='comment'>// 发行凭证的实体</span>
  "issuer": "https://university.example/issuers/565049",
  <span class='comment'>// 凭证发行的时间</span>
  "validFrom": "2010-01-01T19:23:24Z",
  <span class='comment'>// 关于凭证主题的声明</span>
  "credentialSubject": {
    <span class='comment'>// 凭证唯一主题的标识符</span>
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    <span class='comment'>// 关于凭证唯一主题的断言</span>
    "alumniOf": {
      <span class='comment'>// 大学的标识符</span>
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      <span class='comment'>// 大学的名称</span>
      "name": "Example University"
    }
  }
}
        </pre>

      <p>
        然后，Pat尝试兑换校友折扣。[=verifier=]，一个票务销售系统，声明“Example
        University”的校友可以获得体育赛事季票的折扣。使用移动设备，Pat开始购买季票的过程。在这个过程中的一个步骤请求一个校友[=verifiable
        credential=]，这个请求被路由到Pat的数字钱包。数字钱包询问Pat是否愿意提供以前发行的[=verifiable credential=]。Pat选择了校友[=verifiable
        credential=]，然后将其组合成一个[=verifiable presentation=]。[=verifiable presentation=]被发送到[=verifier=]并进行[=verified=]。
      </p>
      <p>
        一旦被[=verified=]为真实和当前的，季票的卖家然后验证[=verifiable credential=]的[=issuer=]是否被认可为校友状态的声明——它是，因为它是由Example
        University发行的——并且今天的日期在由`validFrom`和`validUntil`属性定义的有效期内。由于期望[=holder=]是[=verifiable
        credential=]的[=subject=]，[=verifier=]也确认校友声明的`id`与[=verifiable presentation=]的创建者的`id`匹配。
      </p>
      <p>
        在[=verified=]了凭证和演示，并验证了相关的声明后，票务销售商安全地为Pat启用了校友折扣，确信Pat有合法的权利享受这个折扣。
      </p>
      <pre class="example nohighlight" title="一个可验证演示的简单示例">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": "VerifiablePresentation",
  <span class='comment'>// 在上一个示例中发行的可验证凭证</span>
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/1872",
    "type": ["VerifiableCredential", "ExampleAlumniCredential"],
    "issuer": "https://university.example/issuers/565049",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "alumniOf": {
        "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
        "name": "Example University"
      }
    }
  }]
}
        </pre>

      <p class="note">
        上面的例子是未加密的。对于有兴趣了解更多关于保护[=verifiable credentials=]的实现者，可以参见规范[[[VC-JOSE-COSE]]]
        [[VC-JOSE-COSE]]和[[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]]
        以及[[[VC-SPECS]]]
        [[VC-SPECS]]的"Proofs"部分。
      </p>
    </section>
  </section>

  <section class="normative">
    <h2>基本概念</h2>

    <p>
      本节介绍了规范的一些基本概念，为文档后面的<a href="#advanced-concepts"></a>部分做准备。
    </p>

    <section class="informative">
      <h3>入门</h3>

      <p>
        本规范旨在简化新类型的[=可验证凭证=]原型的设计。开发者可以复制下面的模板，并将其粘贴到常见的[=可验证凭证=]工具中，以开始发布、持有和验证原型凭证。
      </p>

      <p>
        预计开发者会将下面的`MyPrototypeCredential`更改为他们想要创建的凭证类型。由于[=可验证凭证=]涉及主题，因此`credentialSubject`对象中的每个属性值对表示凭证主题的特定属性。一旦开发者添加了若干这样的属性值组合，修改后的对象可以发送给[=可验证凭证=]发行者软件，为开发者创建一个[=可验证凭证=]。从原型设计的角度来看，这就是开发者需要做的所有事情。
      </p>

      <pre class="example nohighlight" title="创建原型可验证凭证的模板">
{
  "@context": ["https://www.w3.org/ns/credentials/v2"],
  "type": ["VerifiableCredential", "MyPrototypeCredential"],
  "credentialSubject": {
    "mySubjectProperty": "mySubjectValue"
  }
}
        </pre>

      <p>
        一旦开发者将他们的凭证原型设计到他们认为所有凭证属性都稳定的程度，建议他们为他们的应用程序生成词汇表和上下文文件，并将它们发布在稳定的URL上，以便其他开发者可以使用相同的词汇表和上下文实现互操作性。这个过程在第<a
          href="#extensibility"></a>节中有介绍。或者，开发者可以重用现有的词汇表和上下文文件，以适应他们的用例。他们可以浏览[[[VC-SPECS]]] [[VC-SPECS]]以获取可重用资源。
      </p>

    </section>
    <section>
      <h3>上下文</h3>

      <p>
        当两个软件系统需要交换数据时，它们需要使用双方都理解的术语。作为一个类比，考虑一下两个人如何交流。两个人必须使用相同的语言，他们使用的词语对彼此必须具有相同的含义。这可能被称为
        <em>对话的上下文</em>。
      </p>
      <p>
        [=可验证的凭证=]和[=可验证的展示=]有许多由[=URLs=]
        [[URL]]标识的属性和值。然而，这些[=URLs=]可能很长，对人类并不友好。在这种情况下，短格式的人类友好别名可能更有帮助。本规范使用`@context`
        [=属性=]将这种短格式别名映射到特定的[=可验证的凭证=]和[=可验证的展示=]所需的[=URLs=]。
      </p>
      <p class="note">
        在JSON-LD中，`@context` [=属性=]也可以用来传递其他细节，如数据类型信息，语言信息，转换规则等，这些超出了本规范的需要，但可能在未来或相关工作中有用。更多信息，请参见
        <a href="https://www.w3.org/TR/json-ld11/#the-context">第3.1节：上下文</a>
        的[[[JSON-LD11]]] [[JSON-LD11]]规范。
      </p>
      <p>
        [=可验证的凭证=]和[=可验证的展示=]必须包含一个`@context` [=属性=]。
      </p>

      <dl>
        <dt><dfn class="export">@context</dfn></dt>
        <dd>
          `@context` [=属性=]的值必须是一个有序集，其中第一项是一个[=URL=]，值为
          `https://www.w3.org/ns/credentials/v2`。作为参考，附录<a href="#base-context"></a>提供了基础上下文的副本。
          数组中的后续项必须由任何组合的[=URLs=]和/或对象组成，每个对象都可以作为
          <a data-cite="JSON-LD11#the-context">JSON-LD上下文</a>处理。
        </dd>
      </dl>
      <p class="note">
        本规范要求存在`@context` [=属性=]
        ，此属性由[[JSON-LD11]]定义。
      </p>
      <pre class="example nohighlight" title="使用@context属性的示例">
{
  <span class="highlight">"@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ]</span>,
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

      <p>
        上面的例子使用基础上下文[=URL=]
        (`https://www.w3.org/ns/credentials/v2`)来确定对话是关于一个[=可验证的凭证=]。第二个[=URL=]
        (`https://www.w3.org/ns/credentials/examples/v2`)确定对话是关于示例的。
      </p>

      <p class="note">
        本文档使用示例上下文[=URL=]
        (`https://www.w3.org/ns/credentials/examples/v2`)来演示示例。实现期望不使用此[=URL=]进行任何其他目的，如在试点或生产系统中使用。
      </p>

      <p>
        在`https://www.w3.org/ns/credentials/v2`上可用的数据是一个静态文档，永远不会更新，应该被下载和缓存。可验证凭证数据模型的相关人类可读词汇文档可在
        <a href="https://www.w3.org/2018/credentials/">https://www.w3.org/2018/credentials/</a>获得。
        这个概念在<a href="#extensibility"></a>章节中有进一步的扩展。
      </p>

    </section>

    <section>
      <h3>标识符</h3>

      <p>
        当对特定事物（如人、产品或组织）进行陈述时，使用该事物的全球唯一标识符可能会很有用。
        全球唯一标识符使其他人能够对同一事物进行陈述。本规范定义了可选的`id`
        [=属性=]用于此类标识符。`id` [=属性=]
        允许在[=可验证的凭证=]中对特定事物进行陈述，并由[=发行者=]在表达
        [=可验证的凭证=]中的对象或[=持有者=]在表达
        [=可验证的展示=]中的对象时设置。`id`值的示例
        包括UUIDs (`urn:uuid:0c07c1ce-57cb-41af-bef2-1b932b986873`)，HTTP URLs
        (`https://id.example/things#123`)和DIDs (`did:example:1234abcd`)。
      </p>

      <p>
        <em>如果</em> `id` [=属性=]存在：
      </p>

      <ul>
        <li>
          `id` [=属性=]必须表达一个标识符，其他人预期会在对该标识符标识的特定事物进行陈述时使用这个标识符。
        </li>
        <li>
          `id` [=属性=]不能有多个值。
        </li>
        <li>
          `id` [=属性=]的值必须是一个[=URL=]，该URL可能会被解引用。
        </li>
      </ul>

      <p class="note">
        开发者应记住，在需要匿名性的场景中，标识符可能会造成伤害。鼓励开发者在考虑此类场景时仔细阅读<a href="#identifier-based-correlation"></a>部分。
        在<a href="#privacy-considerations"></a>部分记录的其他类型的关联机制也会产生隐私问题。在隐私是重要考虑因素的地方，`id` [=属性=]
        可以省略。有些用例不需要，或明确要求省略，`id` [=属性=]。
      </p>

      <dl>
        <dt><dfn class="export">id</dfn></dt>
        <dd>
          `id` [=属性=]的值必须是单个[=URL=]。
          建议`id`中的[=URL=]是一个可以被解引用的URL，如果被解引用，将得到一个包含有关`id`的机器可读信息的文档。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="id属性的使用" data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class="highlight">"id": "http://university.example/credentials/3732"</span>,
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    <span class="highlight">"id": "did:example:ebfeb1f712ebc6f1c276e12ec21"</span>,
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        上述示例使用了两种类型的标识符。第一个标识符用于[=可验证的凭证=]，使用基于HTTP的URL。第二个
        标识符用于[=可验证的凭证=]的[=主题=]（即[=声明=]所涉及的事物），并使用一种[=去中心化标识符=]，也称为[=DID=]。
      </p>

      <p class="note">
        截至本文发布，[=DIDs=]是一种新型标识符，对于[=可验证的凭证=]的有效性并非必需。具体来说，
        [=可验证的凭证=]并不依赖[=DIDs=]，[=DIDs=]也并不依赖[=可验证的凭证=]。然而，预计许多
        [=可验证的凭证=]将使用[=DIDs=]，实现此规范的软件库可能需要解析[=DIDs=]。
        [=DID=]-基础的URL用于表达与[=主题=]、[=发行者=]、[=持有者=]、凭证状态列表、
        加密密钥以及与[=可验证的凭证=]相关的其他机器可读信息相关联的标识符。
      </p>
    </section>

    <section>
      <h3>类型</h3>

      <p>
        处理本文档中指定的对象类型的软件系统
        使用类型信息来确定提供的
        [=可验证凭证=]或[=可验证陈述=]是否适用
        于预期的用例。本规范为表达类型信息定义了一个`type`
        [=属性=]。这种类型信息
        可以在附录中描述的[=验证=]过程中使用
        <a href="#validation"></a>。
      </p>

      <p>
        [=可验证凭证=]和[=可验证陈述=]必须具有
        `type` [=属性=]。也就是说，任何没有`type` [=属性=]的
        [=凭证=]或
        [=陈述=]<em>不是[=可验证的=]</em>，因此既不是[=可验证凭证=]
        也不是[=可验证陈述=]。
      </p>

      <dl>
        <dt><dfn class="export" data-lt="type|types">type</dfn></dt>
        <dd>
          `type` [=属性=]的值必须是，或映射到（通过
          解释`@context`属性），一个或多个[=URLs=]。
          如果提供了多个[=URL=]，则[=URLs=]必须解释为
          无序集合。应使用语法便利功能来简化开发者
          使用。这些便利功能可能包括JSON-LD术语。建议
          `type`中的每个[=URL=]都是一个，如果取消引用，结果
          是一个包含关于
          `type`的机器可读信息的文档。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="使用type属性" data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  <span class="highlight">"type": ["VerifiableCredential", "ExampleDegreeCredential"]</span>,
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        关于本规范，下表列出了必须指定[=类型=]的对象。
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>对象</th>
            <th>类型</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              [=可验证凭证=]&nbsp;对象
            </td>
            <td>
              `VerifiableCredential`以及可选的更具体的
              [=可验证凭证=] [=类型=]。例如，<br>
              `"type": ["VerifiableCredential", "ExampleDegreeCredential"]`
            </td>
          </tr>

          <tr>
            <td>
              [=可验证陈述=]&nbsp;对象
            </td>
            <td>
              `VerifiablePresentation`以及可选的更具体的
              [=可验证陈述=] [=类型=]。例如，<br>
              `"type": ["VerifiablePresentation", "ExamplePresentation"]`
            </td>
          </tr>

          <tr>
            <td>
              <a href="#status">credentialStatus</a>&nbsp;对象
            </td>
            <td>
              有效的[=凭证=]状态[=类型=]。例如，<br>
              `"type": "BitstringStatusListEntry"`
            </td>
          </tr>

          <tr>
            <td>
              <a href="#terms-of-use">termsOfUse</a>&nbsp;对象
            </td>
            <td>
              有效的使用条款[=类型=]。例如，<br>
              `"type": "ExampleTermsPolicy"`
            </td>
          </tr>

          <tr>
            <td>
              <a href="#evidence">evidence</a>&nbsp;对象
            </td>
            <td>
              有效的证据[=类型=]。例如，<br>
              `"type": "ExampleEvidence"`
            </td>
          </tr>

        </tbody>
      </table>

      <p class="note">
        可验证凭证数据模型的[=类型=]系统与[[JSON-LD11]]的系统相同，详细信息在
        <a href="https://www.w3.org/TR/json-ld/#specifying-the-type">第3.5节:
          指定类型</a>和
        <a href="https://www.w3.org/TR/json-ld/#json-ld-grammar">第9节: JSON-LD
          语法</a>中有详细描述。在使用JSON-LD上下文（参见第
        <a href="#extensibility"></a>节）时，本规范将
        `@type`关键字别名为`type`，以使JSON-LD文档
        更易于理解。虽然应用开发者和文档作者不需要理解JSON-LD类型系统的具体细节，但希望支持互操作扩展性的本规范的实现者需要理解。
      </p>

      <p>
        所有[=凭证=]、[=陈述=]和封装对象应该
        指定，或与，更窄的[=类型=]（如
        `ExampleDegreeCredential`，例如）相关联，以便软件系统可以
        更容易地检测和处理这些额外的信息。
      </p>

      <p>
        在处理本规范中定义的封装对象时（例如，与`credentialSubject`对象或
        深层嵌套在其中的对象相关联），软件系统应使用
        在层次结构中更高的封装对象中指定的[=类型=]信息。具体来说，一个
        封装对象，如[=凭证=]，应传达关联对象[=类型=]，以便[=验证者=]可以快速确定基于封装对象[=类型=]的关联对象的内容。
      </p>

      <p>
        例如，一个具有`type`为
        `ExampleDegreeCredential`的[=凭证=]对象，向[=验证者=]发出信号，表示
        与`credentialSubject`属性关联的对象包含以下的
        标识符：
      </p>

      <ul>
        <li>
          在`id`属性中的[=主题=]。
        </li>
        <li>
          在`type`属性中的学位类型。
        </li>
        <li>
          在`name`属性中的学位标题。
        </li>
      </ul>

      <p>
        这使得实现者可以依赖与
        `type`属性关联的值进行[=验证=]。[=类型=]及其关联属性的期望应至少在人类可读的规范中记录，最好在另一个机器可读的表示中记录。
      </p>

      <p class="note">
        本规范中描述的数据模型中使用的类型系统允许
        以多种方式将类型与数据关联。实现者和作者被敦促阅读可验证凭证
        实施指南[[?VC-IMP-GUIDE]]中关于类型的部分。
      </p>

    </section>

    <section>
      <h3>名称和描述</h3>

      <p>
        在显示一个[=credential=]时，由[=issuer=]提供的文本可以为
        [=credential=]提供一个名称以及其目的的简短描述。`name` 和 `description` [=properties=]
        就是为了实现这些目的。
      </p>

      <dl>
        <dt><dfn class="export">name</dfn></dt>
        <dd>
          一个可选的属性，表示[=credential=]的名称。如果
          存在，`name` [=property=]的值必须是一个字符串或
          如<a href="#language-and-base-direction"></a>所述的语言值对象。理想情况下，一个
          [=credential=]的名称简洁、易于阅读，并能让个人
          快速区分他们可能持有的其他任何[=credentials=]。
        </dd>
        <dt><dfn class="export">description</dfn></dt>
        <dd>
          一个可选的属性，传达关于[=credential=]的具体细节。如果
          存在，`description` [=property=]的值必须是一个
          字符串或如<a href="#language-and-base-direction"></a>所述的语言值对象。理想情况下，一个
          [=credential=]的描述长度不超过几句话，传达足够的
          关于[=credential=]的信息，以提醒个人其内容
          而无需查看全部的[=claims=]。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of the name and description property"
        data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": "Example University",
    "description": "A public university focusing on teaching examples."
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": "Example University Degree",
  "description": "2015 Bachelor of Science and Arts Degree",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        名称和描述还支持以不同的语言表达内容。
        要表达带有语言和[=基本方向=]信息的字符串，
        可以使用包含`@value`、`@language`和`@direction`属性的对象，
        分别表示文本值、语言标签和基本方向。
        有关详细信息，请参见
        <a href="#language-and-base-direction"></a>。
      </p>

      <pre class="example nohighlight" title="Usage of the name and description property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": [{
      "@value": "Example University",
      "@language": "en"
    }, {
      "@value": "Université de Exemple",
      "@language": "fr"
    }, {
      "@value": "جامعة المثال",
      "@language": "ar",
      "@direction": "rtl"
    }],
    "description": [{
      "@value": "A public university focusing on teaching examples.",
      "@language": "en"
    }, {
      "@value": "Une université publique axée sur l'enseignement des exemples.",
      "@language": "fr"
    }, {
      "@value": "جامعة عامة تركز على أمثلة التدريس.",
      "@language": "ar",
      "@direction": "rtl"
    }]
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": [{
    "@value": "Example University Degree",
    "@language": "en"
  }, {
    "@value": "Exemple de Diplôme Universitaire",
    "@language": "fr"
  }, {
    "@value": "مثال الشهادة الجامعية",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "description": [{
    "@value": "2015 Bachelor of Science and Arts Degree",
    "@language": "en"
  }, {
    "@value": "2015 Baccalauréat Scientifique et Arts",
    "@language": "fr"
  }, {
    "@value": "2015 بكالوريوس العلوم والآداب",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": [{
        "@value": "Bachelor of Science and Arts Degree",
        "@language": "en"
      }, {
        "@value": "Baccalauréat Scientifique et Arts",
        "@language": "fr"
      }, {
        "@value": "بكالوريوس العلوم والآداب",
        "@language": "ar",
        "@direction": "rtl"
      }]
    }
  }
}
        </pre>
    </section>

    <section>
      <h3>凭证主体</h3>

      <p>
        一个可验证凭证包含关于一个或多个主体的声明。本规范定义了一个 `credentialSubject` 属性，用于表达关于一个或多个主体的声明。
      </p>

      <p>
        一个可验证凭证必须具有 `credentialSubject` 属性。
      </p>

      <dl>
        <dt><dfn class="export" id="defn-credentialSubject">credentialSubject</dfn></dt>
        <dd>
          `credentialSubject` 属性的值被定义为一组对象，其中每个对象必须是一个或多个声明的主体，这些声明必须被序列化在 `credentialSubject` 属性内部。
          每个对象也可以包含一个 `id` 来标识主体，如第 <a href="#identifiers"></a> 节所述。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of the credentialSubject property"
        data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  <span class="highlight">"credentialSubject"</span>: {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        可以在可验证凭证中表达与多个主体相关的信息。下面的示例指定了两个配偶作为主体。请注意，使用数组表示法将多个主体与 `credentialSubject` 属性关联起来。
      </p>

      <pre class="example nohighlight" title="Specifying multiple subjects in a verifiable credential">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "https://example.com/issuer/123",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": <span class="highlight">[{
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Jayden Doe",
    "spouse": "did:example:c276e12ec21ebfeb1f712ebc6f1"
  }, {
    "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
    "name": "Morgan Doe",
    "spouse": "did:example:ebfeb1f712ebc6f1c276e12ec21"
  }]</span>
}
        </pre>

    </section>

    <section>
      <h3>发行者</h3>

      <p>
        本规范定义了一个用于表示[=verifiable credential=]的[=issuer=]属性。
      </p>

      <p>
        一个[=verifiable credential=]必须具有一个`issuer`[=property=]。
      </p>

      <dl>
        <dt><var id="defn-issuer">issuer</var></dt>
        <dd>
          `issuer`[=property=]的值必须是一个[=URL=]，或者是一个包含`id`[=property=]的对象，其值为[=URL=]；在任何情况下，发行者都选择这个[=URL=]以全球无歧义的方式识别自己。建议该[=URL=]为一个可解引用的URL，解引用后的结果是一个关于[=issuer=]的控制器文档，如[[VC-DATA-INTEGRITY]]或[[VC-JOSE-COSE]]中定义的，可用于[=verify=]在[=credential=]中表达的信息。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of issuer property"
        data-vc-vm="https://university.example/issuers/14#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": "https://university.example/issuers/14"</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        还可以通过将一个对象与发行者属性关联起来来表达有关发行者的其他信息：
      </p>

      <pre class="example nohighlight vc" title="Usage of issuer expanded property"
        data-vc-vm="did:example:76e12ec712ebc6f1c221ebfeb1f#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": {
    "id": "did:example:76e12ec712ebc6f1c221ebfeb1f",
    "name": "Example University"
  }</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p class="note">
        `issuer` [=property=] 的值也可以是一个 JWK（例如，`"https://example.com/keys/foo.jwk"`）或者一个
        [=DID=]（例如，`"did:example:abfe13f712120431c276e12ecab"`）。
      </p>

    </section>

    <section>
      <h3>有效期</h3>

      <p>
        本规范定义了`validFrom` [=property=]，以帮助发行者表达[=credential=]生效的日期和时间，以及`validUntil`
        [=property=]，用于表达[=credential=]失效的日期和时间。
      </p>

      <p>
        在比较日期和时间时，计算是“时间性”的，这意味着字符串值被转换为存在于时间轴上的一个点的“时间值”。然后通过检查要比较的日期和时间相对于时间轴上的特定点的位置来进行时间比较。
      </p>

      <dl>
        <dt><var id="defn-validFrom">validFrom</var></dt>
        <dd>
          如果存在，`validFrom` [=property=]的值必须是一个
          [<a data-cite="XMLSCHEMA11-2#dateTime">XMLSCHEMA11-2</a>]
          `dateTimeStamp`字符串值，表示[=credential=]生效的日期和时间，可以是未来或过去的日期和时间。请注意，此值表示与`credentialSubject`
          [=property=]关联的信息生效的最早时间点。如果还存在`validUntil`值，则
          `validFrom`值必须表示与`validUntil`值表示的日期时间相同或更早的日期时间。
        </dd>
        <dt><var id="defn-validUntil">validUntil</var></dt>
        <dd>
          如果存在，`validUntil` [=property=]的值必须是一个
          [<a data-cite="XMLSCHEMA11-2#dateTime">XMLSCHEMA11-2</a>]
          `dateTimeStamp`字符串值，表示[=credential=]失效的日期和时间，可以是过去或未来的日期和时间。请注意，此值表示与`credentialSubject`
          [=property=]关联的信息有效的最晚时间点。如果还存在`validFrom`值，则`validUntil`
          值必须表示与`validFrom`值表示的日期时间相同或更晚的日期时间。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of validFrom and validUntil property"
        data-vc-vm="https://university.example/issuers/14#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  <span class="highlight">"validFrom": "2010-01-01T19:23:24Z"</span>,
  <span class="highlight">"validUntil": "2020-01-01T19:23:24Z"</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p class="note">
        如果`validFrom`和`validUntil`不存在，则认为[=可验证凭证=]的有效期无限。在这种情况下，假定[=可验证凭证=]从创建时开始有效。
      </p>

      <h4>表示时间</h4>

      <p>
        实现者应该了解，表示和处理时间值并非像看起来那么简单，并且在世界不同地区有各种各样的特殊性。例如：
      </p>

      <ul>
        <li>
          除了公历日历系统外，其他日历系统也被各个地区积极使用。
        </li>
        <li>
          在处理夏令时/夏时制时，重要的是要了解：1) 并非所有地区都遵循夏令时，2) 开始和结束的日期或时间并不一定相同，3) 调整的幅度或方向并不总是与其他类似地区相匹配。
        </li>
        <li>
          跳秒可能不会在所有软件系统中考虑，尤其是对于在引入跳秒之前的日期和时间。跳秒会影响那些依赖于从纪元开始的精确毫秒偏移的高度敏感系统。然而，请注意，对于大多数应用程序，唯一受影响的时间点是跳秒本身的那一秒。也就是说，最近一次跳秒之后的时刻总是可以表示为下一天的第一个时刻（例如，`2023-01-01T00:00:00Z`），无论所讨论的系统是否理解跳秒。
        </li>
      </ul>

      <p>
        这些只是一些例子，说明实际的一天时间，如墙上的时钟所示，在一个地区可能存在，而在另一个地区可能不存在。因此，实现者应该使用更通用的时间值，如锚定在`Z`时区的值，而不是受夏令时/夏时制影响的值。
      </p>

      <p>
        本规范试图增加通用认可的日期和时间组合的数量，并通过使用首次由[<a data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a>]规范建立的
        `dateTimeStamp`构造来减少时间值误解的可能性。为了减少不同时区之间的误解，所有在[=符合规范的文档=]中表示的时间值都应该以`dateTimeStamp`
        格式指定，要么是世界协调时间（UTC），用`Z`表示，要么是相对于UTC的时区偏移。没有偏移的错误序列化的时间值必须解释为UTC。相对于UTC的有效时区偏移的示例包括`Z`、`+01:00`、`-08:00`和
        `+14:00`。请参阅本节末尾的正则表达式，以获取所有可接受值的正式定义。
      </p>

      <p>
        时区定义有时会被其管理机构更改。在更换或发布新的[=可验证证书=]时，实现者应确保当地时区规则的更改不会导致意外的有效期间隙。例如，考虑时区`America/Los_Angeles`，其原始偏移为UTC-8，并在2024年投票决定停止遵循夏令时。一个给定的[=可验证证书=]，其`validUtil`
        值为`2024-07-12T12:00:00-07:00`，可能会被重新发布，使其`validFrom`值为`2024-07-12T12:00:00-08:00`，这将导致一个小时的间隙，在这个间隙内，[=可验证证书=]将无效。
      </p>

      <p>
        希望检查`dateTimeStamp`值有效性的实现者可以使用下面提供的正则表达式，该正则表达式是从[<a
          data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a>]规范中复制过来的，以方便使用。为避免疑虑，[[XMLSCHEMA11-2]]中的正则表达式是规范性定义。实现者应注意，并非所有通过下面正则表达式的`dateTimeStamp`值都是有效的时间点。例如，下面的正则表达式允许每个月有31天，这包括闰年和闰秒，以及那些不存在的地方的日子。话虽如此，现代系统库生成的`dateTimeStamp`值在生成有效的`dateTimeStamp`值时通常是无误的。下面显示的正则表达式（减去为了可读性而包含的空白），在处理现代系统上库生成的日期和时间时通常是足够的。
      </p>

      <pre class="example nohighlight"
        title="Regular expression to detect a valid XML Schema 1.1: Part 2 dateTimeStamp">
-?([1-9][0-9]{3,}|0[0-9]{3})
-(0[1-9]|1[0-2])
-(0[1-9]|[12][0-9]|3[01])
T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))
(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))
        </pre>

    </section>

    <section>
      <h3>安全机制</h3>

      <p>
        本规范认可两类安全机制：使用封装证明的机制和使用嵌入式证明的机制。
      </p>

      <p>
        一个<dfn class="export">封装证明</dfn>是包裹了此数据模型序列化的证明。[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]中定义了一种建议的封装证明机制。
      </p>

      <p>
        一个<dfn class="export">嵌入式证明</dfn>是一种证明包含在数据模型序列化中的机制。[[[VC-DATA-INTEGRITY]]]
        [[VC-DATA-INTEGRITY]]中定义了一种建议的嵌入式证明机制。
      </p>

      <p>
        这两类安全机制并非互斥。根据第<a href="#securing-mechanism-specifications"></a>节的规则，还可以定义其他安全机制规范。
      </p>

      <pre class="example nohighlight" title="A verifiable credential utilizing an embedded proof">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.gov/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-rdfc-2022",
    "created": "2021-11-13T18:19:39Z",
    "verificationMethod": "https://university.example/issuers/14#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z58DAdFfa9SkqZMVPxAQp...jQCrfFPP2oumHKtz"
  }</span>
}
        </pre>

      <pre class="example nohighlight" title="A verifiable credential that uses an enveloping proof in SD-JWT format">
eyJhbGciOiJFUzM4NCIsImtpZCI6IkdOV2FBTDJQVlVVMkpJVDg5bTZxMGM3U3ZjNDBTLWJ2UjFTT0
Q3REZCb1UiLCJ0eXAiOiJ2YytsZCtqc29uK3NkLWp3dCIsImN0eSI6InZjK2xkK2pzb24ifQ
.
eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvbnMvY3JlZGVudGlhbHMvdjIiLCJodHRwcz
ovL3d3dy53My5vcmcvbnMvY3JlZGVudGlhbHMvZXhhbXBsZXMvdjIiXSwiaXNzdWVyIjoiaHR0cHM6
Ly91bml2ZXJzaXR5LmV4YW1wbGUvaXNzdWVycy81NjUwNDkiLCJ2YWxpZEZyb20iOiIyMDEwLTAxLT
AxVDE5OjIzOjI0WiIsImNyZWRlbnRpYWxTY2hlbWEiOnsiX3NkIjpbIlNFOHp4bmduZTNNbWEwLUNm
S2dlYW1rNUVqU1NfOXRaNlN5NDdBdTdxRWMiLCJjT3lySEVrSlZwdEtSdURtNkNZVTREajJvRkExd0
JQRjFHcTJnWEo1NXpzIl19LCJjcmVkZW50aWFsU3ViamVjdCI6eyJkZWdyZWUiOnsibmFtZSI6IkJh
Y2hlbG9yIG9mIFNjaWVuY2UgYW5kIEFydHMiLCJfc2QiOlsibVNfSVBMa0JHcTIxbVA3Z0VRaHhOck
E0ZXNMc1ZKQ1E5QUpZNDFLLVRQSSJdfSwiX3NkIjpbIlhTSG9iU05Md01PVl9QNkhQMHNvMnZ1clNy
VXZ3UURYREJHQWtyTXk3TjgiXX0sIl9zZCI6WyJQNE5qWHFXa2JOc1NfRzdvdmlLdm1NOG0yckhDTm
5XVVV2SXZBbW9jb2RZIiwieFNvSHBKUXlCNGV1dmg4SkFJdDFCd1pjNFVEOHY5S3ZOTmVLMk9OSjFC
QSJdLCJfc2RfYWxnIjoic2hhLTI1NiIsImlzcyI6Imh0dHBzOi8vdW5pdmVyc2l0eS5leGFtcGxlL2
lzc3VlcnMvNTY1MDQ5IiwiaWF0IjoxNzAzNjI1OTAxLCJleHAiOjE3MzUyNDgzMDEsImNuZiI6eyJq
d2siOnsia3R5IjoiRUMiLCJjcnYiOiJQLTM4NCIsImFsZyI6IkVTMzg0IiwieCI6Inl1Zlo1SFUzcU
NfOTRMbkI3Zklzd0hmT0swQlJra0Z5bzVhd1QyX21ld0tJWUpLMVNfR0QySVB3UjRYUTZpdFEiLCJ5
IjoiRmEtV2pOd2NLQ1RWWHVDU2tCY3RkdHJOYzh6bXdBTTZWOWxudmxxd1QyQnRlQ0ZHNmR6ZDJoMF
VjeXluTDg0dCJ9fX0
.
M7BFJB9LEV_xEylSJpP00fd_4WjrOlXshh0dUv3QgOzw2MEGIfSfi9PoCkHJH7TI0InsqkD6XZVz38
MpeDKekgBW-RoDdJmxnifYOEJhKpJ5EN9PvA007UPi9QCaiEzX
~
WyJFX3F2V09NWVQ1Z3JNTkprOHNXN3BBIiwgImlkIiwgImh0dHA6Ly91bml2ZXJzaXR5LmV4YW1wbG
UvY3JlZGVudGlhbHMvMTg3MiJd
~
WyJTSEc4WnpfRDVRbFMwU0ZrZFUzNXlRIiwgInR5cGUiLCBbIlZlcmlmaWFibGVDcmVkZW50aWFsIi
wgIkV4YW1wbGVBbHVtbmlDcmVkZW50aWFsIl1d
~
WyJqZzJLRno5bTFVaGFiUGtIaHV4cXRRIiwgImlkIiwgImh0dHBzOi8vZXhhbXBsZS5vcmcvZXhhbX
BsZXMvZGVncmVlLmpzb24iXQ
~
WyItQmhzaE10UnlNNUVFbGt4WGVXVm5nIiwgInR5cGUiLCAiSnNvblNjaGVtYSJd~WyJ0SEFxMEUwN
nY2ckRuUlNtSjlSUWRBIiwgImlkIiwgImRpZDpleGFtcGxlOjEyMyJd
~
WyJ1Ynd6bi1kS19tMzRSMGI0SG84QTBBIiwgInR5cGUiLCAiQmFjaGVsb3JEZWdyZWUiXQ
        </pre>

    </section>

    <section>
      <h3>状态</h3>

      <p>
        本规范为[=verifiable credential=]的状态信息（如是否被暂停或撤销）的发现定义了`credentialStatus` [=property=]。
      </p>

      <p>
        下面为与<strong id="defn-credentialStatus">credentialStatus</strong> [=property=]关联的对象值定义了以下属性：
      </p>

      <dl>
        <dt>id</dt>
        <dd>
          `id` [=property=]是可选的。它可以用于为凭证状态对象提供唯一标识符。如果存在，必须遵循第<a href="#identifiers"></a>节的规范性指南。
        </dd>
        <dt>type</dt>
        <dd>
          `type` [=property=]是必需的。它用于表示对象所表达的状态信息的类型。必须遵循第<a href="#types"></a>节的相关规范性指南。
        </dd>
      </dl>

      <p>
        [=credential=]状态信息的确切内容由特定的`credentialStatus`
        [=type=]定义决定，具体取决于诸如实现简单性和是否增强隐私等因素。预期该值将提供足够的信息来确定[=credential=]的当前状态，并且可以从URL检索机器可读信息。例如，对象可以包含指向外部文档的链接，该文档注明[=credential=]是否被暂停或撤销。
      </p>

      <pre class="example nohighlight" title="Usage of the status property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://w3id.org/vc/status-list/2021/v1"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialStatus": {
    "id": "https://university.example/credentials/status/3#94567",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "94567",
    "statusListCredential": "https://university.example/credentials/status/3"
  }</span>
}
        </pre>

      <p>
        定义状态方案的数据模型、格式和协议超出了本规范的范围。存在一个可验证的凭证规范目录
        [[?VC-SPECS]]，其中包含了实施者想要实施[=可验证的凭证=]
        状态检查的可用状态方案。
      </p>

      <p>
        创建状态方案的规范作者提供了以下指南：
      </p>

      <ul>
        <li>
          状态方案绝对不能以使得能够追踪个人的方式实施，例如，当一个[=验证者=]对特定的[=持有人=]
          或[=主题=]感兴趣时，[=发行者=]被通知（直接或间接）。不可接受的方法包括"电话回家"，即
          每次使用凭证都会联系凭证的[=发行者=]，以检查特定个人的状态，或者"伪名减少"，即
          每次使用凭证都会导致从[=发行者=]那里请求信息，这些信息可以被[=发行者=]用来推断
          [=验证者=]对特定个人的兴趣。
        </li>
      </ul>

    </section>

    <section>
      <h3>展示</h3>

      <p>
        [=可验证展示=] 可用于汇总来自多个 [=可验证凭证=] 的信息。
      </p>
      <p>
        [=可验证展示=] 应该非常短暂，并绑定到由 [=验证者=] 提供的挑战。实现这一点的细节取决于安全机制、传输协议和 [=验证者=] 策略。除非特定的安全机制或嵌入协议定义了其他要求，否则 [=验证者=] 通常无法假定
        [=可验证展示=] 与所提供的 [=可验证凭证=] 之间存在任何关联。
      </p>

      <p>
        [=可验证展示=] 的 [=默认图=] 也被称为 <dfn>可验证展示图</dfn>。
      </p>

      <p>
        下面为 [=可验证展示=] 定义了以下属性：
      </p>

      <dl>
        <dt>|id|</dt>
        <dd>
          `id` [=属性=] 是可选的。它可以用于为 [=可验证展示=] 提供唯一标识符。如果存在，必须遵循第 <a href="#identifiers"></a> 节的规范性指南。
        </dd>
        <dt>|type|</dt>
        <dd>
          `type` [=属性=] 必须存在。它用于表示 [=可验证展示=] 的类型。此属性的一个值必须是 `VerifiablePresentation`，但可以包含其他类型。必须遵循第 <a
            href="#types"></a> 节的相关规范性指南。
        </dd>
        <dt><var id="defn-verifiableCredential">verifiableCredential</var></dt>
        <dd>
          `verifiableCredential` [=属性=] 可以存在。该值必须是一个或多个 [=可验证凭证=] 和/或
          <a href="#enveloped-verifiable-credentials">封装的可验证凭证</a>
          对象（明确地说，值不能是非对象值，如数字、字符串或URL）。这些类型的对象称为
          <a href="#verifiable-credential-graphs">可验证凭证图</a>，并且必须使用
          <a href="#securing-mechanisms">安全机制</a>来表达已加密的信息。
          请参阅第 <a href="#verifiable-credential-graphs"></a> 节以获取更多详细信息。
        </dd>
        <dt><var id="defn-holder">holder</var></dt>
        <dd>
          [=可验证展示=] 可以包含一个 `holder`
          [=属性=]。如果存在，其值必须是一个 [=URL=] 或包含 `id` [=属性=] 的对象。建议 `holder` 中的 [=URL=] 或其 `id` 是一个可以解引用的 URL，解引用后会得到一个包含关于
          [=持有者=] 的机器可读信息的文档，该信息可用于 [=验证=] 在 [=可验证展示=] 中表达的信息。
          如果 `holder` [=属性=] 不存在，则预期关于 [=持有者=] 的信息将通过安全机制获得，或者与 [=可验证展示=] 的 [=验证=] 无关。
        </dd>
      </dl>

      <p>
        下面的示例显示了一个 [=可验证展示=]：
      </p>

      <pre class="example nohighlight" title="Basic structure of a presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5",
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{ <span class="comment">...</span> }]
}
        </pre>

      <p>
        上述的 `verifiableCredential` 属性的内容是本规范所描述的可验证凭证图。
      </p>

      <section>
        <h4>封装的可验证凭证</h4>

        <p>
          一个[=可验证的展示=]可以包含一个或多个使用安全机制保护的
          [=可验证的凭证=]，这种安全机制会"封装"载荷，例如[[[?VC-JOSE-COSE]]] [[?VC-JOSE-COSE]]。
          这可以通过将`verifiableCredential`属性与一个`type`为`EnvelopedVerifiableCredential`的对象关联来实现。
        </p>

        <dl>
          <dt id="defn-EnvelopedVerifiableCredential">封装的可验证凭证</dt>
          <dd>
            用于将包含封装的[=可验证凭证=]的对象与[=可验证的展示=]中的`verifiableCredential`属性关联。
            对象的`@context`属性必须存在并包含一个上下文，
            例如<a href="#base-context">此规范的基础上下文</a>，
            至少定义了`id`、`type`和`EnvelopedVerifiableCredential`
            这些术语，这些术语由此规范提供的基础上下文定义。对象的`id`
            值必须是一个`data:` URL [[RFC2397]]，它用
            <a href="#dfn-enveloping-proof">封装</a>的安全方案表达了一个安全的
            [=可验证凭证=]，例如[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]。对象的`type`值必须是
            `EnvelopedVerifiableCredential`。
          </dd>
        </dl>

        <p>
          下面的例子展示了一个包含封装的[=可验证凭证=]的[=可验证的展示=]：
        </p>

        <pre class="example nohighlight" title="Basic structure of a presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "id": "data:application/vc+ld+json+sd-jwt;QzVjV...RMjU",
    "type": "EnvelopedVerifiableCredential"
  }]</span>
}
        </pre>

      </section>

      <section>
        <h4>使用派生凭证的演示</h4>

        <p>
          一些零知识密码学方案可能使[=持有人=]能够
          间接证明他们持有来自[=可验证凭证=]的[=声明=]
          而无需揭示该[=可验证凭证=]中的所有声明。在这些
          方案中，[=可验证凭证=]可用于派生可呈现的
          数据，这些数据经过加密断言，使得[=验证者=]可以信任
          该值（如果他们信任[=颁发者=]）。
        </p>
        <p>
          一些选择性披露方案可以共享从[=可验证凭证=]派生的[=声明=]子集。
        </p>

        <p class="note">
          有关包含派生数据而非直接嵌入[=可验证凭证=]的ZKP风格[=可验证演示=]的示例，请参见第<a href="#zero-knowledge-proofs"></a>节。
        </p>

        <figure>
          <img style="margin: auto; display: block; width: 50%;" src="diagrams/claim-example-2.svg" alt="Pat拥有一个
                 overAge属性，其值为21">
          <figcaption style="text-align: center;">
            表示Pat年龄超过21岁的基本声明。
          </figcaption>
        </figure>
      </section>
      <section>
        <h4>包含持有人声明的展示</h4>
        <p>
          [=持有人=]可以在[=可验证的展示=]中使用`verifiableCredential`
          [=属性=]，包含来自任何[=发行人=]的[=可验证的凭证=]，包括他们自己。当[=可验证凭证=]的[=发行人=]是[=持有人=]时，该[=可验证凭证=]中的[=声明=]被认为是<em>自我声明</em>。这些自我声明的声明可以通过保护包含它们的[=可验证展示=]的相同机制或任何适用于其他[=可验证凭证=]的机制来保护。
        </p>
        <p>
          这些自我声明的[=声明=]的<a
            href="#dfn-subjects">主题</a>不受限制，因此这些[=声明=]可以包括关于[=持有人=]、其他包含的[=可验证凭证=]之一，甚至包含自我声明的[=可验证凭证=]的[=可验证展示=]的声明。在每种情况下，`id`
          [=属性=]用于在声明关于它的对象中识别特定的[=主题=]，就像在不是自我声明的[=可验证凭证=]中所做的那样。
        </p>
        <p>
          包含仅使用与[=可验证展示=]相同的机制来保护的自我声明的[=可验证凭证=]的[=可验证展示=]必须包含`holder` [=属性=]。
        </p>
        <p>
          为[=可验证凭证=]定义的所有规范性要求都适用于自我声明的[=可验证凭证=]。
        </p>
        <p>
          当使用与[=可验证展示=]相同的机制来保护自我声明的[=可验证凭证=]时，[=可验证凭证=]的`issuer` [=属性=]的值必须与[=可验证展示=]的`holder` [=属性=]相同。
        </p>
        <p>
          下面的示例显示了一个[=可验证展示=]，其中嵌入了使用与[=可验证展示=]相同的机制来保护的自我声明的[=可验证凭证=]。
        </p>

        <pre class="example nohighlight"
          title="A verifiable presentation, secured with an embedded Data Integrity proof, with a self-asserted verifiable credential">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleFoodPreferenceCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      "favoriteCheese": "Gouda"
    },
    { <span class="comment">...</span> }
  }],
  "proof": [{ <span class="comment">...</span> }]
}
          </pre>
        <p>
          下面的示例显示了一个嵌入了自我声明的可验证凭证的可验证展示，该可验证凭证包含关于可验证展示的声明。它使用与可验证展示相同的机制进行保护。
        </p>

        <pre class="example nohighlight"
          title="A verifiable presentation, secured with an embedded Data Integrity proof, with a self-asserted verifiable credential about the verifiable presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleAssertCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
      "assertion": "This VP is submitted by the subject as evidence of a legal right to drive"
    },
    "proof": { <span class="comment">...</span> }
  }],
  "proof": { <span class="comment">...</span> }
}
          </pre>
      </section>
    </section>

    <section>
      <h3>数据模式</h3>

      <p>
        当对给定的数据集合强制执行特定结构时，数据模式很有用。本规范考虑的数据模式至少有两种：
      </p>

      <ul>
        <li>
          数据验证模式，用于确定[=凭证=]或[=可验证凭证=]的结构和内容符合已发布的模式。
        </li>
        <li>
          数据编码模式，用于将[=可验证凭证=]的内容映射到另一种表示格式，例如在零知识证明中使用的格式。
        </li>
      </ul>

      <p>
        重要的是要理解，数据模式与`@context`属性的目的不同，后者既不强制数据结构或数据语法，也不支持定义到替代表示格式的任意编码。
      </p>
      <p>
        本规范为表达数据模式定义了以下[=属性=]，可以由[=发行者=]包含在其发行的[=可验证凭证=]中：
      </p>

      <dl>
        <dt><var id="defn-credentialSchema">credentialSchema</var></dt>
        <dd>
          <p>
            `credentialSchema`
            [=属性=]的值必须是一个或多个数据模式，这些模式为[=验证者=]提供了足够的信息，以确定提供的数据是否符合提供的模式。每个`credentialSchema`必须指定其`type`（例如，`JsonSchema`），以及一个必须是标识模式文件的[=URL=]的`id`
            [=属性=]。每个数据模式的具体内容由特定类型定义决定。
          </p>
          <p>
            如果存在多个模式，则根据每个关联的`credentialSchema` `type`属性所概述的处理规则确定有效性。
          </p>
        </dd>
      </dl>

      <p class="note">
        `credentialSchema`
        [=属性=]提供了注释类型定义或将其锁定到词汇表特定版本的机会。[=可验证凭证=]的作者可以使用`credentialSchema`包含其词汇表的静态版本，该版本被锁定到某种内容完整性保护机制。`credentialSchema`
        [=属性=]还使得可以对[=凭证=]进行语法检查，并使用如JSON Schema [[?VC-JSON-SCHEMA]] 验证等[=验证=]机制。
      </p>

      <pre class="example nohighlight" title="Usage of the credentialSchema property to perform JSON schema validation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential", "ExamplePersonCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    },
    "alumniOf": {
      "name": "Example University"
    }
  },
  <span class="highlight">"credentialSchema": [{
    "id": "https://example.org/examples/degree.json",
    "type": "JsonSchema"
  },
  {
    "id": "https://example.org/examples/alumni.json",
    "type": "JsonSchema"
  }]</span>
}
        </pre>

      <p>
        在上面的示例中，发行者指定了一个`credentialSchema`，它指向一个[[?VC-JSON-SCHEMA]]文件，可以被验证者用来确定可验证凭证是否格式正确。
      </p>

      <p class="note">
        有关与JSON Schema [[?VC-JSON-SCHEMA]]或其他可选模式验证机制的链接信息，请参阅可验证凭证实施指南[[VC-IMP-GUIDE]]文档。
      </p>

      <p>
        数据模式还可以用于指定到其他格式的映射，例如用于执行零知识证明的格式。有关使用`credentialSchema` [=属性=]与零知识证明的更多信息，请参见第<a
          href="#zero-knowledge-proofs"></a>节。
      </p>

      <pre class="example nohighlight"
        title="Usage of the credentialSchema property to perform zero-knowledge validation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialSchema": {
    "id": "https://example.org/examples/degree",
    "type": "ZkpExampleSchema2018"
  }</span>
}
        </pre>

      <p>
        在上面的示例中，发行者指定了一个`credentialSchema`，它指向一种将输入数据转换为格式的方法，然后可以由验证者使用该格式确定可验证凭证所提供的证明是否格式正确。
      </p>


    </section>

  </section>

  <section>
    <h2>高级概念</h2>

    <p>
      在第<a href="#basic-concepts"></a>节介绍的基本概念基础上，本节探讨了关于可验证凭证的更复杂的主题。
    </p>

    <section class="informative">
      <h3>生命周期详细信息</h3>

      <p>
        第<a href="#ecosystem-overview"></a>节提供了
        [=可验证凭证=]生态系统的概述。本节将提供更详细的关于
        生态系统预期运行方式的信息。
      </p>

      <figure id="life-cycle-details">
        <img style="margin: auto; display: block; width: 85%;" src="diagrams/ecosystemdetail.svg" alt="图表显示如何
         凭证从发行者流向持有者，可选地
         从一个持有者流向另一个持有者；以及如何
         展示从持有者流向验证者，其中
         所有参与方可以从逻辑上
         可验证的数据注册处获取信息">
        <figcaption style="text-align: center;">
          本规范的角色和信息流动。
        </figcaption>
      </figure>

      <p class="issue" title="需要将验证过程添加到图像中。">
        需要将验证过程添加到上面的图像中。
      </p>

      <p>
        [=可验证凭证=]生态系统中的角色和信息流动如下：
      </p>

      <ul>
        <li>
          一个[=发行者=] <dfn class="export" data-lt="issue">发行</dfn> 一个
          [=可验证凭证=]给一个[=持有者=]。发行总是在涉及[=凭证=]的任何其他行动之前发生。
        </li>
        <li>
          一个[=持有者=]可能会<dfn class="export" data-lt="transfers">转移</dfn>其一个或多个[=可验证
          凭证=]给另一个[=持有者=]。
        </li>
        <li>
          一个[=持有者=] <dfn class="export" data-lt="present">展示</dfn>其一个或
          多个[=可验证凭证=]给一个[=验证者=]，可选地
          在一个[=可验证的展示=]内部。
        </li>
        <li>
          一个[=验证者=] [=验证=]所展示的
          [=可验证的展示=]和[=可验证的凭证=]的真实性，并
          检查任何<a href="#status">凭证状态</a>（如果存在）
          的[=可验证的凭证=]。
        </li>
        <li>
          在[=验证=]之后，一个[=验证者=]验证所展示的[=可验证凭证=]中的相关声明，
          使用他们自己的业务逻辑来评估哪些发行者适合哪些声明，以及哪些主题适合所请求的使用。
        </li>
        <li>
          一个[=发行者=]可能会<dfn class="export" data-lt="revoke">撤销</dfn>一个
          [=可验证的凭证=]。
        </li>
        <li>
          一个[=持有者=]可能会<dfn class="export" data-lt="delete">删除</dfn>一个
          [=可验证的凭证=]。
        </li>
      </ul>

      <p class="note">
        上述行动的顺序并不固定，有些行动可能会被执行多次。这样的行动重复可能是立即的，也可能在任何以后的时间点。
      </p>

      <p>
        最常见的行动序列预计是：
      </p>

      <ol>
        <li>
          一个[=发行者=] <a href="#lifecycle-details">发行</a> 一个[=可验证
          凭证=]给一个[=持有者=]。
        </li>
        <li>
          该[=持有者=]<a href="#lifecycle-details">向</a>
          一个[=验证者=]展示。
        </li>
        <li>
          该[=验证者=] <a href="#lifecycle-details">验证</a>。
        </li>
        <li>
          该[=验证者=] <a href="#lifecycle-details">验证</a>声明。
        </li>
        <li>
          该[=验证者=] 应用有效声明</a>。
        </li>
      </ol>

      <p>
        本规范没有定义任何用于传输
        [=可验证凭证=]或[=可验证展示=]的协议，但假设
        其他规范确实指定了它们如何在实体之间传输，那么
        这个可验证凭证数据模型就直接适用。
      </p>

      <p>
        本规范既没有定义授权框架，也没有
        限制[=验证者=]在[=验证=]一个[=可验证凭证=]或[=可验证
        展示=]之后可能做出的业务决策。相反，[=验证者=]
        在将任何声明视为有效之前应用自己的业务规则，
        考虑到[=持有者=]，[=可验证凭证=]的[=发行者=]，[=可验证凭证=]的声明，以及[=验证者=]自己的政策。
      </p>

      <p>
        尤其是，第<a href="#terms-of-use"></a>节和
        可验证凭证
        实施指南[[VC-IMP-GUIDE]]中的<a href="https://w3c.github.io/vc-imp-guide/#subject-holder-relationships">
          主题-持有者关系</a>部分说明了[=验证者=]如何
        确定：
      </p>

      <ul>
        <li>
          [=持有者=]是否是[=可验证凭证=]的[=主题=]。
        </li>
        <li>
          [=主题=]与[=持有者=]之间的关系。
        </li>
        <li>
          原始[=持有者=]是否将[=可验证凭证=]传递给
          随后的[=持有者=]。
        </li>
        <li>
          使用[=可验证凭证=]的[=持有者=]
          或[=验证者=]的任何限制。
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>信任模型</h3>

      <p>
        [=可验证凭证=]的信任模型如下：
      </p>

      <ul>
        <li>
          [=验证者=]信任[=颁发者=]颁发其收到的[=凭证=]。为建立这种信任，预期[=凭证=]应该：
          <ul>
            <li>
              使用<a href="#securing-mechanisms">安全机制</a>保护[=凭证=]，确立
              [=颁发者=]生成了[=凭证=]（即，它是一个
              [=可验证凭证=]），或
            </li>
            <li>
              以清晰确立[=颁发者=]生成了[=可验证凭证=]且
              [=可验证凭证=]在传输或存储过程中未被篡改的方式传输。这种
              信任可能会因[=验证者=]的风险评估而削弱。
            </li>
          </ul>
        </li>
        <li>
          所有[=实体=]信任[=可验证数据注册表=]具有防篡改性，并且是哪些数据由哪些
          [=实体=]控制的正确记录。
        </li>
        <li>
          [=持有者=]和[=验证者=]信任[=颁发者=]为[=主题=]颁发
          真实（即，非虚假）的[=凭证=]，并在适当时撤销它们。
        </li>
        <li>
          [=持有者=]信任[=存储库=]安全存储[=凭证=]，
          不向除[=持有者=]以外的任何人发布它们，并且在其保管期间不
          损坏或丢失它们。
        </li>
      </ul>

      <p>
        与其他信任模型相比，这种信任模型确保：
      </p>

      <ul>
        <li>
          [=颁发者=]和[=验证者=]不需要信任
          [=存储库=]
        </li>
        <li>
          [=颁发者=]不需要了解或信任[=验证者=]。
        </li>
      </ul>

      <p>
        通过解耦[=身份提供者=]和
        [=依赖方=]之间的信任，创建了更灵活、更具动态性的信任模型，
        从而增加了市场竞争和客户选择。
      </p>

      <p>
        有关此信任模型与工作组研究的各种威胁模型之间的交互方式的更多信息，请参阅可验证凭证用例文档[[VC-USE-CASES]]。
      </p>

      <p class="note">
        本规范详细介绍的数据模型并不意味着传递性信任模型，例如由更传统的证书颁发机构信任模型提供的那种。在可验证凭证数据模型中，[=验证者=]要么直接信任[=颁发者=]，要么不信任[=颁发者=]。虽然可以使用可验证凭证数据模型构建传递性信任模型，但实施者应该
        <a href="https://datatracker.ietf.org/doc/draft-iab-web-pki-problems/">了解
          安全弱点</a>，这些弱点是由
        <a href="https://www.usenix.org/conference/imc-05/perils-transitive-trust-domain-name-system">
          广泛委托信任</a>的方式引入的，这种方式是证书颁发机构系统所采用的。
      </p>
    </section>

    <section>
      <h3>可扩展性</h3>

      <p>
        可验证凭证数据模型的目标之一是实现无需许可的创新。为实现这一目标，数据模型需要在多个方面具有可扩展性。数据模型需要：
      </p>

      <ul>
        <li>
          通过使用基于[=graph=]的数据模型，对复杂的多实体关系进行建模。
        </li>
        <li>
          通过使用[[?LINKED-DATA]]，扩展用于描述数据模型中信息的机器可读词汇，无需使用集中式系统来实现。
        </li>
        <li>
          通过使用JOSE或COSE [[VC-JOSE-COSE]]，数据完整性证明[[VC-DATA-INTEGRITY]]，以及可验证凭证规范目录[[?VC-SPECS]]中列出的各种加密套件，支持多种类型的加密证明格式。
        </li>
        <li>
          通过使用[[JSON-LD11]]，在受软件开发人员和网页作者欢迎的数据格式中提供上述所有可扩展性机制。
        </li>
      </ul>

      <p>
        这种数据建模方法通常被称为<em>开放世界假设</em>，意味着任何实体都可以对任何其他实体发表任何言论。尽管这种方法似乎与构建简单且可预测的软件系统相冲突，但在开放世界假设下，平衡可扩展性与程序正确性总是比在封闭软件系统中更具挑战性。
      </p>

      <p>
        本节其余部分通过一系列示例描述了如何实现可扩展性和程序正确性。
      </p>

      <p>
        让我们假设我们从下面显示的[=verifiable credential=]开始。
      </p>

      <pre class="example nohighlight vc" title="A simple credential"
        data-vc-vm="https://university.example/issuers/14#keys-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe"
  }
}
        </pre>

      <p>
        这个可验证凭证声明与与`did:example:abcdef1234567`关联的实体具有值为`Jane Doe`的`name`。
      </p>

      <p>
        现在假设开发人员想要扩展可验证凭证以存储两个额外的信息：一个内部公司参考号和Jane的最喜欢的食物。
      </p>

      <p>
        首先要做的是创建一个包含两个新术语的JSON-LD上下文，如下所示。
      </p>

      <pre class="example nohighlight" title="A JSON-LD context">
{
  "@context": {
    "referenceNumber": "https://example.com/vocab#referenceNumber",
    "favoriteFood": "https://example.com/vocab#favoriteFood"
  }
}
        </pre>

      <p>
        创建完这个 JSON-LD 上下文后，开发人员将其发布到某个地方，以便[=验证者=]可以访问并处理[=可验证凭证=]。
        假设上述 JSON-LD 上下文发布在 `https://example.com/contexts/mycontext.jsonld`，
        我们可以通过包含上下文并添加新的[=属性=]和[=凭证=]的[=类型=]来扩展这个示例。
      </p>

      <pre class="example nohighlight" title="A verifiable credential with a custom extension">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    <span class="highlight">"https://example.com/contexts/mycontext.jsonld"</span>
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential", "CustomExt12"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  <span class="highlight">"referenceNumber": 83294847,</span>
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe",
    <span class="highlight">"favoriteFood": "Papaya"</span>
  }
}
        </pre>

      <p>
        这个例子演示了如何以无需许可和去中心化的方式扩展可验证凭证数据模型。所示的机制还确保以这种方式创建的[=可验证凭证=]提供了一种防止命名空间冲突和语义模糊的机制。
      </p>

      <p>
        这样的动态扩展性模型确实增加了实施负担。为这样的系统编写的软件必须根据应用的风险特性来确定是否接受带有扩展的[=可验证凭证=]。一些应用可能只接受某些扩展，而高度安全的环境可能不接受任何扩展。这些决定由这些应用的开发者来做，明确地说，这不是本规范的领域。
      </p>

      <p>
        开发者被敦促确保扩展JSON-LD上下文的高可用性。无法解引用上下文的实现将产生错误。确保扩展JSON-LD上下文始终可用的策略包括使用内容寻址URL来获取上下文，将上下文文档与实现捆绑在一起，或启用上下文的积极缓存。
      </p>

      <p>
        实施者被建议密切关注本规范中的扩展点，例如在<a href="#proofs-signatures"></a>、<a href="#status"></a>、<a href="#data-schemas"></a>、<a
          href="#refreshing"></a>、<a href="#terms-of-use"></a>和<a
          href="#evidence"></a>等部分。虽然本规范并未为这些扩展点定义具体的实现，但可验证凭证规范目录[[?VC-SPECS]]提供了一个非官方的，由开发者可以从这些扩展点使用的扩展的策略列表。
      </p>

      <section>
        <h4>语义互操作性</h4>

        <ul>
          <li>
            基于JSON-LD的处理器在JSON-LD上下文重新定义
            <a href="https://www.w3.org/TR/json-ld/#dfn-active-context">活动上下文</a>中的任何术语时，必须产生错误。
            更改现有术语定义的唯一方法是引入一个新术语，该术语在新术语的范围内清除活动上下文。对此功能感兴趣的作者应阅读JSON-LD 1.1规范中的
            `@protected` 功能。
          </li>
        </ul>

        <p>
          任何寻求互操作性的实现者都应发布一个描述`@context` [=property=]的值预期顺序的人类可读文档。期望JSON-LD实现者在寻求互操作性时，在`@context`
          [=property=]中指定的URL上发布机器可读描述（即，一个普通的JSON-LD上下文文档）。
        </p>
      </section>
    </section>

    <section>
      <h2>相关资源的完整性</h2>
      <p>
        当在[=可验证的凭证=]中包含指向外部资源的链接时，我们希望知道签名时指向的资源是否与验证时的资源相同。这适用于远程检索外部资源的情况，也适用于[=发行者=]和/或[=验证者=]可能拥有资源的本地缓存副本的情况。
      </p>
      <p>
        我们还希望知道在[=可验证的凭证=]中使用的JSON-LD上下文的内容在[=发行者=]和[=验证者=]使用时是否相同。
      </p>
      <p>
        为了验证由[=可验证的凭证=]引用的资源在验证时与发行时是否相同，实施者可以包含一个名为<code
          id="defn-relatedResource">relatedResource</code>的属性，该属性存储一个对象数组，描述每个由[=可验证的凭证=]引用的资源的额外完整性元数据。如果存在`relatedResource`，则数组中必须有一个对象，用于在可验证的凭证中使用的每个上下文的每个远程资源。
      </p>
      <p class="issue" title="Mandatory listing of contexts in relatedResouce are under debate.">
        目前正在VCWG中讨论是否需要在`relatedResource`中列出上下文。这个要求可能会在规范的未来版本中被移除。
      </p>
      <p>
        `relatedResource`数组中的每个对象必须包含以下内容：命名为`id`的资源的[[URL]]，以及使用<a
          href="https://www.w3.org/TR/SRI/#integrity-metadata">子资源完整性</a>中指定的方法构建的资源的<code
          id="defn-digestSRI">digestSRI</code>信息。
      </p>
      <p class="issue" title="Unification of cryptographic hash expression formats are under discussion">
        工作组目前正在尝试确定是否可以在所有的VCWG核心规范中统一加密哈希表达格式。这种机制的候选者包括`digestSRI`和`digestMultibase`。工作组目前正在讨论统一的利弊。
      </p>
      <p>
        `relatedResource`中每个`id`不得有多于一个的对象。
      </p>
      <p>
        `relatedResource`数组中的对象可以包含一个名为`mediaType`的属性，该属性指示指定`resource`的预期媒体类型。如果包含了`mediaType`，其值应该：
      </p>
      <ul>
        <li>
          是<a href="https://www.iana.org/assignments/media-types/media-types.xhtml">IANA媒体类型</a>注册表中列出的有效媒体类型
        </li>
        <li>
          在检索内容时使用，例如通过`Accept` HTTP头
        </li>
        <li>
          与检索到的内容媒体类型匹配，例如通过`Content-Type` HTTP头。
        </li>
      </ul>

      <p>
        [=可验证凭证=]中包含`id` [[URL]]属性的任何对象都可以通过在对象中包含`digestSRI`来按照本节的规定添加完整性信息。
      </p>
      <p>
        对于希望进行选择性披露的任何对象，不应将其作为`relatedResource`数组中的一个对象包含进去。
      </p>
      <p>
        编写根据[=符合性文档=]中对象的`id`获取资源的算法的规范作者需要考虑该资源的内容是否对该文档的有效性至关重要。如果是，除非资源具有预期的媒体类型，并且其字节散列到预期的摘要，否则规范必须产生验证错误。
      </p>
      <p>
        实施者被敦促咨询适当的资源，例如
        <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">
          FIPS 180-4安全哈希标准</a>和
        <a href="https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF">
          商业国家安全算法套件2.0</a>以确保他们选择了当前且可靠的哈希算法。在编写本文时，`sha384`应被视为实施者使用的最低强度哈希算法。
      </p>
      <p class="issue">
        工作组正在讨论我们是否将采用[[SRI]]中定义的子资源完整性的更多方面，并将其纳入[[JSON-LD11]]规范，如该规范的<a
          href="https://www.w3.org/TR/json-ld11/#security">
          当前安全考虑</a>所述，VC中的这个哈希可以作为确保发行VC时使用的缓存上下文与远程资源匹配的额外检查。
      </p>
      <p>
        下面是一个引用JSON-LD上下文的相关资源完整性对象的示例。
      </p>

      <pre class="example nohighlight" title="Usage of the relatedResource property">
"relatedResource": [{
  "id": "https://www.w3.org/ns/credentials/v2",
  "digestSRI":
    "sha384-lHKDHh0msc6pRx8PhDOMkNtSI8bOfsp4giNbUrw71nXXLf13nTqNJoRp3Nx+ArVK",
},{
  "id": "https://www.w3.org/ns/credentials/examples/v2",
  "digestSRI":
    "sha384-zNNbQTWCSUSi0bbz7dbua+RcENv7C6FvlmYJ1Y+I727HsPOHdzwELMYO9Mz68M26",
}]
        </pre>

      <p>
        `credentialSubject`中引用完整性保护图像的对象示例。
      </p>

      <pre class="example nohighlight" title="An integrity-protected image that is associated with a credentialSubject">
"credentialSubject": {
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "image": {
    "id": "https://university.example.org/images/58473",
    "digestSRI":
      "sha384-ZfAwuJmMgoX3s86L7x9XSPi3AEbiz6S/5SyGHJPCxWHs5NEth/c5S9QoS1zZft+J",
    "mediaType": "application/svg+xml",
  },
  ...
}
        </pre>
    </section>

    <section>
      <h3>刷新</h3>

      <p class="issue" title="(AT RISK) 特性取决于独立实现的演示">
        该特性处于风险状态，如果在候选推荐阶段结束前，至少没有两个独立的、可互操作的实现针对单个扩展类型进行演示，它将从规范中删除。如果删除此特性，该属性将包含在第<a
          href="#reserved-extension-points"></a>节中，以期待未来的实现和包含在规范中。
      </p>

      <p>
        对于系统来说，启用过期的[=verifiable credential=]的手动或自动刷新是很有用的。有关[=verifiable credentials=]的有效期的更多信息，请参见第<a
          href="#validity-periods"></a>节。本规范定义了一个`refreshService` [=property=]，使[=issuer=]能够包含指向刷新服务的链接。
      </p>
      <p>
        [=issuer=]可以将刷新服务作为[=verifiable credential=]内部的一个元素，如果它既适用于[=verifier=]，也适用于[=holder=]（或两者），或者在[=verifiable
        presentation=]内部，如果它仅适用于[=holder=]。在后一种情况下，这使得[=holder=]在创建[=verifiable
        presentation=]与[=verifier=]共享之前可以刷新[=verifiable credential=]。在前一种情况下，将刷新服务包含在[=verifiable
        credential=]内部，使得[=holder=]或[=verifier=]可以执行未来的[=credential=]更新。
      </p>
      <p>
        只有在[=credential=]已过期或[=issuer=]不发布[=credential=]状态信息时，才预期使用刷新服务。建议[=Issuers=]不要将`refreshService`
        [=property=]放在一个不包含公共信息或其刷新服务未以某种方式受保护的[=verifiable credential=]中。
      </p>
      <p class="note">
        将`refreshService` [=property=]放在[=verifiable
        credential=]中，使其对[=verifiers=]可用，可能会从[=holder=]中移除控制和同意，并允许[=verifiable
        credential=]直接发给[=verifier=]，从而绕过[=holder=]。
      </p>

      <dl>
        <dt><var id="defn-refreshService">refreshService</var></dt>
        <dd>
          `refreshService` [=property=]的值必须是一个或多个刷新服务，为接收者的软件提供足够的信息，以便接收者可以刷新[=verifiable
          credential=]。每个`refreshService`值必须指定其`type`（例如，`ManualRefreshService2018`）和其`id`，即服务的[=URL=]。预期需要从URL检索机器可读的信息。每个刷新服务的确切内容由特定的`refreshService`
          [=type=]定义确定。
        </dd>
      </dl>

      <pre class="example nohighlight" title="Usage of the refreshService property by an issuer">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"refreshService": {
    "id": "https://university.example/refresh/3732",
    "type": "ManualRefreshService2018"
  }</span>
}
        </pre>

      <p>
        在上面的示例中，[=issuer=]指定了一个手动的`refreshService`，可以通过将[=holder=]或[=verifier=]指向`https://university.example/refresh/3732`来使用。
      </p>

    </section>

    <section>
      <h3>使用条款</h3>

      <p>
        使用条款可以被[=发行者=]或[=持有者=]用于传达在发行[=可验证凭证=]或[=可验证展示=]时所遵循的条款。[=发行者=]将其使用条款放置在[=可验证凭证=]内。[=持有者=]将其使用条款放置在[=可验证展示=]内。本规范定义了一个用于表达使用条款信息的`termsOfUse`
        [=属性=]。
      </p>

      <p>
        `termsOfUse` [=属性=]的值可能用于告知[=验证者=]以下任何或所有内容，以及其他事项：
      </p>

      <ul>
        <li>
          发行[=可验证凭证=]时所使用的程序或政策，例如，提供指向公共位置的指针（以避免“回拨”隐私问题），在该位置可以找到这些程序或政策，或者定义它们的标准的名称
        </li>
        <li>
          适用于向[=验证者=]展示此[=可验证凭证=]的[=发行者=]的规则和政策，例如，提供指向公共位置的指针（以避免“回拨”隐私问题），在该位置可以找到这些规则或政策
        </li>
        <li>
          在其授权下发行此特定[=可验证凭证=]的实体的身份
        </li>
      </ul>

      <dl>
        <dt><var id="defn-termsOfUse">termsOfUse</var></dt>
        <dd>
          `termsOfUse`
          [=属性=]的值必须指定创建者发行[=凭证=]或[=展示=]所遵循的一个或多个使用条款政策。如果接收者（[=持有者=]或[=验证者=]）不愿意遵守指定的使用条款，则他们需要自行承担责任，并且如果违反了规定的使用条款，可能会承担法律责任。每个`termsOfUse`值必须指定其[=类型=]，例如，`IssuerPolicy`，并可以指定其实例`id`。每个使用条款的具体内容由特定的`termsOfUse`
          [=类型=]定义来确定。
        </dd>
      </dl>

      <pre class="example nohighlight" title="Usage of the termsOfUse property by an issuer">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:did:123456",
  "type": [
    "VerifiableCredential",
    "EbsiTermsOfUseExample"
  ],
  "issuer": "did:ebsi:zz7XsC9ixAXuZecoD9sZEM1",
  "validFrom": "2021-11-01T00:00:00Z",
  "validUntil": "2021-10-30T00:00:00Z",
  "credentialSubject": {
    "id": "did:key:z2dmzD81cgPx8Vki7JbuuMmFYrWPgYoytykUZ3eyqht1j9KbrDt4zxXoDrBWYFiATYZ8G9JMeEXC7Kki24fbTwtsJbGe5qcbkYFunSzcDokMRmj8UJ1PbdCGh33mf97K3To89bMzd15qrYq3VkDztoZqfmujkJVpvTbqoXWXqxmzNDbvMJ",
    "personalIdentifier": "IT/DE/1234",
    "familyName": "Castafiori",
    "firstName": "Bianca",
    "dateOfBirth": "1930-10-01"
  },
  "credentialSchema": {
    "id": "https://api-test.ebsi.eu/trusted-schemas-registry/v2/schemas/z3MgUFUkb722uq4x3dv5yAJmnNmzDFeK5UC8x83QoeLJM",
    "type": "JsonSchema"
  },
  "termsOfUse": {
    "id": "https://api-test.ebsi.eu/trusted-issuers-registry/v4/issuers/did:ebsi:zz7XsC9ixAXuZecoD9sZEM1/attributes/7201d95fef05f72667f5454c2192da2aa30d9e052eeddea7651b47718d6f31b0",
    "type": "IssuanceCertificate"
  }
}
        </pre>

      <p>
        在上述示例中，[=发行者=] 断言作为欧洲区块链服务基础设施（EBSI）认证发行者，它遵守 EBSI 政策作为认证发行者，并在 EBSI 受信任发行者注册中注册。[=termsOfUse=] [=id=] 可以由
        [=验证者=] 解析，以确认 [=发行者=] 已获得由 EBSI 信任链中更高级别的受信任发行者颁发的认证 VC（JWT 格式）[?EBSI]。
      </p>


      <pre class="example nohighlight" title="Usage of the termsOfUse property by a holder">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    {
        "@protected": true,
        "VerifiablePresentationTermsOfUseExtension": {
          "@id": "https://www.w3.org/2018/credentials/examples#VerifiablePresentationExtension",
          "@context": {
            "@protected": true,
            "termsOfUse": {
              "@id": "https://www.w3.org/2018/credentials#termsOfUse",
              "@type": "@id"
            }
          }
        }
    }
  ],
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/3732",
    "type": ["VerifiableCredential", "ExampleDegreeCredential"],
    "issuer": "https://university.example/issuers/14",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "degree": {
        "type": "ExampleBachelorDegree",
        "name": "Bachelor of Science and Arts"
      }
    }
  }],
  <span class="highlight">"termsOfUse": [{
    "type": "HolderPolicy",
    "id": "http://example.com/policies/credential/6",
    "profile": "http://example.com/profiles/credential",
    "prohibition": [{
      "assigner": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "assignee": "https://wineonline.example.org/",
      "target": "http://university.example/credentials/3732",
      "action": ["3rdPartyCorrelation"]
    }]
  }]</span>
}
        </pre>

      <p>
        在上述示例中，[=持有者=]（`assigner`）同时也是[=主题=]，表达了一项使用条款，禁止[=验证者=]
        （`assignee`，`https://wineonline.example.org`）使用提供的信息通过第三方服务关联[=持有者=]或[=主题=]。如果[=验证者=]使用第三方
        服务进行关联，他们将违反[=持有者=]创建[=展示=]的条款。
      </p>

      <p>
        本功能还预计将被政府颁发的
        [=可验证凭证=]用于指导数字钱包将其使用限制在类似的政府组织中，以试图保护公民免受敏感数据意外使用的影响。同样，一些
        由私营行业颁发的[=可验证凭证=]预计将限制
        在组织内部的部门之间使用，或在工作时间内使用。实施者被敦促在可验证凭证实施指南
        [[?VC-IMP-GUIDE]]文档的相应部分阅读有关这个迅速发展的功能的更多信息。
      </p>

    </section>

    <section>
      <h3>证据</h3>

      <p class="issue" data-number="1303" title="(AT RISK) 特性取决于独立实现的演示">
        该特性存在风险，如果在候选推荐阶段结束时，至少没有两个独立的、可互操作的实现针对单个扩展类型进行演示，那么该特性将从规范中删除。如果删除了此功能，该属性将包含在第
        <a href="#reserved-extension-points"></a>节中，以期待未来的实现和包含在规范中。
      </p>

      <p>
        [=发行者=]可以包含证据，以便在[=可验证凭证=]中向[=验证者=]提供额外的支持信息。这可以被[=验证者=]用来建立它依赖[=可验证凭证=]中的声明的信心。
      </p>
      <p>
        例如，[=发行者=]可以在发行[=凭证=]之前检查[=主题=]提供的实体文件或执行一系列背景检查。在某些场景中，这些信息对于[=验证者=]在确定依赖某个[=凭证=]所涉及的风险时非常有用。
      </p>

      <p>
        本规范定义了用于表示证据信息的`evidence` [=属性=]。
      </p>

      <dl>
        <dt><dfn id="defn-evidence" class="export">evidence</dfn></dt>
        <dd>
          `evidence` [=属性=]的值必须是一个或多个证据方案，为[=验证者=]提供足够的信息，以确定[=发行者=]收集的证据是否满足其对[=凭证=]的信心要求。每个证据方案由其[=类型=]标识。`id`
          [=属性=]是可选的，
          但如果存在，应包含一个指向有关此证据实例的更多信息的URL。每个证据方案的确切内容由特定的`evidence` [=类型=]定义确定。
        </dd>
      </dl>

      <p class="note">
        有关规范如何支持附件和对[=凭证=]和非凭证数据的引用的信息，请参阅可验证凭证实施指南[[VC-IMP-GUIDE]]文档。
      </p>

      <pre class="example nohighlight" title="Usage of the evidence property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"evidence": {
    "id": "https://university.example/evidence/f2aeec97-fc0d-42bf-8ca7-0548192d4231",
    "type": ["DocumentVerification"],
    "verifier": "https://university.example/issuers/14",
    "evidenceDocument": "DriversLicense",
    "subjectPresence": "Physical",
    "documentPresence": "Physical",
    "licenseNumber": "123AB4567"
  }</span>
}
        </pre>

      <p class="note">
        在这个`evidence`示例中，[=issuer=]声称他们将[=credential=]的[=subject=]与实体驾驶执照的副本进行了匹配，该副本上有所述的驾驶执照号码。这张驾驶执照在发证过程中被用来验证“Example
        University”在发放证书之前对主体进行了验证，以及他们是如何做到这一点的（实体验证）。
      </p>

      <p class="note">
        `evidence` [=property=] 提供的信息与所使用的保护机制的信息不同。`evidence` [=property=]
        用于表达与[=可验证凭证=]的完整性相关的支持信息，如文件证据。相反，保护机制用于表达与[=发行者=]的真实性和[=可验证凭证=]的完整性相关的机器可验证的数学证明。有关保护机制的更多信息，请参见第<a
          href="#securing-mechanisms"></a>节。
      </p>

    </section>

    <section>
      <h3>零知识证明</h3>

      <p>
        零知识证明是一种加密方法，它使用户能够证明对一个值的知识，而不需要披露实际的值。这种数据模型支持使用零知识证明机制进行安全保护。
      </p>
      <p>
        一些由零知识证明机制实现的，与[=可验证的凭证=]兼容的功能：
      </p>
      <ul>
        <li>
          [=持有者=]向[=验证者=]选择性披露在[=可验证的凭证=]中的属性。这使得[=持有者=]能够为[=验证者=]提供他们需要的精确信息，而不是更多。这也使得在呈现时，无需涉及[=发行者=]，就能生成一个按照[=验证者=]的数据模式格式化的派生[=可验证的凭证=]。这为[=持有者=]使用他们的发行[=可验证的凭证=]提供了很大的灵活性。
        </li>
        <li>
          对与[=验证者=]共享的签名值进行盲化。盲签名允许进行不可链接的证明，这消除了在向一个或多个[=验证者=]进行多次展示时，[=持有者=]关联的常见来源。这使得[=持有者=]在每次展示时都可以分享不同的签名值，从而减少了分享的数据量。
        </li>
        <li>
          保护[=持有者=]和/或[=主题=]的隐私识别。这使得[=持有者=]可以证明一个[=凭证=]是发给他们的，或者[=主题=]可以证明一个[=凭证=]是关于他们的，而无需分享一个标识符。这也减少了需要分享的数据量。这种能力也可以用来将来自多个[=发行者=]的多个[=可验证的凭证=]合并成一个单一的[=可验证的展示=]，而不需要向[=验证者=]揭示[=可验证的凭证=]或[=主题=]的标识符。
        </li>
      </ul>
      <p>
        并非所有的零知识证明机制都支持所有的功能。关于特定零知识证明机制提供的功能和技术的具体细节，以及使用它们与[=可验证的凭证=]的规范要求，将在一个用于保护[=可验证的凭证=]的零知识证明机制的规范中找到。
      </p>
      <p>
        我们注意到，在大多数情况下，[=持有者=]使用零知识机制与[=可验证的凭证=]需要[=发行者=]以支持这些功能的方式保护[=可验证的凭证=]。
      </p>
      <p>
        当[=持有者=]选择性地披露了一部分[=可验证的凭证=]时，重要的是[=验证者=]检查在派生[=可验证的凭证=]中提供的信息是否与[=发行者=]提供的`credentialSchema`[=属性=]中的模式兼容。[=验证者=]也可以在请求[=持有者=]的数据时，向[=持有者=]提供一个模式，并确保派生的[=可验证的凭证=]与该模式兼容。我们在这个规范中没有定义这样一个请求模式，但一个实现这种方法的例子是[[?PRES-EX]]。
      </p>
      <p class="note">
        `credentialSchema`的实现者被鼓励考虑选择性披露凭证的影响，并根据构造提供处理指南。如果一个模式没有考虑到选择性披露，那么验证可能会失败。
      </p>
      <p>
        下面的图示说明了如何使用数据模型在零知识中发行和展示[=可验证的凭证=]。
      </p>
      <p class="issue">
        将来会在这里添加利用<a href="https://w3c.github.io/vc-di-bbs/">vc-di-bbs</a>的示例，或者删除这一部分。
      </p>

      <figure>
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/zkp-cred-pres.svg" alt="Verifiable
            Credential 1 and Verifiable Credential 2 on the left map
            to Derived Credential 1 and Derived Credential 2 inside a
            Presentation on the right.  Verifiable Credential 1
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains GivenName, FamilyName, and
            Birthdate and Proof contains Signature, Proof of
            Correctness, and Attributes.  Verifiable Credential 2
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains University, which contains
            Department, which contains DegreeAwarded, and Proof contains Signature, Proof of
            Correctness, and Attributes.  The Presentation diagram on
            the right contains Context, Type, ID,
            VerifiableCredential, and Proof, where
            VerifiableCredential contains Derived Credential 1 and
            Derived Credential 2 and Proof contains Common Link
            Secret.  Derived Credential 1 contains Context, Type, ID,
            Issuer, Issue Date, CredentialSubject, and Proof, where
            CredentialSubject contains AgeOver18 and Proof contains
            Knowledge of Signature.  Derived Credential 2 contains
            Context, Type, ID, Issuer, Issue Date, CredentialSubject,
            and Proof, where CredentialSubject contains Degree and
            Proof contains Knowledge of Signature.  A line links
            Birthdate in Verifiable Credential 1 to AgeOver18 in
            Derived Credential 1.  A line links DegreeAwarded in
            Verifiable Credential 2 to Degree in Derived Credential 2.">
        <figcaption style="text-align: center;">
          ZKP [=presentation=] 中凭证和派生凭证之间关系的可视化示例。
        </figcaption>

      </figure>

      <p>
        对于创建提供不可链接性的<a href="#securing-mechanisms">安全机制</a>规范的作者，提供以下准则：

      <ul>
        <li>
          不可链接的安全机制不得设计成会泄露信息，从而使得 [=verifier=] 能够在多个 [=verifiable presentations=] 到不同的 [=verifiers=] 之间关联一个 [=holder=]。
        </li>
      </ul>
      </p>


    </section>

    <section class="informative">
      <h3>授权</h3>

      <p>
        [=可验证凭证=] 旨在作为可靠识别 [=subjects=] 的手段。尽管承认基于角色的访问控制（RBACs）和基于属性的访问控制（ABACs）
        依赖于此身份识别作为授权 [=subjects=] 访问资源的手段，但本规范不提供完整的 RBAC 或 ABAC 解决方案。在没有相应的授权框架的情况下，
        本规范不适用于授权。
      </p>

      <p>
        工作组在创建本规范期间考虑了授权用例，并正在作为建立在本规范之上的体系结构层的工作中继续推进该工作。
      </p>
    </section>


    <section class="normative">
      <h3>保留的扩展点</h3>

      <p>
        本规范保留了若干[=属性=]作为可能的扩展点。虽然一些实现者对这些属性表示了兴趣，
        但将它们包含在本规范中被认为是过早的；这些扩展点可能在本规范的未来版本中被更正式地定义。需要注意的是，这些属性并未由本规范定义，实现者需谨慎使用这些属性，因为它们被认为是实验性的。
      </p>
      <p>
        实现者可以使用这些属性，但在规范化指定它们的过程中，应预期它们和/或它们的含义会发生变化。
        实现者在没有公开披露描述其实现的规范的情况下，不应使用这些属性。
      </p>

      <p>
        为了避免关于如何使用以下属性的冲突，实现必须在与保留属性关联的值中指定一个`type`属性。有关添加`type`信息的更多信息，请参阅<a href="#types"></a>部分。
      </p>
      <p class="issue" title="工作组正在考虑的扩展点">
        工作组正在讨论是否在<a href="https://www.w3.org/ns/credentials/v2">https://www.w3.org/ns/credentials/v2</a>中保留额外的扩展点。
        <br /><br />
        工作组目前计划只保留在社区组中孵化的至少有草案规范的扩展点。
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>Reserved&nbsp;Property</th>
            <th>Description</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>`confidenceMethod`</td>
            <td>
              一个用于指定验证者可能使用的一种或多种方法的属性，以提高对可验证凭证或可验证呈现中的属性值的准确性的信心，包括但不限于诸如`initialRecipient`（又名`issuee`）、`presenter`、`authorizedPresenter`、`holder`等属性。相关的词汇表URL必须是`https://www.w3.org/2018/credentials#confidenceMethod`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                如果在候选推荐阶段结束前至少有一个规范和两个独立实现被证明，则此属性保留可能会被删除，以支持规范中现有的部分。如果没有发生这种情况，此保留将保留，但规范中现有的部分将被删除。
                参见<a href="https://w3c-ccg.github.io/confidence-method-spec/">可验证凭证信心方法</a>。
              </p>
            </td>
          </tr>
          <tr>
            <td>`evidence`</td>
            <td>
              用于指定发放凭证所需的证据的属性。关联的词汇表 URL 必须是 `https://www.w3.org/2018/credentials#evidence`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                该属性的保留可能会被删除，以支持规范中的现有部分，如果在候选推荐阶段结束时至少有一个具有两个独立实现的规范得以证明。如果未能实现该目标，
                该保留将保留，但规范中的现有部分将被移除。
              </p>
            </td>

          </tr>
          <tr>
            <td>`refreshService`</td>
            <td>
              用于指定凭证如何进行刷新的属性。关联的词汇表 URL 必须是 `https://www.w3.org/2018/credentials#refreshService`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                该属性的保留可能会被删除，以支持规范中的现有部分，如果在候选推荐阶段结束时至少有一个具有两个独立实现的规范得以证明。如果未能实现该目标，
                该保留将保留，但规范中的现有部分将被移除。
              </p>
            </td>

          </tr>
          <tr>
            <td>`renderMethod`</td>
            <td>
              用于指定一种或多种将凭证呈现为视觉、听觉或触觉格式的方法的属性。关联的词汇表 URL 必须是 `https://www.w3.org/2018/credentials#renderMethod`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                此保留属性存在风险，如果在候选推荐阶段结束时未能证明至少有一个具有两个独立实现的规范，将从规范中移除。
                请参阅<a href="https://w3c-ccg.github.io/vc-render-method/">可验证凭证呈现方法</a>。
              </p>
            </td>

          </tr>
          <tr>
            <td>`termsOfUse`</td>
            <td>
              用于指定凭证使用条款的属性。关联的词汇表 URL 必须是 `https://www.w3.org/2018/credentials#termsOfUse`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                此保留属性存在风险，如果在候选推荐阶段结束时未能证明至少有一个具有两个独立实现的规范，将从规范中移除。
              </p>
            </td>

          </tr>
        </tbody>
      </table>


      <p>
        与本规范中定义的扩展点相关联的规范的非官方列表，以及本节中定义的保留扩展点，可在可验证凭证规范目录 [[?VC-SPECS]] 中找到。
        目录中涉及保留扩展点的项目应被视为实验性质。
      </p>
      

    </section>

    <section class="normative">
      <h3>生态系统兼容性</h3>

      <p>
        有许多数字凭证格式本身并不使用本文档中提供的数据模型，但与本规范中的许多概念保持一致。在出版时，这些数字凭证格式的例子包括
        <a href="https://www.rfc-editor.org/rfc/rfc7519.html">
          JSON Web Tokens</a> (JWTs)，
        <a href="https://www.rfc-editor.org/rfc/rfc8392.html">
          CBOR Web Tokens</a> (CWTs)，
        <a href="https://www.iso.org/standard/69084.html">ISO-18013-5:2021</a>
        (mDLs)，
        <a href="https://hyperledger.github.io/anoncreds-spec/">
          AnonCreds</a>，
        <a href="https://datatracker.ietf.org/doc/draft-mcnally-envelope/">
          Gordian Envelopes</a>，和
        <a href="https://datatracker.ietf.org/doc/draft-ssmith-acdc/">
          Authentic Chained Data Containers</a> (ACDCs)。
      </p>

      <p>
        如果概念上对齐的数字凭证格式可以根据本节提供的规则转换为
        [=符合规范的文档=]，它们被认为是<em>"与W3C可验证凭证生态系统兼容"</em>。描述如何执行转换以实现与可验证凭证生态系统兼容性的规范：
      </p>

      <ul>
        <li>
          必须确定将此数据模型的转换是单向还是可往返。
        </li>
        <li>
          在执行可往返转换时，必须保留`@context`值。
        </li>
        <li>
          在转换为本规范描述的数据模型时，必须产生一个[=符合规范的文档=]。
        </li>
        <li>
          必须为输入文档指定一个注册的媒体类型。
        </li>
        <li>
          应提供一个测试套件，证明将指定的转换算法应用于本规范中的数据模型会产生
          一个[=符合规范的文档=]。
        </li>
        <li>
          应确保转换后的[=符合规范的文档=]中使用的所有语义都遵循链接数据的最佳实践。请参阅
          第<a href="#getting-started"></a>节，第
          <a href="#extensibility"></a>节，以及链接数据最佳实践[[?LD-BP]]
          以获取更多指导。
        </li>
      </ul>

      <p class="note" title="什么构成了一个可验证的凭证？">
        建议读者注意，只有当数字凭证是一个[=符合规范的文档=]并且至少使用了一种安全机制（如本规范中各自的要求所述）时，才被认为与W3C可验证凭证生态系统兼容。虽然一些社区可能会称一些不是[=符合规范的文档=]的数字凭证格式为“可验证凭证”，但这样做并不能使该数字凭证符合本规范。
      </p>

    </section>

    <section>
      <h3>可验证凭证图</h3>

      <p>
        在表达[=可验证凭证=]（例如在[=展示=]中）时，确保一个[=可验证凭证=]中的数据不会被误认为是另一个[=可验证凭证=]中的相同数据是很重要的。例如，如果有两个[=可验证凭证=]，每个都包含以下形式的对象：`{"type": "Person", "name": "Jane
        Doe"}`，就无法判断一个对象是否在描述与另一个对象相同的人。换句话说，在确认两个[=可验证凭证=]讨论的是相同实体和/或属性之前，合并两个[=可验证凭证=]之间的数据可能会导致数据集损坏。
      </p>

      <p>
        为了确保来自不同[=可验证凭证=]的数据不会意外地混合在一起，使用<dfn class="export">可验证凭证图</dfn>的概念来封装每个[=可验证凭证=]。对于简单的[=可验证凭证=]，即JSON-LD文档包含一个可能带有关联证明的单一凭证时，此图是[=默认图=]。对于[=展示=]，与[=展示=]的`verifiableCredential`属性关联的每个值都是一个单独的[=命名图=]，类型为<dfn class="export">VerifiableCredentialGraph</dfn>，其中包含一个[=可验证凭证=]或一个
        <a href="#enveloped-verifiable-credentials">封装的可验证凭证</a>。
      </p>
      <p>
        使用这些[=图=]在执行JSON-LD处理时会产生具体效果，这样可以正确地将一个图中的图节点标识符与另一个图中的图节点标识符分开。将输入限制为特定于应用程序的JSON-LD文档的实现者在将一个[=可验证凭证=]中的数据与另一个[=可验证凭证=]中的数据合并时，也需要考虑到这一点，例如，当`credentialSubject.id`在两个[=可验证凭证=]中都相同时，但对象可能包含前一段中描述的"Jane Doe"形式的对象。在不包含使用全局标识符（如URL）的`id`属性的情况下，不要合并看似具有相似属性的对象非常重要。
      </p>
    </section>

    <section>
      <h3>安全机制规范</h3>

      <p>
        如第<a href="#securing-mechanisms">节</a>所述，实现者在保护[=符合规范的文档=]时可以使用多种策略。为了最大化实用性和互操作性，希望建立新的保护[=符合规范的文档=]方法的规范作者可以参考本节的指南。
      </p>

      <p>
        安全机制规范必须记录为[=符合规范的文档=]提供内容完整性保护的规范性算法。这些算法可以是通用的，也可以用于保护除[=符合规范的文档=]之外的其他数据。
      </p>

      <p>
        安全机制规范必须提供一种验证机制，该机制仅返回已经被保护的[=符合规范的文档=]中的信息，不包括任何安全机制信息，如`proof`或JOSE/COSE头参数和签名。规范可以提供额外的机制来传达其他可能有用的信息（例如，在验证过程中或用于调试目的），如安全机制数据。安全机制的验证算法必须提供一个接口，该接口接收字节序列（[=字节序列=] |inputBytes|）或文档（[=映射=] |inputDocument|）和媒体类型（[=字符串=] |inputMediaType|）作为输入，并返回至少包含以下[=结构/项目=]的验证结果：
      </p>

      <dl>
        <dt>[=布尔值=] |status|</dt>
        <dd>
          验证状态，如果验证成功，则值为`true`，如果验证失败，则值为`false`。
        </dd>
        <dt>[=映射=] |document|</dt>
        <dd>
          一个仅包含成功保护的信息的文档。
        </dd>
        <dt>[=字符串=] |mediaType|</dt>
        <dd>
          一个在[[RFC6838]]中定义的媒体类型。
        </dd>
      </dl>

      <p class="issue atrisk" title="控制器文档引用可能会发生变化">
        工作组目前正在尝试在[[[?DID-CORE]]]、[[[?VC-DATA-INTEGRITY]]]和[[[?VC-JOSE-COSE]]]之间对控制器文档的定义进行对齐。目标是让每个先前声明的规范和本规范都可以引用一个关于控制器文档的规范性声明。在候选推荐阶段，对控制器文档的规范性引用预计会发生变化。
      </p>

      <p>
        安全机制规范应为对验证至关重要的URL引用的任何信息提供完整性保护。可以实现此保护的机制在第<a href="#integrity-of-related-resources">节</a>和第<a href="#base-context">节</a>中有讨论。
      </p>

      <p>
        创建新类型[=嵌入式证明=]的安全机制规范必须为保护[=可验证凭证=]和[=可验证演示文稿=]指定一个[=属性=]。嵌入式安全机制所使用的属性要求如下：
      </p>

      <ul>
        <li>
          该属性必须将[=可验证凭证=]或[=可验证演示文稿=]与可分离且可保护的[=证明图=]关联起来。
        </li>
        <li>
          该属性必须定义[=证明图=]所使用的所有术语。例如，该机制可以定义词汇表规范和`@context`文件，就像它们被本规范使用的那样。
        </li>
        <li>
          在[=可验证凭证=]中，该属性必须保护[=默认图=]。
        </li>
        <li>
          在[=可验证演示文稿=]中，该属性必须保护[=演示文稿=]的[=默认图=]以及[=演示文稿=]中每个[=可验证凭证=]相关的[=证明图=]。
        </li>
        <li>
          [[VC-DATA-INTEGRITY]]中定义的`proof`属性可以被嵌入式安全机制使用。
        </li>
      </ul>

      <p>
        安全机制规范应在<a data-cite="?VC-SPECS#securing-mechanisms">安全机制</a>部分[[[?VC-SPECS]]] [[?VC-SPECS]]中注册安全机制。
      </p>

      <p class="note" title="选择安全机制取决于用例">
        有多种可接受的安全机制，本规范并未规定任何特定的安全机制用于[=可验证凭证=]或[=可验证演示文稿=]。制定本规范的工作组确实对两种安全机制选项进行了标准化，分别是：[[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]]和[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]。社区已知的其他安全机制可以在[[[?VC-SPECS]]] [[?VC-SPECS]]的<a data-cite="?VC-SPECS#securing-mechanisms">安全机制</a>部分找到。
      </p>

    </section>

  </section>

  <section>
    <h2>语法</h2>

    <p>
      如<a href="#core-data-model"></a>、<a href="#basic-concepts"></a>和
      <a href="#advanced-concepts"></a>章节所述的数据模型是
      [=可验证凭证=]或[=可验证展示=]的规范结构表示。所有
      序列化都是以特定格式表示该数据模型。本节指定了如何在JSON-LD中实现数据模型
      用于`application/vc+ld+json`，可验证凭证的基本媒体类型。
      尽管语法映射仅提供给JSON-LD，应用程序和
      服务可以使用任何其他能够映射回`application/vc+ld+json`的数据表示语法（如XML、YAML或
      CBOR）。由于[=验证=]和[=验证=]要求是基于
      数据模型，所有序列化语法都必须确定性地
      转换为数据模型以进行处理，[=验证=]或比较。
    </p>

    <p>
      本规范中属性值的预期元数以及保存这些值的
      结果数据类型可能因属性而异。
      如果存在，以下属性表示为单个值：
    </p>

    <ul>
      <li>
        `id` [=属性=]
      </li>
      <li>
        `issuer` [=属性=]
      </li>
      <li>
        `validFrom` [=属性=]
      </li>
      <li>
        `validUntil` [=属性=]。
      </li>
    </ul>

    <p>
      所有其他属性（如果存在）表示为单个值
      或值数组。
    </p>

    <section>
      <h3>JSON-LD</h3>

      <p>
        [[!JSON-LD11]] 是一种基于 JSON 的格式，用于序列化
        <a href="https://www.w3.org/TR/ld-glossary/#linked-data">链接数据</a>。该
        语法旨在轻松集成到已经使用 JSON 的部署系统中，
        并为从 JSON 升级到 [[!JSON-LD11]] 提供平滑升级路径。它主要
        用于在基于 Web 的编程环境中使用链接数据，
        构建可互操作的 Web 服务，并将链接数据存储在基于 JSON 的
        存储引擎中。
      </p>

      <p>
        [[!JSON-LD11]] 在扩展本规范中描述的数据模型时非常有用。数据模型的实例以 JSON-LD 紧凑形式 [[!JSON-LD11]] 编码，并包括 `@context` [=property=]。 
        <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD 上下文</a>
        在 [[!JSON-LD11]] 规范中详细描述，其用法在第 <a href="#contexts"></a> 节和
        第 <a href="#extensibility"></a> 节中进一步阐述。
      </p>

      <p>
        可以使用或组合多个上下文来以惯用的 JSON 表达关于 [=verifiable credentials=] 的任意信息。
        <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD 上下文</a>，
        可在 `https://www.w3.org/ns/credentials/v2` 获取，是一个静态
        文档，永远不会更新，因此可以在客户端下载和缓存。可验证凭据数据模型的关联词汇文档可在 `https://www.w3.org/2018/credentials` 获取。
      </p>

      <p>
        本规范限制了对数据模型的 JSON-LD 表示的使用。JSON-LD <a href="https://www.w3.org/TR/json-ld/#compacted-document-form">紧凑文档形式</a> 必须用于基本媒体类型 `application/vc+ld+json` 中的数据模型的所有表示。
      </p>

      <p>
        如第 <a href="#credential-type-specific-processing"></a> 节中详细阐述的那样，某些软件应用可能不执行通用的 JSON-LD 处理。 [=conforming documents=] 的作者应注意，如果在 `@context` 值中使用 JSON-LD 关键字全局影响 [=verifiable credential=] 或 [=verifiable presentation=] 中的值（例如，通过全局设置 `@base` 关键字），互操作性可能会降低。例如，全局设置这些值可能会在执行 [=credential type-specific processing=] 的实现中触发对 `@context` 值的错误实现的 JSON Schema 检查，而该实现并未期望在 `@context` 值中表达 `@base` 值。
      </p>

      <p>
        为了提高互操作性，建议 [=conforming document=] 作者不要使用在执行 [=credential type-specific processing=] 时不容易检测到的 JSON-LD 功能。这些功能包括：
      </p>

      <ul>
        <li>
          在 `@context` 值中使用 JSON-LD 关键字，全局修改文档值处理，例如全局设置 `@base`
        </li>
        <li>
          在 `@context` 属性中内联声明 JSON-LD 上下文。
        </li>
        <li>
          使用 JSON-LD 术语和类型的完整 URL（例如，
          `https://www.w3.org/2018/credentials#VerifiableCredential` 或
          `https://vocab.example/myvocab#SomeNewType`）而不是使用任何这样的值的简短形式（例如，`VerifiableCredential` 或 `SomeNewType`），这些值要么被明确定义为 JSON-LD `@context` 映射（例如，
          `https://www.w3.org/ns/credentials/v2`），要么通过适用于所有未定义术语的 `@vocab` 功能隐式定义。
        </li>
      </ul>

      </p>

      <section>
        <h3>语法糖</h3>

        <p>
          总的来说，本文档中描述的数据模型和语法设计使得开发者可以复制粘贴示例，将
          [=可验证凭证=]集成到他们的软件系统中。这种方法的设计目标是在确保不同软件系统之间实现全球互操作性的同时，降低进入门槛。本节描述了其中一些方法，这些方法可能不会被大多数开发者注意到，但其细节对于实现者来说是有趣的。[[!JSON-LD11]]提供的最值得注意的语法糖包括：
        </p>

        <ul>
          <li>
            `@id` 和 `@type` 关键字分别被别名为
            `id` 和 `type`，使开发者能够将本规范用作地道的 JSON。
          </li>
          <li>
            数据类型，如整数、日期、度量单位和 URL，会自动进行类型化，以便为需要它们的用例提供更强的类型保证。
          </li>
          <li>
            `verifiableCredential` [=属性=]
            被定义为
            <a href="https://www.w3.org/TR/json-ld11/#graph-containers">JSON-LD 1.1 图形
              容器</a>。这要求创建 [=命名图=]，用于隔离由不同实体声明的数据集。这确保了，例如，每个 [=发行者=] 提供的数据图与 [=持有者=] 提供的数据图之间的适当加密分离，以确保每个图的信息来源得以保留。
          </li>
          <li>
            使用 [[!JSON-LD11]] 1.1 的 `@protected` 属性功能
            确保本规范定义的术语不能被覆盖。这意味着只要在
            [=可验证凭证=] 或 [=可验证展示=] 的顶部进行相同的 `@context` 声明，
            对于数据模型的所有用户理解的术语，无论他们是否使用 [[!JSON-LD11]] 处理器，都可以保证互操作性。
          </li>
        </ul>
      </section>
      <section>
        <h3>列表和数组</h3>
        <p>
          当使用[[JSON-LD11]] 1.1时，列表、数组，甚至列表的列表都是可能的。
          我们鼓励那些希望在需要列表和数组的用例中使用RDF语义的人遵循
          <a href="https://www.w3.org/TR/json-ld11/#lists">JSON-LD 1.1中的列表</a>的指导。
        </p>
        <p>
          一般来说，JSON数组是有序的，而JSON-LD数组在没有使用`@list`关键字的情况下是无序的。
        </p>
        <p class="note">
          虽然可以在不进行任何JSON-LD处理的情况下使用此数据模型，
          但那些这样做并使用数组的人需要注意，除非遵循上述指导，否则无法保证JSON-LD中数组中项目的顺序。这可能导致意外的行为。
        </p>
        <p>
          如果JSON结构或排序对您的应用程序很重要，
          我们建议您通过`@context`将这些元素标记为`@json`。
        </p>
        <pre class="example" title="A @context file that defines a matrix as an embedded JSON data structure">
{
  "@context":
    {
      "matrix": {
        "@id": "https://website.example/vocabulary#matrix",
        "@type": "@json"
      }
    }
}
          </pre>
        <pre class="example" title="A verifiable credential with an embedded JSON data structure">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    "https://website.example/matrix/v1"
  ],
  "id": "http://university.example/credentials/1872",
  "type": [
    "VerifiableCredential",
    "ExampleMatrixCredential"
  ],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "matrix": [
      [1,2,3,4,5,6,7,8,9,10,11,12],
      [1,1,1,1,1,1,1,1,0,0,0,0],
      [0,0,1,1,1,1,1,1,1,0,0,0]
    ]
  }
}
          </pre>
      </section>
    </section>
    <section>
      <h3>媒体类型</h3>

      <p>
        媒体类型，如[[RFC6838]]中定义，标识用于表达
        [=可验证证书=]的语法以及其他有用的处理指南。
      </p>
      <p>
        本规范中用于表达数据模型的语法应由媒体类型标识，且在定义或使用与[=可验证证书=]相关的媒体类型时，应遵循本节概述的约定。
      </p>
      <p>
        与核心数据模型相关的有两种媒体类型，列在<a href="#iana-considerations">考虑因素</a>一节中：
        `application/vc+ld+json` 和 `application/vp+ld+json`。
      </p>
      <p>
        `application/vc+ld+json` 和 `application/vp+ld+json` 媒体类型并不暗示任何特定的安全机制，但是预期将与安全机制一起使用。需要应用一个安全机制来保护这些媒体类型的完整性。不论用于通信的媒体类型是什么，都不要假设内容的安全性。
      </p>

      <section class="informative">
        <h3>媒体类型精度</h3>

        <p>
          有时，开发者或系统可能使用较低精度的媒体类型来传递
          [=可验证证书=]或[=可验证展示=]。使用较低精度媒体类型的一些原因包括：
        </p>

        <ul>
          <li>
            当文件扩展名不可用且无法确定媒体类型时，Web服务器默认为`text/plain`或`application/octet-stream`。
          </li>
          <li>
            开发者添加的文件扩展名导致媒体类型比文件内容的精度低。例如，`.json`可能导致`application/json`的媒体类型，而`.jsonld`可能导致`application/ld+json`的媒体类型。
          </li>
          <li>
            协议要求对于特定交易使用较不精确的媒体类型；例如，`application/json`而不是`application/vp+ld+json`。
          </li>
        </ul>

        <p>
          实施者被敦促在可能从有效载荷确定预期的媒体类型的情况下，不要引发错误，前提是在给定协议中使用的媒体类型是可接受的。例如，如果一个应用程序只接受符合`application/vc+ld+json`媒体类型相关规则的有效载荷，但有效载荷被标记为`application/json`或`application/ld+json`，则应用程序可能执行以下步骤来确定有效载荷是否也符合更高精度的媒体类型：
        </p>

        <ol>
          <li>
            将有效载荷解析为JSON文档。
          </li>
          <li>
            确保`@context`字段的第一个元素匹配`https://www.w3.org/2018/credentials/v2`。
          </li>
          <li>
            如果JSON文档包含一个顶级`type`字段，其中包含一个`VerifiablePresentation`元素，则假设其为`application/vp+ld+json`媒体类型。仍然期望执行额外的后续检查（根据本规范），以确保有效载荷表达了一个符合规范的可验证展示。
          </li>
          <li>
            如果JSON文档包含一个顶级`type`字段，其中包含一个`VerifiableCredential`元素，则假设其为`application/vc+ld+json`媒体类型。仍然期望执行额外的后续检查（根据本规范），以确保有效载荷表达了一个符合规范的可验证证书。
          </li>
        </ol>

        <p>
          在任何可能的情况下，建议实施者对本规范定义的所有有效载荷使用最精确（最高精度）的媒体类型。实施者还建议认识到，用较低精度媒体类型标记的有效载荷并不意味着有效载荷不符合用更高精度类型标记的规则。同样，用较高精度媒体类型标记的有效载荷并不意味着有效载荷将满足与媒体类型相关的要求。接收有效载荷的系统，无论其关联的媒体类型如何，都应执行适当的检查，以确保有效载荷符合在给定系统中使用的要求。
        </p>
      </section>
      <section class="informative">
        <h2>HTTP</h2>
        <p>
          预期HTTP端点将在接受标头和指示内容类型时使用与
          [=可验证证书=]和[=可验证展示=]相关的媒体类型。
        </p>
        <p>
          尽管如此，HTTP服务器可能会忽略接受标头并返回另一种内容类型，或返回错误代码，例如
          <a data-cite="RFC7231#section-6.5.13">`415 Unsupported Media Type`</a>。
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>凭证类型特定处理</h2>

      <p>
        <dfn>通用JSON-LD处理</dfn>被定义为一种利用JSON-LD软件库对[=符合要求的文档=]进行各种<a data-cite="?JSON-LD11#forms-of-json-ld">转换</a>的机制。
        <dfn>凭证类型特定处理</dfn>被定义为一种处理[=符合要求的文档=]的轻量级机制，不需要JSON-LD软件库。一些[=可验证凭证=]的消费者只需要处理特定类型的凭证。这些消费者可以使用凭证类型特定处理而不是通用处理。凭证类型特定处理可能是可取的场景包括但不限于以下几种：
      </p>

      <ul>
        <li>
          在对[=符合要求的文档=]应用安全机制之前，或在验证受安全机制保护的[=符合要求的文档=]之后，确保
          <a href="https://csrc.nist.gov/glossary/term/data_integrity">数据完整性</a>。
        </li>
        <li>
          在执行JSON Schema验证时，如第<a href="#data-schemas"></a>节所述。
        </li>
        <li>
          在将[=可验证凭证=]或[=可验证展示=]序列化或反序列化到存储或索引其内容的系统中。
        </li>
        <li>
          在软件应用程序中操作[=可验证凭证=]或[=可验证展示=]，在执行需要[=通用JSON-LD处理=]的安全机制的验证或验证之后。
        </li>
        <li>
          当应用程序选择使用`+json`结构化媒体类型后缀处理媒体类型时。
        </li>
      </ul>

      <p>
        也就是说，只要消费或生成的文档是[=符合要求的文档=]，就允许进行[=凭证类型特定处理=]。如果需要这种类型的处理，建议实施者遵循以下规则：
      </p>

      <ul>
        <li>
          确保与`@context`属性关联的所有值按预期顺序排列，上下文文件的内容与每个文件的已知良好加密哈希匹配，领域专家认为内容适用于预期的用例。
        </li>
      </ul>

      <p>
        使用静态上下文文件和JSON Schema是实现上述规则的一种可接受方法。在执行[=凭证类型特定处理=]时，这可以确保正确识别、类型化和排序术语。
      </p>

      <p>
        上述规则保证了通过`@context`机制将字面JSON键映射到URI的两种处理机制之间的语义互操作性。虽然[=通用JSON-LD处理=]可以使用其算法中提供的以前未见过的`@context`值来验证所有术语是否正确指定，但执行[=凭证类型特定处理=]的实现只接受特定的`@context`值，这些值是实现事先设计好的，从而在不调用任何JSON-LD API的情况下实现相同的语义。换句话说，通过使用`@context`以导致相同的[=符合要求的文档=]语义的方式，明确说明了数据交换发生的上下文，以便两种处理机制都能使用。
      </p>

    </section>

  </section>

  <section class="normative">
    <h2>算法</h2>

    <p>
      本节包含可供实现使用的算法，以执行常见操作，如验证。以算法表述的一致性要求使用[[[INFRA]]] [[INFRA]]中的规范性概念。有关实现要求的更多指导，请参阅[[[INFRA]]]中关于<a data-cite="INFRA#conformance">一致性</a>的部分。
    </p>

    <p class="issue atrisk" title="在候选推荐之前需要解决的问题">
      与本节相关的有一个问题需要在工作组进入候选推荐阶段之前解决。在这些问题得到解决之前，整个部分都处于风险之中。
    </p>

    <p class="issue" data-number="1377"></p>

    <p class="note" title="实现者可以包括额外的检查、警告和错误。">
      建议实现者注意，本节中的算法包含了实现用于测试对本规范的一致性的最基本的检查集。预计实现将提供额外的检查，为开发人员报告有用的警告，以帮助调试潜在问题。同样，实现可能会提供额外的检查，这可能导致报告新类型的错误，以阻止有害内容。这些额外检查中的任何一个都可能被整合到本规范的未来版本中。
    </p>

    <section class="normative">
      <h3>验证</h3>

      <p>
        本节包含一个算法，该算法是[=符合验证器实现=]在验证[=可验证凭证=]或[=可验证演示=]时必须运行的。该算法接受一串字节（[=字节序列=] |inputBytes|）或一个文档（[=map=] |inputDocument|）和一个媒体类型（[=string=] |inputMediaType|）作为输入，并返回一个包含以下内容的[=map=]：
      </p>

      <ul>
        <li>
          状态（[=boolean=] |status|）
        </li>
        <li>
          一个[=符合的文档=]（[=map=] |document|）
        </li>
        <li>
          媒体类型（[=string=] |mediaType|）
        </li>
        <li>
          与保护机制相关联的验证方法的控制器（[=string=] |controller|）
        </li>
        <li>
          与用于验证保护机制的验证方法相关联的控制器文档（[=map=] |controllerDocument|）
        </li>
        <li>
          零个或多个警告（[=ProblemDetails=]的[=list=] |warnings|）
        </li>
        <li>
          零个或多个错误（[=ProblemDetails=]的[=list=] |errors|）
        </li>
      </ul>

      <p>
        验证算法如下：
      </p>

      <ol class="algorithm">
        <li>
          通过执行以下步骤，确保保护机制已正确保护[=符合的文档=]：
          <ol class="algorithm">
            <li>
              使用|inputMediaType|和[[[?VC-SPECS]]] [[?VC-SPECS]]的<a data-cite="?VC-SPECS#securing-mechanisms">保护机制</a>部分，或实现已知的其他机制，来确定在验证保护机制时使用的加密套件，从而设置|verifyProof|函数。|verifyProof|函数必须实现在<a href="#securing-mechanisms"></a>中描述的接口。
              <div class="issue" title="“确定”的机制正在详细说明">
                目前，工作组担心“确定”的算法可能需要更正式地定义。目前，没有实现遇到确定适当的|verifyProof|算法使用的问题，但工作组正在尝试看看在这里说更多是否值得。可以添加额外的示例语言，说明实现可能有一个可接受的加密套件的允许列表——这些将用作查找要验证的匹配证明的输入。
              </div>
            </li>
            <li>
              将|result|设置为将|inputBytes|和|inputMediaType|传递给|verifyProof|函数的结果。如果调用成功，|result|将包含|status|、|document|、|mediaType|、|controller|、|controllerDocument|、|warnings|和|errors|属性。
            </li>
            <li>
              如果|result|.|status|设置为`false`，则将<a href="#CRYPTOGRAPHIC_SECURITY_ERROR">CRYPTOGRAPHIC_SECURITY_ERROR</a>添加到|result|.|errors|。
            </li>
          </ol>
        </li>
        <li>
          如果|result|.|status|设置为`true`，确保|result|.|document|是一个[=符合的文档=]。如果不是，将|result|.|status|设置为`false`，从|result|中删除|document|属性，并至少向|result|.|errors|添加一个<a href="#MALFORMED_VALUE_ERROR">MALFORMED_VALUE_ERROR</a>。可能包含其他警告和错误以帮助任何调试过程。
        </li>
        <li>
          返回|result|。
        </li>
      </ol>

      <p>
        验证保护机制的状态和验证输入文档是否为[=符合的文档=]的步骤可以按照与上述不同的顺序执行，只要实现对相同的无效输入返回错误。实现可能产生与上述不同的错误。
      </p>

    </section>

    <section>
      <h3>问题详情</h3>

      <p>
        当实现在处理文档时检测到异常时，可以使用<dfn>ProblemDetails</dfn>对象将问题报告给其他软件系统。这些类型对象的接口遵循[[RFC9457]]对数据进行编码。一个[=ProblemDetails=]对象包括以下属性：
      </p>

      <dl>
        <dt>type</dt>
        <dd>
          `type` [=property=] 必须存在，其值必须是一个 [=URL=]，用于标识问题的类型。
        </dd>
        <dt>code</dt>
        <dd>
          `code` [=property=] 是可选的。
          如果存在，其值必须是一个整数，用于标识问题的类型。
          整数代码在只提供整数返回值的系统中很有用。
        </dd>
        <dt>title</dt>
        <dd>
          `title` [=property=] 必须存在，其值应提供一个简短但具体的问题的人类可读字符串。
        </dd>
        <dt>detail</dt>
        <dd>
          `detail` [=property=] 必须存在，其值应提供一个较长的问题的人类可读字符串。
        </dd>
      </dl>

      <p>
        本规范定义了以下问题描述类型和代码：
      </p>

      <dl>
        <dt id="PARSING_ERROR">
          https://www.w3.org/TR/vc-data-model#PARSING_ERROR
          (-64)
        </dt>
        <dd>
          在解析输入时出现错误。
        </dd>
        <dt id="CRYPTOGRAPHIC_SECURITY_ERROR">
          https://www.w3.org/TR/vc-data-model#CRYPTOGRAPHIC_SECURITY_ERROR
          (-65)
        </dt>
        <dd>
          文档的安全机制检测到自创建以来文档内容的修改；
          检测到潜在的篡改。请参阅
          <a href="#verification"></a>部分。
        </dd>
        <dt id="MALFORMED_VALUE_ERROR">
          https://www.w3.org/TR/vc-data-model#MALFORMED_VALUE_ERROR
          (-66)
        </dt>
        <dd>
          与特定[=property=]关联的值格式错误。在[=ProblemDetails=]对象中应提供[=property=]的名称和属性路径。请参阅
          <a href="#verification"></a>部分。
        </dd>
        <dt id="RANGE_ERROR">
          https://www.w3.org/TR/vc-data-model#RANGE_ERROR
          (-67)
        </dt>
        <dd>
          提供的值超出了关联值的预期范围，
          例如，给定的数组索引值大于数组的当前大小。
        </dd>
      </dl>

      <p>
        实现可以通过指定其他类型、代码或属性来扩展[=ProblemDetails=]对象。有关使用此机制的进一步指导，请参阅[[RFC9457]]中的
        <a data-cite="RFC9457#name-extension-members">扩展成员</a>部分。
      </p>

    </section>

  </section>

  <section class="informative">
    <h2>隐私考虑</h2>

    <p>
      本节详细介绍了将可验证凭证数据模型部署到生产环境中的一般隐私考虑和具体隐私影响。
    </p>

    <section class="informative">
      <h3>隐私范围</h3>

      <p>
        重要的是要认识到，隐私有一个范围，从伪名到强烈识别。根据用例，人们对于他们愿意提供的信息以及从所提供的信息中可以得出的信息有不同的舒适度。
      </p>

      <figure>
        <img style="margin: auto; display: block; width: 80%;" src="diagrams/privacy-spectrum.svg" alt="水平条形图，左侧为红色，中间为橙色，右侧为绿色。红色部分的文字为'高度关联（全球ID），例如，政府ID，邮寄地址，信用卡号码'。橙色部分的文字为'通过勾结关联（个人身份信息），例如，姓名，生日，邮政编码'。绿色部分的文字为'不可关联（化名），例如，年龄超过21岁'。">
        <figcaption style="text-align: center;">
          从伪名到完全识别的隐私范围。
        </figcaption>
      </figure>

      <p>
        例如，大多数人在购买酒精时可能希望保持匿名，因为所需的监管检查仅基于一个人是否超过特定年龄。另一方面，对于医生为患者开具的医疗处方，配药的药房需要更强烈地识别医疗专业人员和患者。因此，并没有一种适用于所有用例的隐私方法。隐私解决方案是针对特定用例的。
      </p>

      <p class="note">
        即使对于那些在购买酒精时希望保持匿名的人，也可能仍需要提供照片身份证明以向商家提供适当的保证。商家可能不需要知道您的姓名或其他详细信息（除了您是否超过特定年龄），但在许多情况下，仅提供年龄证明可能仍然不足以满足法规要求。
      </p>

      <p>
        可验证凭证数据模型力求支持完整的隐私范围，并且在任何特定交易的正确匿名程度上不持哲学立场。以下各节为希望避免特定对隐私不友好的场景的实施者提供指导。
      </p>
    </section>

    <section class="informative">
      <h3>软件信任边界</h3>

      <p>
        在本规范所描述的<a href="#ecosystem-overview">生态系统</a>中存在各种信任关系。个人使用Web浏览器时，信任Web浏览器（也称为<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>）不会将他们的个人信息上传到数据代理；同样，填充本规范所描述的生态系统中的角色的实体信任代表这些角色的软件。示例包括以下内容：
      </p>

      <ul>
        <li>
          [=发行者=]的<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>（发行者软件），例如在线教育平台，预期只向发行者确认已完成其教育计划的个人发行[=可验证凭证=]。
        </li>
        <li>
          [=验证者=]的<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>（验证软件），例如招聘网站，预期只允许具有有效验证状态的个人访问，这些个人向平台提供[=可验证凭证=]和[=可验证演示文稿=]。
        </li>
        <li>
          [=持有者=]的<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>（持有者软件），例如数字钱包，预期只有在[=持有者=]同意释放该信息时才会向[=验证者=]泄露信息。
        </li>
      </ul>

      <p>
        上述示例并非详尽无遗，这些角色中的用户还可以期望从他们用来实现目标的软件中获得各种其他功能。简而言之，预计软件将为用户的最佳利益服务，违反该期望将导致信任的破裂，软件将被不违反信任的其他软件替代。强烈建议实施者编写不违反其服务用户信任的软件。实施者还建议在他们创建的软件中提供审计功能，以便用户或受信任的第三方可以检查软件是否确实在为他们的最佳利益服务。
      </p>

      <p>
        建议读者注意，某些软件（例如为单个[=验证者=]和多个[=持有者=]提供服务的网站）可能作为<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>同时为这两个角色提供服务，但可能无法始终同时为所有各方的最佳利益服务。例如，如果该网站检测到多个[=持有者=]之间存在欺诈性[=可验证凭证=]的使用尝试，它可能会向[=验证者=]报告此类异常，这可能被认为不符合犯规的[=持有者=]的最佳利益，但符合[=验证者=]以及任何<em>不</em>犯此类违规行为的[=持有者=]的最佳利益。强烈建议在软件以这种方式运行时，通过诸如网站使用政策之类的机制明确软件是在谁的最佳利益下运行。
      </p>
    </section>

    <section class="informative">
      <h3>个人身份信息</h3>

      <p>
        存储在`credential.credentialSubject`字段中与[=可验证凭证=]相关的数据在与[=验证者=]共享时容易受到隐私侵犯。例如政府发行的标识符、邮寄地址和全名等个人身份信息，可以很容易地用来确定、追踪和关联一个[=实体=]。即使是看似不具有个人身份特征的信息，如出生日期和邮政编码的组合，也具有非常强大的关联和去匿名化能力。
      </p>

      <p>
        强烈建议实施者在[=持有者=]分享这类特征的数据时进行警告。强烈建议[=发行者=]在可能的情况下提供保护隐私的[=可验证凭证=]。例如，当一个[=验证者=]想要确定一个[=实体=]是否已满18岁时，发行`ageOver` [=可验证凭证=]而不是出生日期[=可验证凭证=]。
      </p>

      <p>
        由于[=可验证凭证=]通常包含个人身份信息(PII)，因此强烈建议实施者在存储和传输[=可验证凭证=]时使用保护数据免受非法访问的机制。可以考虑的机制包括传输层安全性(TLS)或其他在传输过程中加密数据的方式，以及加密或数据访问控制机制来保护存储在[=可验证凭证=]中的数据。
      </p>
    </section>

    <section class="informative">
      <h3>基于标识符的关联</h3>

      <p>
        [=可验证凭证=]的[=主体=]使用`credential.credentialSubject.id`字段进行识别。用于识别[=主体=]的标识符在跨多个网络域或长时间使用时，关联风险更大。
      </p>

      <p>
        同样地，披露[=凭证=]标识符（`credential.id`）会导致多个[=验证者=]或[=发行者=]与[=验证者=]串通关联[=持有者=]的情况。如果[=持有者=]希望减少关联，他们应使用允许在[=可验证呈现=]过程中隐藏标识符的[=可验证凭证=]方案。这类方案要求[=持有者=]生成标识符，甚至允许在保持标识符嵌入并签署在[=可验证凭证=]中的同时，将标识符对[=发行者=]进行隐藏。
      </p>

      <p>
        如果在[=可验证凭证=]系统中需要强大的反关联特性，强烈建议标识符采用以下方式之一：
      </p>

      <ul>
        <li>
          绑定到单一来源
        </li>
        <li>
          一次性使用
        </li>
        <li>
          根本不使用，而是用短时、一次性的持票人令牌替代。
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>基于签名的关联</h3>

      <p>
        使用安全机制保护[=凭证=]的内容。当在多个会话或域中使用相同的值且值不变时，用于表示安全机制的值会增加关联风险。
      </p>

      <p>
        如果需要强大的反关联特性，建议使用第三方成对签名、零知识证明或群签名等技术，每次重新生成签名值和元数据。
      </p>

      <p class="note">
        即使在使用反关联签名时，[=可验证凭证=]中可能仍然包含信息，从而使所使用的密码学的反关联特性失效。
      </p>
    </section>

    <section class="informative">
      <h3>基于长期标识符的关联</h3>

      <p>
        [=可验证凭证=]可能包含可用于关联个人的长期标识符。这些类型的标识符包括
        [=主题=]标识符、电子邮件地址、政府颁发的标识符、
        机构颁发的标识符、地址、医疗保健生命体征、
        [=可验证凭证=]特定的JSON-LD上下文，以及许多其他类型的
        长期标识符。
      </p>

      <p>
        向[=持有者=]提供软件的组织应努力识别
        [=可验证凭证=]中包含可用于关联个人的信息的字段，并在此类信息被
        共享时警告[=持有者=]。
      </p>
    </section>

    <section class="informative">
      <h3>基于元数据的关联</h3>

      <p>
        在第<a href="#basic-concepts"></a>节和第<a href="#advanced-concepts"></a>节中描述的不同扩展点的使用
        如果使用特定扩展类型或类型组合的[=颁发者=]数量相对较少，
        可能会成为一种无意识或不希望的关联机制。
        例如，仅由特定国家使用的某些类型的加密技术，或特定司法管辖区使用的吊销格式，
        或特定地区使用的凭证类型，都可以作为一种机制
        降低[=持有者=]在向[=验证者=]选择性披露信息时期望的匿名性。
      </p>

      <p>
        建议[=颁发者=]在颁发预期以匿名方式使用的[=可验证凭证=]时减少基于元数据的关联可能性，
        通过减少可用于缩小[=持有者=]匿名性的扩展类型。使用具有全球应用的凭证类型、
        扩展和技术概况优于具有国家应用的凭证类型，而具有国家应用的凭证类型优于仅具有地方应用的凭证类型。
      </p>
    </section>

    <section class="informative">
      <h3>设备追踪和指纹识别</h3>

      <p>
        存在一些外部机制，用于在互联网和Web上追踪和关联个体，这些机制不包括[=可验证的凭证=]。这些机制包括互联网协议（IP）地址追踪、网络浏览器指纹识别、永久cookies、广告网络追踪器、移动网络位置信息以及应用内全球定位系统（GPS）API。使用[=可验证的凭证=]无法阻止这些其他追踪技术的使用。此外，当这些技术与[=可验证的凭证=]一起使用时，可能会发现新的可关联信息。例如，生日与GPS位置的组合可以被用来在多个网站上强烈关联一个个体。
      </p>

      <p>
        建议尊重隐私的系统在使用[=可验证的凭证=]时阻止这些其他追踪技术的使用。在某些情况下，可能需要在代表[=持有者=]传输[=可验证的凭证=]的设备上禁用追踪技术。
      </p>

      <p>
        Oblivious HTTP协议[[?OHTTP]]是实施者在获取与[=可验证的凭证=]或[=可验证的展示=]相关的外部资源时可能会考虑使用的一种机制。Oblivious HTTP允许客户端向源服务器发送多个请求，而该服务器无法将这些请求链接到该客户端，甚至无法识别这些请求来自同一个客户端，同时只对用于转发消息的节点有限的信任。因此，Oblivious HTTP是一种可以用来减少设备追踪和指纹识别可能性的保护隐私的机制。以下包含了Oblivious HTTP如何使生态系统参与者受益的具体示例。
      </p>

      <ul>
        <li>
          使用数字钱包的[=持有者=]可以减少他们在访问存储在其数字钱包中的[=可验证的凭证=]内的外部链接时被第三方追踪的可能性。例如，数字钱包可能会获取并呈现链接的图像，或者通过获取外部链接的撤销列表来检查[=可验证的凭证=]的有效性。
        </li>
        <li>
          [=验证者=]可以减少向[=发行者=]发出已收到特定[=可验证的凭证=]的信号。例如，[=验证者=]在对[=可验证的凭证=]进行状态检查时，可能会获取外部链接的撤销列表。
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>偏爱抽象声明</h3>

      <p>
        为了让[=可验证凭证=]的接收者在各种情况下使用它们，而无需透露比交易所需更多的个人身份信息（PII），[=发行者=]应考虑将发布在[=凭证=]中的信息限制为预期目的所需的最小集合。避免在[=凭证=]中放置个人身份信息的一种方法是使用一种抽象的[=属性=]，该属性满足[=验证者=]的需求，而无需提供关于[=主题=]的具体信息。
      </p>
      <p>
        例如，本文档使用了`ageOver` [=属性=]，而不是具体的出生日期，后者构成了更强的个人身份信息。如果某个特定市场的零售商通常要求购买者年龄大于某个年龄，那么在该市场受信任的[=发行者=]可能会选择提供一种[=可验证凭证=]，声称[=主题=]已经满足了该要求，而不是提供包含关于具体出生日期的[=声明=]的[=可验证凭证=]。这使得个人顾客可以在不透露具体个人身份信息的情况下进行购买。
      </p>
    </section>

    <section class="informative">
      <h3>数据最小化原则</h3>

      <p>
        当在一个上下文中泄露的信息泄露到另一个上下文时，就会发生隐私侵犯。防止此类侵犯的公认最佳做法是将请求和接收的信息限制到绝对最小必要。这种数据最小化方法在多个司法管辖区中都被法规要求，包括美国的健康保险可携带性和责任法案（HIPAA）和欧盟的一般数据保护条例（GDPR）。
      </p>
      <p>
        对于[=可验证的凭证=]，对[=发行者=]来说，数据最小化意味着将[=可验证的凭证=]的内容限制到潜在的[=验证者=]预期使用所需的最小限度。对于[=验证者=]，数据最小化意味着限制请求或获取服务所需的信息范围。
      </p>
      <p>
        例如，一个包含驾驶员ID号码、身高、体重、生日和家庭地址的驾驶执照是一个[=凭证=]，它包含的信息比确认一个人是否超过某个年龄所需的信息更多。
      </p>

      <p>
        一般认为，[=发行者=]最好将信息原子化或使用允许[=选择性披露=]的签名方案。例如，驾驶执照的[=发行者=]可以发行一个包含驾驶执照上出现的每个属性的[=可验证的凭证=]，以及一组每个[=可验证的凭证=]只包含一个属性（如一个人的生日）的[=可验证的凭证=]。它还可以发行更抽象的[=可验证的凭证=]（例如，只包含`ageOver`属性的[=可验证的凭证=]）。一种可能的适应方式是[=发行者=]提供安全的HTTP端点，用于检索单次使用的[=持有人凭证=]，以促进[=可验证的凭证=]的匿名使用。认为这种做法不切实际或不安全的实施者，应考虑使用[=选择性披露=]方案，以消除在证明时间和减少来自[=发行者=]的时间关联风险的依赖。
      </p>

      <p>
        强烈建议[=验证者=]只请求进行特定交易绝对必要的信息。这至少有两个原因。它：
      </p>

      <ul>
        <li>
          减少了[=验证者=]处理其不需要的高度敏感信息的责任。
        </li>
        <li>
          通过只询问特定交易所需的信息，增强了个人的隐私。
        </li>
      </ul>

      <p class="note">
        虽然可以实践最小披露原则，但在一个会话或多个会话中，对于特定用例，可能无法避免强烈识别个人。本文档的作者无法强调在现实世界场景中满足这一原则有多困难。
      </p>
    </section>

    <section class="informative">
      <h3>持票人凭证</h3>

      <p>
        一个<dfn data-lt="bearer credentials">持票人凭证</dfn>是一种
        增强隐私的信息，例如音乐会门票，它使得持票人凭证的[=持有者=]有权获得特定资源，而无需
        泄露关于[=持有者=]的敏感信息。持票人凭证通常用于低风险的使用场景，其中分享持票人凭证不是
        一个问题，或者不会导致巨大的经济或声誉损失。
      </p>

      <p>
        [=可验证凭证=]中的[=持票人凭证=]是通过不指定[=主题=]标识符实现的，该标识符使用
        `id` [=属性=]表示，它嵌套在
        `credentialSubject` [=属性=]中。例如，以下
        [=可验证凭证=]是一个[=持票人凭证=]：
      </p>

      <pre class="example nohighlight vc" title="Usage of issuer properties"
        data-vc-vm="https://university.example/issuers/14#keys-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/temporary/28934792387492384",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2017-10-22T12:23:48Z",
  "credentialSubject": {
    <span class="comment">// note that the 'id' property is not specified for bearer credentials</span>
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
          虽然[=持票人凭证=]可以增强隐私，但必须精心设计，以免意外泄露比[=持有人=]
          预期的更多信息。例如，在多个站点上重复使用相同的
          [=持票人凭证=]使这些站点可能串通起来不当地跟踪或关联[=持有人=]。同样，
          可能看似非识别的信息，如出生日期和邮政编码，在同一[=持票人凭证=]或会话中一起使用时
          可以用于统计识别个人。
        </p>
  
        <p>
          [=发行人=]应确保[=持票人凭证=]提供增强隐私的好处，包括：
        </p>
  
        <ul>
          <li>
            尽可能实现一次性使用。
          </li>
          <li>
            不包含个人识别信息。
          </li>
          <li>
            不会过度关联。
          </li>
        </ul>
  
        <p>
          如果发行或请求包含敏感信息的[=持票人凭证=]，或者在一个或多个会话中组合两个或多个[=持票人凭证=]时存在关联风险，
          [=持有人=]应被其软件警告。虽然检测到所有关联风险可能是不可能的，但某些风险肯定是可以检测到的。
        </p>
  
        <p>
          [=验证者=]不应请求可用于不当关联[=持有人=]的[=持票人凭证=]。
        </p>
    </section>

    <section class="informative">
      <h3>验证</h3>

      <p>
        在处理[=可验证的凭证=]时，[=验证者=]
        在依赖它们之前会评估任何相关的[=声明=]。只要满足
        进行验证的[=验证者=]的要求，这种评估可以以任何期望的方式进行。
        许多验证者将执行附录<a href="#validation-0"></a>中列出的检查，以及各种
        特定的业务流程
        检查，例如：
      </p>

      <ul>
        <li>
          [=持有者=]的专业许可状态。
        </li>
        <li>
          许可证续期或撤销的日期。
        </li>
        <li>
          个人的子资格。
        </li>
        <li>
          [=持有者=]与[=持有者=]试图互动的[=实体=]
          之间是否存在关系。
        </li>
        <li>
          与[=持有者=]相关联的地理位置信息。
        </li>
      </ul>

      <p>
        执行这些检查的过程可能会导致信息泄露，从而侵犯[=持有者=]的隐私。例如，一个简单
        的操作，如检查一个配置不当的撤销列表，可以
        通知[=发行者=]某个特定的业务可能正在与[=持有者=]互动。这可能
        使[=发行者=]在不知情的情况下串谋关联个人。
      </p>

      <p>
        建议[=发行者=]在
        [=验证=]过程中不要使用可能导致隐私侵权的机制，如每个[=凭证=]都有唯一的撤销列表。为[=持有者=]提供软件的组织应当警告，当[=凭证=]包含可能在验证过程中导致隐私侵权的信息时。[=验证者=]应考虑拒绝可能产生隐私侵权或促成不良隐私实践的[=凭证=]。
      </p>
    </section>

    <section class="informative">
      <h3>存储提供商和数据挖掘</h3>

      <p>
        当一个[=持有者=]从[=发行者=]那里收到一份[=可验证的凭证=]时，这份[=可验证的凭证=]需要存储在某个地方（例如，在一个[=凭证=]仓库中）。[=持有者=]需要注意，[=可验证的凭证=]中的信息具有敏感性和高度个性化，使其成为数据挖掘的高价值目标。宣传免费存储[=可验证凭证=]的服务实际上可能在挖掘个人数据，并将其出售给希望建立个人和组织个性化档案的组织。
      </p>
      <p>
        [=持有者=]需要了解他们的[=凭证=]仓库的服务条款，特别是针对那些将其[=可验证凭证=]存储在服务提供商处的用户的关联和数据挖掘保护措施。
      </p>
      <p>
        针对数据挖掘和分析的一些有效缓解措施包括使用：
      </p>

      <ul>
        <li>
          不将您的信息出售给第三方的服务提供商。
        </li>
        <li>
          对[=可验证凭证=]进行加密的软件，以使服务提供商无法查看[=凭证=]的内容。
        </li>
        <li>
          将[=可验证凭证=]存储在您控制的设备上的软件，该软件不会在超出您的期望范围内上传或分析您的信息。
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>证书的聚合</h3>

      <p>
        持有关于同一[=主题=]的两份信息几乎总是会揭示出比两份信息之和更多的关于[=主题=]的信息，即使这些信息是通过不同的渠道传递的。[=可验证证书=]的聚合是一个隐私风险，生态系统中的所有参与者都需要意识到数据聚合的风险。
      </p>

      <p>
        例如，如果两个[=持有者证书=]，一个是电子邮件地址，另一个声明[=持有者=]已经超过21岁，都在多个会话中提供，那么信息的[=验证者=]现在就拥有了该个体的唯一标识符以及与年龄相关的信息。现在很容易为[=持有者=]创建和建立一个档案，以便随着时间的推移泄露出越来越多的信息。在彼此串通的多个网站上也可以进行[=证书=]的聚合，这会导致隐私侵犯。
      </p>

      <p>
        从技术角度来看，防止信息聚合是一个非常难以解决的隐私问题。虽然新的加密技术，如零知识证明，被提出来解决聚合和关联问题，但是长期存在的标识符和浏览器跟踪技术甚至可以打败最现代的加密技术。
      </p>

      <p>
        解决关联或聚合的隐私问题的解决方案往往不是技术性的，而是由政策驱动的。因此，如果一个[=持有者=]不希望他们的信息被聚合，他们必须在他们传输的[=可验证的展示=]中表达这一点。
      </p>
    </section>

    <section class="informative">
      <h3>使用模式</h3>

      <p>
        尽管我们竭尽全力确保隐私，但实际使用[=可验证证书=]可能会导致去匿名化和隐私丧失。这种关联可能发生在以下情况：
      </p>

      <ul>
        <li>
          相同的[=可验证证书=]被呈现给同一个[=验证者=]多次。[=验证者=]可以推断出[=持有者=]是同一个人。
        </li>
        <li>
          相同的[=可验证证书=]被呈现给不同的[=验证者=]，这些[=验证者=]串通起来或者第三方可以访问来自两个[=验证者=]的交易记录。一个观察者可以推断出呈现[=可验证证书=]的个体在两个服务中是同一个人。也就是说，这些账户由同一个人控制。
        </li>
        <li>
          [=证书=]的[=主体=]标识符在多个[=演示文稿=]或[=验证者=]中都指向同一个[=主体=]。即使呈现的[=证书=]不同，如果[=主体=]标识符相同，[=验证者=]（以及那些可以访问[=验证者=]日志的人）可以推断出[=证书=]的[=持有者=]是同一个人。
        </li>
        <li>
          [=证书=]中的基本信息可以用于在各种服务中识别个人。在这种情况下，使用来自其他来源的信息（包括由[=持有者=]直接提供的信息），[=验证者=]可以使用[=证书=]中的信息将个人与现有的个人资料进行关联。例如，如果[=持有者=]呈现包含邮政编码、年龄和性别的[=证书=]，[=验证者=]可以将该[=证书=]的[=主体=]与已建立的个人资料进行关联。有关更多信息，请参阅[[DEMOGRAPHICS]]。
        </li>
        <li>
          将[=证书=]的标识符传递给一个集中式撤销服务器。集中式服务器可以在交互过程中关联[=证书=]的使用。例如，如果以这种方式使用[=证书=]作为年龄证明，集中式服务可以知道[=证书=]呈现的所有地方（所有的酒类商店、酒吧、成人商店、彩票购买等）。
        </li>
      </ul>

      <p>
        在某种程度上，可以通过以下方式来减轻这种去匿名化和隐私丧失：
      </p>

      <ul>
        <li>
          使用全球唯一标识符作为任何给定[=证书=]的[=主体=]，并且永远不要重复使用该[=证书=]。
        </li>
        <li>
          如果[=证书=]支持撤销，使用全球分布式服务进行撤销。
        </li>
        <li>
          设计不依赖于提交[=证书=] ID 的撤销 API。例如，使用撤销列表而不是查询。
        </li>
        <li>
          避免将个人身份信息与任何特定的长期[=主体=]标识符关联起来。
        </li>
      </ul>

      <p>
        人们理解这些缓解技术并不总是实用，甚至与必要的使用兼容。有时候关联是一种要求。
      </p>
      <p>
        例如，在某些处方药监测计划中，使用监测是一项要求。执法实体需要确认个人没有欺骗系统以获得多个受控药物的处方。这种法定或监管需求优先于个人隐私关切。
      </p>

      <p>
        [=可验证证书=]还将被用于在服务之间有意识地关联个人，例如，在使用通用角色登录多个服务时，以便在这些服务上的所有活动都有意识地与同一个个人关联。只要每个服务都按照预期的方式使用关联，这就不是一个隐私问题。
      </p>

      <p>
        [=证书=]使用的隐私风险发生在因呈现[=证书=]而产生意外或意料之外的关联时。
      </p>
    </section>

    <section class="informative">
      <h3>与错误的一方分享信息</h3>

      <p>
        当一个[=持有者=]选择与[=验证者=]分享信息时，
        可能的情况是[=验证者=]恶意行事并请求
        可能用于伤害[=持有者=]的信息。例如，
        [=验证者=]可能会要求提供银行账号，然后可以使用
        其他信息来欺诈[=持有者=]或银行。
      </p>

      <p>
        [=发行者=]应努力将尽可能多的信息标记化，
        这样即使[=持有者=]不小心将[=凭证=]传输给错误的
        [=验证者=]，情况也不会太糟。
      </p>

      <p>
        例如，不是为了检查个人的银行余额而包含银行账号，
        而是提供一个令牌，使[=验证者=]能够检查余额是否超过某个金额。
        在这种情况下，银行可以向[=持有者=]发出包含余额检查令牌的
        [=可验证凭证=]。然后，[=持有者=]将
        [=可验证凭证=]包含在[=可验证的演示=]中，并使用数字签名将
        令牌绑定到信用检查机构。然后，[=验证者=]可以将他们的
        数字签名包裹在[=可验证的演示=]中，并将其交还给发行者以动态检查
        账户余额。
      </p>

      <p>
        使用这种方法，即使[=持有者=]与错误的一方分享了账户余额令牌，
        攻击者也无法发现银行账号，也无法知道账户中的确切金额。并且考虑到
        反签名的有效期，攻击者也无法获得令牌的访问权限超过几分钟。
      </p>
    </section>

    <section class="informative">
      <h3>数据盗窃</h3>

      <p>
        在[=可验证凭证=]和[=可验证展示=]中表达的数据具有价值，因为它们包含由值得信赖的第三方（如[=发行者=]）或个人（如[=持有者=]和[=主体=]）所作的真实陈述。存储这些数据会产生攻击者有动机突破以获取和交换数据以获得经济利益的敏感数据蜜罐。
      </p>
      <p>
        建议[=发行者=]保留发行[=可验证凭证=]给[=持有者=]以及管理这些凭证的状态和撤销所需的最少数据量。
      </p>
      <p>
        建议[=持有者=]使用在传输和休息时适当加密其数据的实现，并以无法轻易从硬件设备中提取的方式保护敏感材料（如加密秘密）。此外，建议[=持有者=]仅在他们控制的设备上存储和操作他们的数据，远离集中式系统，以减少对他们数据的攻击可能性，或者如果攻击成功，减少大规模盗窃的可能性。
      </p>
      <p>
        建议[=验证者=]仅要求进行特定交易所需的数据，并且不要保留超出任何特定交易需求的任何数据。
      </p>
      <p>
        建议监管者重新考虑审计要求，以便可以使用更多隐私保护机制来实现类似的执法和审计能力。例如，以收集和长期保留个人身份信息为目的的审计型法规可能会对个人和组织造成伤害，如果这些信息被攻击者窃取并访问。本规范描述的技术使[=持有者=]能够更容易地证明他们自己和他人的属性，从而减少了[=验证者=]对长期数据保留的需求。替代方案包括保留收集和检查信息的日志，以及随机测试以确保合规制度按预期运行。
      </p>
    </section>

    <section class="informative">
      <h3>声明发行频率</h3>

      <p>
        如第<a href="#usage-patterns"></a>节详述，使用模式可以与某些类型的行为相关联。当[=持有者=]在不知道[=发行者=]的情况下使用[=可验证凭证=]时，这种关联的一部分就被减轻了。然而，[=发行者=]可以通过使其[=可验证凭证=]的有效期短暂且自动更新来破坏这种保护。
      </p>

      <p>
        例如，`ageOver` [=可验证凭证=]对于进入酒吧是有用的。如果[=发行者=]发行这样一个具有非常短的有效期和自动更新机制的[=可验证凭证=]，那么[=发行者=]可能会以一种对[=持有者=]产生负面影响的方式关联[=持有者=]的行为。
      </p>

      <p>
        为[=持有者=]提供软件的组织应该警告他们，如果他们反复使用具有短生命周期的[=凭证=]，可能会导致行为关联。[=发行者=]应避免以一种使他们能够关联使用模式的方式发行[=凭证=]。
      </p>
    </section>

    <section class="informative">
      <h3>优先使用一次性凭证</h3>

      <p>
        理想的尊重隐私的系统只需要由[=持有者=]披露与[=验证者=]互动所需的信息。
        [=验证者=]随后记录披露要求得到满足，并忘记披露的任何敏感信息。在许多情况下，
        诸如监管负担等相互竞争的优先事项，阻止了这一理想系统的实施。在其他情况下，长期存在的标识符阻止了一次性使用。然而，
        任何[=可验证凭证=]生态系统的设计都应力求尽可能尊重隐私，尽可能优先使用一次性
        [=可验证凭证=]。
      </p>

      <p>
        使用一次性[=可验证凭证=]带来了几个好处。第一个好处是对[=验证者=]，他们可以确保
        [=可验证凭证=]中的数据是最新的。第二个好处是对[=持有者=]，他们知道如果
        [=可验证凭证=]中没有长期存在的标识符，那么[=可验证凭证=]本身就不能用于
        在线跟踪或关联他们。最后，攻击者没有可窃取的东西，使整个生态系统更安全地运行。
      </p>
    </section>

    <section class="informative">
      <h3>私密浏览</h3>

      <p>
        在理想的私密浏览场景中，不会泄露任何个人身份信息（PII）。因为许多
        [=凭证=]包含个人身份信息，为[=持有者=]提供软件的组织应该警告他们，如果他们希望在私密浏览模式下使用
        [=凭证=]和[=展示=]，可能会泄露这些信息。由于每个浏览器厂商处理私密浏览的方式不同，有些浏览器可能根本没有这个功能，所以
        实施者需要了解这些差异并相应地实施解决方案。
      </p>
    </section>

    <section class="informative">
      <h3>发行者合作对隐私的影响</h3>

      <p>
        无法过分强调[=可验证凭证=]对[=发行者=]的高度信任的依赖性。[=持有者=]可能利用可能的隐私保护的程度通常强烈依赖于[=发行者=]对这些功能的支持。在许多情况下，利用零知识证明、数据最小化技术、持有者凭证、抽象声明以及防止基于签名的关联的隐私保护，需要[=发行者=]积极支持这些能力并将它们纳入他们发行的[=可验证凭证=]中。
      </p>
      <p>
        还应注意，除了依赖[=发行者=]参与提供帮助保护[=持有者=]和[=主题=]隐私的[=可验证凭证=]能力外，[=持有者=]还依赖[=发行者=]不故意破坏隐私保护。例如，[=发行者=]可能使用一种保护免受基于签名的关联的签名方案来签署[=可验证凭证=]。这将保护[=持有者=]免受由于签名值在[=验证者=]之间共享而产生的关联。然而，如果[=发行者=]为每个发行的[=凭证=]创建一个唯一的密钥，那么[=发行者=]可能能够跟踪[=凭证=]的[=展示=]，无论[=验证者=]是否有能力这样做。
      </p>
      <p>
        除了前述的隐私保护，[=发行者=]可能使用，[=发行者=]还需要注意他们在发行[=凭证=]时使用的与标识符和声明类型相关的数据泄漏。这的一个例子可能是[=发行者=]发行驾驶执照，这既揭示了他们有管辖权的地点，也揭示了[=主题=]的居住地。[=验证者=]可能利用这一点，通过请求[=凭证=]来检查[=主题=]是否有驾驶执照，实际上他们对凭证的元数据<em>关于</em>感兴趣，例如哪个[=发行者=]发行了凭证，以及可能被[=发行者=]泄漏的与主题的家庭地址等相关的间接信息。为了减轻这种泄漏，[=发行者=]可能选择使用常见的标识符来掩盖特定的位置信息或其他敏感的元数据；例如，使用一个在州或国家级别共享的发行者标识符，而不是在县、城市、镇或其他较小的市政单位级别。此外，[=验证者=]可以使用[=持有者=]的声明机制来保护隐私，通过提供证明一个[=发行者=]存在于一组受信任的实体中，而无需公开具体的[=发行者=]。
      </p>
    </section>
  </section>

  <section class="informative">
    <h2>安全注意事项</h2>

    <p>
      在处理本规范描述的数据时，[=发行者=]、[=持有者=]和[=验证者=]应注意一些安全问题。忽略或不理解本节的含义可能导致安全漏洞。
    </p>

    <p>
      虽然本节试图强调一系列广泛的安全注意事项，但这并不是一个完整的列表。实施者在使用本规范中概述的技术实施关键任务系统时，应寻求安全和加密专业人士的建议。
    </p>

    <section class="informative">
      <h3>加密套件和库</h3>

      <p>
        本规范中描述的数据模型的某些方面可以通过使用加密来保护。实施者需要了解用于创建和处理[=凭证=]和[=展示=]的加密套件和库。实施和审计加密系统通常需要丰富的经验。有效的
        <a href="https://en.wikipedia.org/wiki/Red_team">红队</a>也可以帮助消除安全审查中的偏见。
      </p>

      <p>
        加密套件和库有一定的使用寿命，最终会受到新攻击和技术进步的影响。生产质量的系统需要考虑到这一点，并确保存在机制来轻松且主动地升级过期或损坏的加密套件和库，以及使现有[=凭证=]失效和替换。定期监控对于确保处理[=凭证=]的系统的长期可行性非常重要。
      </p>
    </section>

    <section class="informative">
      <h3>密钥管理</h3>
      <p>
        大多数数字签名算法的安全性，用于保护[=可验证凭证=]和[=可验证展示=]，取决于其<em>私有签名密钥</em>的质量和保护。关于加密密钥管理的指导是一个很大的主题，建议读者参考[[NIST-SP-800-57-Part-1]]以获得更详细的建议和讨论。正如[[FIPS-186-5]]和[[NIST-SP-800-57-Part-1]]强烈建议的那样，私有签名密钥不应用于多种用途，例如，私有签名密钥不应用于加密以及签名。
      </p>
      <p>
        [[NIST-SP-800-57-Part-1]]强烈建议私有签名密钥和<em>公共验证密钥</em>具有有限的<em>加密周期</em>，其中<em>加密周期</em>是“合法实体授权使用特定密钥的时间跨度，或者给定系统的密钥将保持有效。”[[NIST-SP-800-57-Part-1]]针对不同情况下不同密钥类型的加密周期提供了广泛的指导，并通常建议私有签名密钥的加密周期为1-3年。
      </p>
      <p>
        为应对潜在的私钥泄露，[[NIST-SP-800-57-Part-1]]提供了保护措施、减少损害和撤销的建议。尽管本节主要关注私有签名密钥的安全性，但[[NIST-SP-800-57-Part-1]]还强烈建议在使用所有[=验证材料=]之前确认其有效性。
      </p>
    </section>

    <section class="informative">
      <h3>内容完整性保护</h3>

      <p>
        [=可验证凭证=]通常包含指向位于
        [=可验证凭证=]本身之外的数据的URL。链接到存在于
        [=可验证凭证=]之外的内容，如图片、JSON-LD上下文、JSON模式，
        以及其他机器可读数据，通常无法防止篡改，
        因为数据位于<a href="#securing-mechanisms">安全机制</a>之外的
        [=可验证凭证=]。例如，通过解引用以下突出显示的链接可检索的内容没有完整性保护，但
        可能应该有：
      </p>

      <pre class="example nohighlight" title="Non-content-integrity protected links">
{
  "@context": [
    <span class="highlight">"https://www.w3.org/ns/credentials/v2"</span>,
    <span class="highlight">"https://www.w3.org/ns/credentials/examples/v2"</span>
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://university.example/images/58473"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

        <p>
          尽管本规范没有推荐任何特定的内容完整性保护，但建议希望确保链接到内容具有完整性保护的文档作者使用强制内容完整性的URL方案。
        </p>

      <pre class="example nohighlight" title="Content-integrity protection for links to external data">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2<span class="highlight">?hl=z3aq31uzgnZBuWNzUB</span>",
    "https://www.w3.org/ns/credentials/examples/v2<span class="highlight">?hl=z8guWNzUBnZBu3aq31</span>"
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://example.com/image"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

        <p class="note">
          上述JSON-LD上下文是否需要保护是有争议的，因为预期生产实现将配备重要的JSON-LD上下文的静态副本。
        </p>
  
        <p>
          虽然上述示例是实现内容完整性保护的一种方式，但对于某些应用程序，可能有其他更适合的解决方案。实施者被敦促理解链接到未受内容完整性保护的外部机器可读内容可能如何导致对他们的应用程序的成功攻击。
        </p>

    </section>

    <section class="informative">
      <h3>未签名声明</h3>

      <p>
        本规范允许生成没有通过签名或任何形式的证明来保护的[=credentials=]。这类[=credentials=]通常用于中间存储或自我声明信息，类似于在网页上填写表单。实现者应该注意，这类[=credentials=]不是[=verifiable=]的，因为作者身份要么未知，要么不可信。
      </p>
    </section>

    <section class="informative">
      <h3>中间人（MITM）、重放和克隆攻击</h3>

      <p>
        数据模型本身并不能防止
        <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人（MITM）</a>，
        <a href="https://en.wikipedia.org/wiki/Replay_attack">重放</a>和
        <a href="https://en.wikipedia.org/wiki/Spoofing_attack">欺骗</a>攻击。
        在线和离线使用场景都可能受到这类攻击的影响，其中对手在传输或存储过程中截取、修改、重用和/或复制
        [=可验证凭证=]数据。
      </p>
      <h4>中间人（MITM）攻击</h4>

      <p>
        [=验证者=]可能需要确保它是[=可验证展示=]的预期接收者，而不是
        <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">
          中间人攻击</a>的目标。一些<a href="#securing-mechanisms">安全
          机制</a>，如[[VC-JOSE-COSE]]或[[VC-DATA-INTEGRITY]]，提供了指定[=展示=]的预期受众或域的选项，
        这有助于降低这种风险。
      </p>
      <p>
        诸如令牌绑定[[RFC8471]]之类的替代方法，将请求
        [=可验证展示=]与响应绑定，可以保护协议。
        任何未加密的协议都容易受到中间人攻击。
      </p>
      <h4>重放攻击</h4>

      <p>
        [=验证者=]可能希望确保[=可验证展示=]不会被使用超过一定次数。例如，表示活动门票的[=可验证
        凭证=]，如果多次呈现，可能允许多个人进入，从而破坏了门票在发行方看来的目的。为防止此类攻击，
        [=持有人=]可以使用诸如在展示过程中包含
        <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">随机数</a>或添加过期时间戳以减少攻击窗口的技术。
      </p>
      <h4>欺骗攻击</h4>

      <p>
        [=验证者=]有充分的利益知道[=持有人=]有权呈现[=可验证展示=]内的声明。
        虽然数据模型概述了[=可验证凭证=]所需的结构和数据元素，但它没有包含确定呈现[=凭证=]的授权的机制。为解决这个问题，
        实现者可能需要探索补充方法，如将[=可验证凭证=]绑定到强认证机制或使用
        [=可验证展示=]中的附加属性
        以实现控制证明。
      </p>
    </section>
    <section class="informative">
      <h3>捆绑相关声明</h3>

      <p>
        对于[=发行者=]，将信息原子化到[=凭证=]中，或使用允许选择性披露的签名方案被认为是最佳实践。在原子化的情况下，如果[=发行者=]没有安全地进行操作，[=持有者=]可能会以[=发行者=]未预期的方式将不同的[=凭证=]捆绑在一起。
      </p>

      <p>
        例如，一所大学可能向一个人发放两个[=可验证的凭证=]，每个凭证包含两个[=属性=]，这两个属性必须一起使用，以指定该人在某个“部门”的“角色”，例如“计算机系”的“工作人员”或“经济系”的“研究生”。如果将这些[=可验证的凭证=]原子化，将这些[=属性=]中的每一个分别放入每一个[=凭证=]中，那么大学将向这个人发放四个[=凭证=]，每个凭证包含以下一个称号：“工作人员”、“研究生”、“计算机系”和“经济系”。[=持有者=]可能会将“工作人员”和“经济系”的[=可验证凭证=]转移到[=验证者=]，这两个凭证一起构成了一个错误的[=声明=]。
      </p>
    </section>

    <section class="informative">
      <h3>高度动态信息</h3>

      <p>
        当为高度动态信息发放[=可验证凭证=]时，实施者应确保有效期设置得当。有效期长于[=可验证凭证=]预期使用时间范围可能会产生可利用的安全漏洞。有效期短于[=可验证凭证=]所表达的信息预期使用时间范围，会给[=持有者=]和[=验证者=]带来负担。因此，为[=可验证凭证=]设置适合用例和所包含信息预期使用寿命的有效期非常重要。
      </p>
    </section>

    <section class="informative">
      <h3>设备盗窃和冒充</h3>

      <p>
        当[=可验证的凭证=]存储在设备上，且该设备丢失或被盗时，攻击者可能能够利用受害者的[=可验证的凭证=]获得对系统的访问权限。缓解这种类型攻击的方法包括：
      </p>

      <ul>
        <li>
          在设备上启用密码、PIN码、图案或生物识别屏幕解锁保护。
        </li>
        <li>
          为[=凭证=] [=仓库=]启用密码、生物识别或多因素认证。
        </li>
        <li>
          在访问加密密钥时启用密码、生物识别或多因素认证。
        </li>
        <li>
          使用单独的基于硬件的签名设备。
        </li>
        <li>
          上述所有或任何组合。
        </li>
      </ul>

      <p>
        此外，冒充的实例可以以各种形式出现，包括[=实体=]试图否认其行为的情况。提高[=可验证凭证=]领域的信任和安全级别不仅仅是避免冒充；它涉及到非否认机制的实施。这些机制巩固了[=实体=]对其行为或交易的责任，从而加强了问责制并阻止了恶意行为。实现非否认是一项多方面的努力，包括从<a href="#securing-mechanisms">安全机制</a>、持有证明和各种协议中的认证方案等一系列技术。
      </p>
    </section>
    <section class="informative">
      <h3>可接受的使用</h3>

      <p>
        确保[=实体=]的行为，如[=展示=]，与这些行为的预期目的保持一致，是非常重要的。这涉及到有权使用[=可验证的凭证=]，以及按照其指定的范围和目标使用[=凭证=]。在这个背景下出现的两个关键问题是<i>未经授权的使用</i>和<i>不适当的使用</i>。
      </p>
      <h4>未经授权的使用</h4>
      <p>
        任何实体试图在未经授权的情况下使用[=可验证的凭证=]和[=可验证的展示=]，都可以被视为未经授权的使用。未经授权使用的一种类型是<i>保密性违规</i>。考虑一个例子，一个[=持有者=]与[=验证者=]分享一个[=可验证的展示=]，以确定他们的年龄和居住状态。如果[=验证者=]然后在未经适当同意的情况下利用[=持有者=]的数据，比如将数据卖给数据经纪人，那么这将构成对数据的未经授权的使用，违反了[=持有者=]在交易中可能对隐私的期望。
      </p>
      <p>
        同样，[=发行者=]可以使用
        <a href="#terms-of-use">termsOfUse</a>属性来规定凭证可能如何和何时被使用。一个[=持有者=]在`termsOfUse`定义的范围之外使用凭证将被视为未经授权的使用。
      </p>
      <p class="note">
        需要进一步研究如何确定[=持有者=]在[=展示=]后可以如何声明和执行他们的数据的授权使用。
      </p>
      <h4>不适当的使用</h4>
      <p>
        虽然有效的加密签名和成功的状态检查表明[=凭证=]的可靠性，但它们并不表明所有[=凭证=]在所有情况下都是可互换的。对于[=验证者=]来说，也必须<a href="#validation-0">验证</a>任何可能相关的声明，考虑到声明的来源和性质以及凭证所呈现的特权或服务。
      </p>
      <p>
        例如，在需要认证的医疗诊断的情况下，一个自我声明的[=凭证=]携带必要的数据可能不足够，因为它缺乏来自权威医疗来源的有效性。为了确保[=凭证=]的适当使用，各方都被敦促在他们预期的应用的特定上下文中评估<a href="#dfn-credential">凭证的</a>相关性和权威性。
      </p>
    </section>
  </section>

  <section class="informative">
    <h2>可访问性考虑</h2>

    <p>
      在处理本规范中描述的数据时，实现者应注意一些可访问性问题。与实现任何Web标准或协议一样，忽略可访问性问题会导致这些信息对大部分人口无法使用。遵循可访问性指南和标准，如[[WCAG21]]，确保所有人，无论能力如何，都可以使用这些数据。在建立使用加密的系统时，这一点尤为重要，因为历史上这些系统对辅助技术造成了问题。
    </p>

    <p>
      本节详细介绍了在使用此数据模型时需要考虑的一般可访问性问题。
    </p>

    <section class="informative">
      <h3>数据优先方法</h3>

      <p>
        当今使用的许多实体[=凭证=]，如政府身份证件，具有较差的可访问性特征，包括但不限于小字体、依赖小型和高分辨率图像以及对视力障碍者没有便利设施。
      </p>

      <p>
        在使用此数据模型创建[=可验证凭证=]时，建议数据模型设计者采用<em>数据优先</em>方法。例如，在使用数据或图形图像来描述[=凭证=]时，设计者应以机器可读的方式表达图像的每个元素，如机构名称或专业[=凭证=]，而不是依赖观众对图像的解释来传达这些信息。采用数据优先方法是首选，因为它为为不同能力的人构建不同界面提供了基本元素。
      </p>
    </section>
  </section>

  <section class="informative">
    <h2>国际化考虑因素</h2>

    <p>
      实施者被建议在发布本规范中描述的数据时，需要注意一些国际化的考虑因素。
      就像任何网络标准或协议的实施一样，忽视国际化会使数据在各种不同的语言和社会中的生产和消费变得困难，这限制了规范的适用性，并显著降低了其作为标准的价值。
    </p>

    <p>
      实施者强烈建议阅读
      <em>网络上的字符串：语言和方向元数据</em>文档
      [[STRING-META]]，该文档由W3C国际化活动发布，详细阐述了提供可靠的文本元数据以支持国际化的需要。对于最新的国际化考虑因素，实施者也被强烈建议阅读可验证的凭证实施指南[[VC-IMP-GUIDE]]文档。
    </p>

    <p>
      本节概述了在使用此数据模型时需要考虑的一般国际化因素，并旨在突出实施者可能感兴趣的阅读<em>网络上的字符串：语言和方向元数据</em>文档[[STRING-META]]的特定部分。
    </p>

    <section>
      <h3>语言和基础方向</h3>

      <p>
        强烈建议数据发布者阅读<em>网络上的字符串：语言和方向元数据</em>文档[[STRING-META]]中的跨语法表达部分，以确保能够在多种表达语法中，如[[JSON-LD11]]，[[JSON]]和CBOR [[?RFC7049]]，表达语言和<dfn data-cite="i18n-glossary">基础方向</dfn>信息。
      </p>

      <p>
        一般的设计模式是在表达带有语言标签的文本字符串时，使用以下标记模板，并可选地指定一个特定的基础方向。
      </p>

      <pre class="example nohighlight" title="自然语言字符串的设计模式">
"myProperty": {
  "@value": "<span class="highlight">字符串值</span>",
  "@language": "LANGUAGE"
  "@direction": "DIRECTION"
}
        </pre>

      <p>
        当语言值对象用于替代字符串值时，该对象必须包含一个`@value`属性，其值为字符串，并应包含一个`@language`属性，其值为一个由[[BCP47]]定义的格式良好的`Language-Tag`字符串，并可能包含一个`@direction`属性，其值为由[[JSON-LD11]]中的`@direction`属性定义的[=base direction=]字符串。语言值对象不得包含`@value`，`@language`和`@direction`之外的任何其他键。
      </p>

      <p>
        使用上述设计模式，以下示例表达了一本书的标题，该书使用英语，但未指定文本方向。
      </p>

      <pre class="example nohighlight" title="将自然语言文本表达为英语">
"title": {
  "@value": "<span class="highlight">HTML和CSS：设计和创建网站</span>",
  "@language": "en"
}
        </pre>

      <p>
        下一个示例使用了类似的标题，但是用阿拉伯语表达，并且基础方向为从右到左。
      </p>

      <pre class="example nohighlight" title="阿拉伯文本的基础方向为从右到左">
"title": {
  "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
  "@language": "ar",
  "@direction": "rtl"
}
        </pre>

      <p class="note">
        如果没有明确表达语言和方向，上面的文本很可能会被错误地渲染为从左到右，因为许多系统使用文本字符串的第一个字符来确定其[=base direction=]。
      </p>

      <p>
        可以为属性提供多个语言值对象作为数组值：
      </p>

      <pre class="example nohighlight" title="为标题提供多种语言文本">
"title": [
  {
    "@value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
    "@language": "en"
  },
  {
    "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
    "@language": "ar",
    "@direction": "rtl"
  }
]
        </pre>
    </section>

    <section class="substantive">
      <h3>提供默认语言和方向</h3>

      <p>
        每个自然语言字符串属性值的语言和基础方向应该提供，可以通过每个属性值的语言值结构，也可以通过整个凭证中所有值的默认语言和基础方向来提供。使用每个值的语言值结构是首选，因为使用文档默认值可能导致下游处理器执行基于JSON-LD扩展的转换，而这本来是可选的。有关更多信息，请参阅[[JSON-LD11]]规范中的<a data-cite="JSON-LD11#string-internationalization">字符串国际化</a>部分。没有与之关联的语言的自然语言字符串值应被视为语言值为`undefined`（语言标签"`und`"）。没有与之关联的基础方向的自然语言字符串值应被视为方向值为"`auto`"。
      </p>
    </section>

    <section class="informative">
      <h3>复杂语言标记</h3>

      <p>
        当单个自然语言字符串包含多种语言或注释时，字符串的内容可能需要额外的结构或标记才能正确呈现。可以使用标记语言，如HTML，来标记不同语言的文本片段或提供呈现[=bidirectional text=]所需的字符串内部标记。还可以使用`rdf:HTML`数据类型在JSON-LD中准确地编码这些值。
      </p>

      <p>
        尽管可以将信息编码为HTML，但强烈建议实施者不要这样做，因为这样做：
      </p>

      <ul>
        <li>
          需要某种版本的HTML处理器，这增加了处理语言和基础方向信息的负担。
        </li>
        <li>
          在使用此数据模型时增加了安全攻击面，因为盲目处理HTML可能导致在数据生产过程中的某个时刻执行攻击者注入的`script`标签。
        </li>
      </ul>

      <p>
        如果实施者觉得必须使用HTML或其他能够包含可执行脚本的标记语言来解决特定用例，建议他们分析攻击者如何使用标记发起针对标记消费者的注入攻击，然后针对已识别的攻击部署缓解措施。
      </p>
    </section>

  </section>

  <section class="appendix informative">
    <h2>验证</h2>

    <p>
      尽管本规范没有为[=可验证凭证=]或[=可验证展示=]的[=验证=]过程提供符合性标准，但读者可能会对如何在[=验证=]过程中利用本数据模型中的信息感到好奇。本节涵盖了工作组关于[=验证者=]在本规范中使用数据字段的预期用途的一系列讨论。
    </p>

    <section class="informative">
      <h3>凭证类型</h3>

      <p>
        当[=验证者=]向[=持有者=]请求一个或多个[=可验证凭证=]时，他们可以指定他们希望接收的凭证类型。凭证的类型通过<a href="#types">type</a>属性表示。特定类型的[=可验证凭证=]预计包含特定的[=属性=]，这些属性可用于确定[=展示=]是否满足[=验证者=]正在执行的一组处理规则。通过请求特定`type`的[=可验证凭证=]，[=验证者=]能够从[=持有者=]那里收集特定信息，这些信息起源于每个[=可验证凭证=]的[=发行者=]，从而使其能够确定与[=持有者=]互动的下一阶段。
      </p>
    </section>

    <section class="informative">
      <h3>凭证主题</h3>

      <p>
        在[=持有者=]提供的[=可验证凭证=]中，与每个`credentialSubject`的`id`[=属性=]关联的值预计将向[=验证者=]标识一个[=主题=]。如果[=持有者=]也是[=主题=]，那么[=验证者=]可以在他们拥有与[=持有者=]相关的[=验证=]元数据的情况下验证[=持有者=]。[=验证者=]然后可以使用[=可验证展示=]中由[=持有者=]生成的签名来验证[=持有者=]。`id`[=属性=]是可选的。[=验证者=]可以使用[=可验证凭证=]中的其他[=属性=]来唯一标识一个[=主题=]。
      </p>

      <p class="note">
        有关身份验证和WebAuthn如何与[=可验证凭证=]一起工作的信息，请参阅可验证凭证实施指南[[VC-IMP-GUIDE]]文档。
      </p>

    </section>

    <section class="informative">
      <h3>发行者</h3>

      <p>
        与`issuer` [=property=]关联的值预计将识别一个已知并受到[=verifier=]信任的[=issuer=]。
      </p>

      <p>
        与`issuer` [=property=]相关的元数据可通过<a href="#verification">验证算法</a>提供给[=verifier=]，如第<a href="#verification"></a>节所定义。此元数据包括验证用于保护每个[=可验证凭证=]或[=可验证展示=]的安全机制所使用的验证方法的控制器的身份，控制器通常是各自的`issuer`或`holder`。
      </p>

      <p>
        一些生态系统可能在[=issuers=]和验证方法控制器之间具有更复杂的关系，并可能使用经过验证的发行者列表，作为对上述映射的补充或替代。
      </p>
    </section>

    <section class="informative">
      <h4>持有者</h4>
      <p>
        与`holder` [=property=]关联的值预计可用于识别[=holder=]给[=verifier=]。
      </p>
      <p>
        通常，关于[=holder=]的相关元数据（由`holder` [=property=]的值标识）可提供给[=verifier=]，或者由[=verifier=]检索。例如，[=holder=]可以发布包含用于保护[=可验证展示=]的[=验证材料=]的信息。在检查[=可验证展示=]上的证明时，预计将使用此元数据。某些加密标识符在标识符本身中包含所有必要的元数据。在这些情况下，不需要其他元数据。其他标识符使用可验证数据注册表，在那里，这样的元数据会自动发布供[=verifiers=]使用，无需[=holder=]采取任何其他操作。
      </p>
      <p>
        请参阅<a data-cite="VC-IMP-GUIDE/#subject-holder-relationships"></a>和
        <a data-cite="VC-USE-CASES#user-tasks"></a>以获取与[=subject=]和[=holder=]相关的其他示例。
      </p>

      <p class="note">
        验证是验证者应用业务规则的过程，以评估使用[=可验证凭证=]的适当性。
      </p>
      <ul>
        <li>
        </li>
      </ul>
      <p>
        [=verifier=]可能需要根据复杂的业务规则验证给定的[=可验证展示=]；例如，验证者可能需要确信[=holder=]与[=可验证凭证=]的[=subject=]是相同的实体。在这种情况下，以下因素可以为[=verifier=]提供合理的信心，即关于该标识符的声明，在包含的[=可验证凭证=]中，实际上是关于当前演示者的：
      </p>
      <ul>
        <li>
          [=可验证展示=]是安全的，使用[=verifier=]信任的机制来保护内容的完整性。
        </li>
        <li>
          [=可验证展示=]包括一个或多个[=可验证凭证=]，这些凭证是安全的，使用[=verifier=]信任的机制来保护内容的完整性。
        </li>
        <li>
          [=可验证展示=]的`holder`属性中的标识符和`credentialSubject`数组中至少一个对象的至少一个标识符属性相同。
        </li>
        <li>
          该公共标识符可以用于发现或派生用于验证该[=可验证展示=]完整性的验证材料。
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>颁发日期</h3>

      <p>
        `validFrom` 预计在 [=verifier=] 的预期范围内。例如，[=verifier=] 可以检查 [=可验证凭证=] 的有效期开始时间是否在未来。
      </p>
    </section>

    <section class="informative">
      <h3>证明（签名）</h3>

      <p>
        用于证明 [=可验证凭证=] 或 [=可验证展示=] 中的信息未被篡改的加密机制称为<em>证明</em>。有许多类型的加密证明，包括但不限于数字签名和零知识证明。一般来说，在验证证明时，实现预计要确保：
      </p>

      <ul>
        <li>
          证明以已知的证明套件形式提供。
        </li>
        <li>
          所有必需的证明套件 [=属性=] 都存在。
        </li>
        <li>
          将证明套件 [=验证=] 算法应用于数据，结果是可接受的证明。
        </li>
      </ul>

      <p>
        一些证明是数字签名。一般来说，在验证数字签名时，实现预计要确保：
      </p>

      <ul>
        <li>
          关于与签名相关的 [=验证材料=] 的可接受的最近元数据是可用的。例如，元数据可能包括与有效期、密钥所有者或密钥用途相关的 [=属性=]。
        </li>
        <li>
          密钥未被暂停、撤销或过期。
        </li>
        <li>
          预计加密签名将被验证。
        </li>
        <li>
          满足由保护机制定义的任何其他要求。
        </li>
      </ul>

      <p class="note">
        数字签名提供了许多保护措施，除了防篡改之外，还有一些不太明显的保护措施。例如，链接数据签名 `created` [=属性=] 建立了一个日期和时间，在此之前，[=凭证=] 不应被视为 [=已验证=]，这与凭证的有效期不同。此属性描述了证明的有效性，而不是凭证的有效性。
        JWT `iat` 声明同样提供了签名制作的时间。
        <br /><br />
        `verificationMethod` [=属性=] 例如指定了可用于验证数字签名的公钥。解引用公钥 URL 揭示了关于密钥控制者的信息，这可以与 [=凭证=] 的颁发者进行比对。`proofPurpose` [=属性=] 清楚地表达了证明的目的，并确保此信息受到签名的保护。证明通常附加到 [=可验证展示=] 以用于身份验证目的，并作为断言方法附加到 [=可验证凭证=]。
      </p>
    </section>

    <section class="informative">
      <h3>有效期限</h3>

      <p>
        [=验证者=]期望`validFrom`和`validUntil`属性在一定范围内。例如，[=验证者=]可以检查[=可验证凭证=]的有效期结束时间是否已过去。由于某些凭证在其原始有效期过期后仍可用于次要目的，因此使用`validFrom`和`validUntil`属性表示的有效期始终被视为验证的组成部分，验证是在<em>验证之后</em>执行的。
      </p>
    </section>

    <section class="informative">
      <h3>状态</h3>

      <p>
        如果`credentialStatus`属性可用，[=验证者=]将根据[=可验证凭证=]的`credentialStatus` [=类型=]定义以及[=验证者=]自己的状态评估标准来评估[=可验证凭证=]的状态。例如，[=验证者=]可以确保[=可验证凭证=]的状态不是“由[=发行者=]撤销原因”。
      </p>
    </section>

    <section class="informative">
      <h3>模式</h3>

      <p>
        如果`credentialSchema`属性可用，[=验证者=]将根据[=可验证凭证=]的`credentialSchema` [=类型=]定义以及[=验证者=]自己的模式评估标准来评估[=可验证凭证=]的模式。例如，如果`credentialSchema`的`type`值为[[?VC-JSON-SCHEMA]]，那么[=验证者=]可以确保凭证的数据符合给定的JSON模式。
      </p>
    </section>

    <section class="informative">
      <h3>适用性</h3>

      <p>
        适用性是关于[=可验证凭证=]中的自定义[=属性=]是否适合[=验证者=]的目的。例如，如果[=验证者=]需要确定[=主题=]是否年满21岁，他们可能依赖于特定的`birthdate` [=属性=]，或者更抽象的[=属性=]，如`ageOver`。
      </p>

      <p>
        [=发行者=]受到[=验证者=]的信任，以提出相关的[=声明=]。例如，特许经营快餐店位置信任特许经营公司总部发出的折扣券[=声明=]。[=发行者=]在[=可验证凭证=]中表达的政策信息应该得到[=持有者=]和[=验证者=]的尊重，除非他们接受忽略政策的责任。
      </p>
    </section>
  </section>

  <section class="appendix">
    <h2>上下文、词汇表、类型和凭证模式</h2>

    <section class="normative">
      <h3>基础上下文</h3>

      <p class="issue" title="(存在风险) 哈希值可能在候选推荐阶段发生变化">
        本节列出了在候选推荐阶段可能发生变化的加密哈希值，这取决于需要修改引用文件的实施者反馈。
        <br><br>
        工作组期望在本规范作为建议推荐发布之前，JSON-LD 上下文中提供的所有术语和URL要么稳定，要么被移除。虽然这意味着如果像[[?VC-DATA-INTEGRITY]]，[[?VC-JOSE-COSE]]，SD-JWT，[[?VC-JSON-SCHEMA]]，或状态列表等依赖项不在同一时间框架内进入建议推荐阶段，本规范可能会被延迟，但工作组已准备好在过渡到推荐阶段产生过大负担的情况下移除这些依赖项。这是工作组正在承担的一个计算风险，并已制定了缓解策略，以确保本规范能及时过渡到推荐阶段。
      </p>
      <p>
        实现必须将位于`https://www.w3.org/ns/credentials/v2`的基础上下文值视为已经检索到的；以下值是根据[[SRI]]对`digest`的定义计算并编码的资源的SHA-384摘要：
        <strong>`vxRgTREj3/ZmDabpiTX+Au4UXY8GDhyCSFNw+UQtdtISDyO/znDUY+FTg8rNsGXJ`</strong>。
        强烈建议应用程序使用的所有JSON-LD上下文URL都使用相同的机制，或者一个功能等效的机制，以确保端到端的安全性。如果资源的加密哈希值与预期的哈希值不匹配，预计实现会抛出错误。
      </p>
      <p>
        应用上述基础上下文以及在任何`@context`属性中的其他上下文和值的实现，在执行如
        <a href="https://www.w3.org/TR/json-ld11-api/#expansion-algorithm">
          JSON-LD扩展</a>或
        <a href="https://www.w3.org/TR/json-ld11/#serializing-deserializing-rdf">
          转换为RDF</a>等操作时，预计不会遇到任何错误。如果执行此类操作并导致错误，
        [=可验证凭证=]或[=可验证展示=]必须导致验证失败。
      </p>
      <p>
        可以通过在现代Unix命令行界面中运行以下命令来确认上述SHA-384摘要：
        `curl -s https://www.w3.org/ns/credentials/v2 | openssl dgst -sha384 -binary | openssl base64 -A`
      </p>
      <p>
        关于此哈希编码方法的更多详细信息可以在<a
          href="https://www.w3.org/TR/SRI/#integrity-metadata">完整性元数据</a>
        部分的[[SRI]]中找到。
      </p>
      <p class="note" title="如果检测到哈希值变化，请查看勘误">
        本规范中具有关联加密哈希值的文件极不可能发生变化。然而，如果在规范中发现了关键的勘误，并且需要进行更正以确保生态系统的稳定，加密哈希值可能会发生变化。因此，这些文件的HTTP缓存时间并未设置为无限，并建议实施者在检测到加密哈希值变化时检查勘误。
      </p>
      <p>
        本节提醒了确保在验证[=可验证凭证=]和[=可验证展示=]时，[=验证者=]具有与[=发行者=]或[=持有者=]在保护[=凭证=]或[=展示=]时所具有的一致信息的重要性。这些信息可能至少包括：
      </p>
      <ol>
        <li>
          凭证本身的内容，在[=可验证凭证=]和[=可验证展示=]中使用[[VC-JOSE-COSE]]和[[VC-DATA-INTEGRITY]]等机制进行保护。
        </li>
        <li>
          凭证中内容的含义取决于指向外部URL的链接，例如JSON-LD上下文，可以通过使用本地静态副本或文件的加密摘要来保护。
        </li>
      </ol>
      <p>
        验证者需注意，凭证内部引用的其他数据，例如通过URL链接的资源，默认情况下并未加密保护。最佳实践是确保通过使用永久缓存文件和/或加密哈希为[=可验证凭证=]的安全性至关重要的任何URL提供相同类型的保护。有关更多信息，请参阅可验证凭证实现指南中的
        <a data-cite="?vc-imp-guide/#content-integrity">内容完整性</a>
        部分。最终，知道任何链接的外部内容的加密摘要可以使[=验证者=]确认内容与[=发行者=]或[=持有者=]的意图相符。
      </p>
    </section>

    <section class="normative">
      <h3>词汇表</h3>

      <p class="issue" title="(有风险) URL 值可能在候选推荐阶段发生变化">
        本节列出了在候选推荐阶段可能发生变化的 URL 值，这取决于将文档迁移到时间戳位置、将文档迁移到 W3C 技术报告命名空间以及需要修改引用的 URL 的实施者反馈。
      </p>

      <p>
        依赖 RDF 词汇处理的实现必须确保基本上解析到以下文件的词汇 URL，这些文件是规范的。实现可以使用其他语义等效的词汇文件的序列化。为了确保开发人员可以验证每个文件的内容是否正确，提供了所有内容的加密哈希。
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>URL 和媒体类型</th>
            <th>内容和哈希</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              https://www.w3.org/2018/credentials#<br>
              `application/ld+json`
            </td>
            <td>
              https://www.w3.org/2018/credentials/index.jsonld<br><br>
              sha256: `z52TgKqh2nqTCuACI8lCvhRdjwxQjeVmuOMCDCEijq4=`<br><br>
              sha3-512: `m8Ss+jgZiyL2Ws/ICJcWjHFd9PccJWsXPvMatBOhrH<wbr>
h0qCBrzfgO2zO1OQQbTL7zoPgLseIbcxJJpunD2bkoRA==`
            </td>
          </tr>
          <tr>
            <td>
              https://w3id.org/security#<br>
              `application/ld+json`
            </td>
            <td>
              https://w3c.github.io/vc-data-integrity/vocab/security/vocabulary.jsonld<br><br>
              sha256: `LEaoTyf796eTaSlYWjfPe3Yb+poCW9TjWYTbFDmC0tc=`<br><br>
              sha3-512: `f4DhJ3xhT8nT+GZ8UUZi4QC+HT//wXE2fRTgUP4UNw<wbr>
e4kvel2PFfd6jcofHBm9BjwEiGzVFGv4K+fFTKXRD2NA==`
            </td>
          </tr>
        </tbody>
      </table>

      <p>
        可以通过在现代Unix命令界面中运行以下命令来确认上述加密摘要：
        `curl -sL -H "Accept: &lt;MEDIA_TYPE>" &lt;DOCUMENT_URL> | openssl dgst -&ltDIGEST_ALGORITHM> -binary | openssl
        base64 -nopad -a`
      </p>

      <p class="note" title="schema.org定期更改，但被认为是稳定的">
        实施者和文档作者可能注意到，`schema.org`的加密摘要未提供。这是因为`schema.org`词汇经常更改；任何提供的摘要在发布几周后就会过时。工作组讨论了这个问题，并得出结论，本规范使用的`schema.org`词汇的语义含义多年来一直稳定，并且极不可能发生变化。
      </p>

      <p>
        本规范为处理器和其他受益于此类定义的规范定义了以下基类：
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>基类</th>
            <th>目的</th>
          </tr>
        </thead>
        <tbody>
          <tr id="bc-credential-evidence">
            <td>
              `CredentialEvidence`
            </td>
            <td>
              作为放入
              <a href="#evidence">证据</a>属性中的特定证据类型的超类。 <span class="issue atrisk">如果在候选推荐阶段结束时未能确定至少两个独立的超类实现，此超类将处于风险并将被移除。</span>
            </td>
          </tr>
          <tr id="bc-credential-schema">
            <td>
              `CredentialSchema`
            </td>
            <td>
              作为放入
              <a href="#data-schemas">credentialSchema</a>属性中的特定模式类型的超类。
            </td>
          </tr>
          <tr id="bc-credential-status">
            <td>
              `CredentialStatus`
            </td>
            <td>
              作为放入
              <a href="#status">credentialStatus</a>属性中的特定凭证状态类型的超类。
            </td>
          </tr>
          <tr id="bc-confidence-method">
            <td>
              `ConfidenceMethod`
            </td>
            <td>
              作为放入`confidenceMethod`属性中的特定信心方法类型的超类。
              <span class="issue atrisk">如果在候选推荐阶段结束时未能确定至少两个独立的超类实现，此超类将处于风险并将被移除。</span>
            </td>
          </tr>
          <tr id="bc-refresh-service">
            <td>
              `RefreshService`
            </td>
            <td>
              作为放入
              <a href="#refreshing">credentialRefresh</a>属性中的特定刷新服务类型的超类。
              <span class="issue atrisk">如果在候选推荐阶段结束时未能确定至少两个独立的超类实现，此超类将处于风险并将被移除。</span>
            </tr>
          </tbody>
        </table>
  
        <p>
          本规范为处理器和其他受益于此类定义的规范定义了以下属性：
        </p>
  
        <table class="simple">
          <thead>
            <tr>
              <th>属性</th>
              <th>目的</th>
            </tr>
          </thead>
          <tbody>
            <tr id="ap-credential-evidence">
              <td>
                <a href="#evidence">evidence</a>
              </td>
              <td>
                用于表示与[=可验证凭证=]关联的证据。这些证据可以用于帮助[=验证者=]确定他们是否信任[=可验证凭证=]。
              </td>
            </tr>
            <tr id="ap-credential-schema">
              <td>
                <a href="#data-schemas">credentialSchema</a>
              </td>
              <td>
                用于表示[=可验证凭证=]的结构和语义。这些模式可以用于帮助[=验证者=]确定他们是否信任[=可验证凭证=]的结构和语义。
              </td>
            </tr>
            <tr id="ap-credential-status">
              <td>
                <a href="#status">credentialStatus</a>
              </td>
              <td>
                用于表示[=可验证凭证=]的状态。这些状态可以用于帮助[=验证者=]确定他们是否信任[=可验证凭证=]的状态。
              </td>
            </tr>
            <tr id="ap-confidence-method">
              <td>
                `confidenceMethod`
              </td>
              <td>
                用于表示[=可验证凭证=]的信心方法。这些方法可以用于帮助[=验证者=]确定他们是否信任[=可验证凭证=]的信心方法。
                <span class="issue atrisk">如果在候选推荐阶段结束时未能确定至少两个独立的属性实现，此属性将处于风险并将被移除。</span>
              </td>
            </tr>
            <tr id="ap-refresh-service">
              <td>
                <a href="#refreshing">credentialRefresh</a>
              </td>
              <td>
                用于表示[=可验证凭证=]的刷新服务。这些服务可以用于帮助[=验证者=]确定他们是否信任[=可验证凭证=]的刷新服务。
                <span class="issue atrisk">如果在候选推荐阶段结束时未能确定至少两个独立的属性实现，此属性将处于风险并将被移除。</span>
              </td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>

  <section class="appendix informative">
    <h2>IANA注意事项</h2>

    <p>
      本节将提交给互联网工程指导组（IESG）进行审查、批准，并在IANA注册。
    </p>

    <section id="vc-ld-media-type">
      <h2>application/vc+ld+json</h2>
      <p>
        本规范专门为识别符合可验证凭证格式的文档注册了`application/vc+ld+json`媒体类型。
      </p>
      <table>
        <tr>
          <td>类型名称：</td>
          <td>应用程序</td>
        </tr>
        <tr>
          <td>子类型名称：</td>
          <td>vc+ld+json</td>
        </tr>
        <tr>
          <td>必需参数：</td>
          <td>无</td>
        </tr>
        <tr>
          <td>编码注意事项：</td>
          <td>
            使用"`application/vc+ld+json`"媒体类型的资源
            必须符合所有"`application/ld+json`"媒体类型的要求，因此受到[[RFC7159]]第11节中指定的相同编码注意事项的约束。
          </td>
        </tr>
        <tr>
          <td>安全性考虑：</td>
          <td>按照本规范定义。</td>
        </tr>
        <tr>
          <td>联系方式：</td>
          <td>
            W3C 可验证凭证工作组
            <a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
          </td>
        </tr>
      </table>

      <p>
        请注意，虽然可验证凭证格式使用了JSON-LD约定，
        但是对于可验证凭证实现有一些约束和额外要求，这就证明了使用特定媒体类型的必要性。
      </p>

      <p>
        这种媒体类型可以用于使用[=封装证明=]保护的凭证。
      </p>
      <p>
        期望在文档的主体中存在一个[[JSON-LD11]]上下文，并且如媒体类型中的`ld+json`所示，期望凭证是一个有效的
        <a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document">JSON-LD
          文档</a>。
      </p>
    </section>

    <section id="vp-ld-media-type">
      <h2>application/vp+ld+json</h2>
      <p>
        本规范专门为符合可验证呈现格式的文档注册了`application/vp+ld+json`媒体类型。
      </p>
      <table>
        <tr>
          <td>类型名称：</td>
          <td>application</td>
        </tr>
        <tr>
          <td>子类型名称：</td>
          <td>vp+ld+json</td>
        </tr>
        <tr>
          <td>必需参数：</td>
          <td>无</td>
        </tr>
        <tr>
          <td>编码注意事项：</td>
          <td>
            使用"`application/vp+ld+json`"媒体类型的资源需要遵守
            "`application/ld+json`"媒体类型的所有要求，因此需要遵循[[RFC7159]]第11节中规定的相同编码注意事项。
          </td>
        </tr>
        <tr>
          <td>安全注意事项：</td>
          <td>按照本规范定义。</td>
        </tr>
        <tr>
          <td>联系方式：</td>
          <td>
            W3C 可验证凭证工作组
            <a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
          </td>
        </tr>
      </table>

      <p>
        请注意，虽然可验证凭证格式使用 JSON-LD 约定，但可验证凭证实现有许多限制和额外要求，这些限制和要求足以证明使用特定媒体类型是合理的。
      </p>

      <p>
        该媒体类型可用于使用[=enveloping proof=]保护的演示文稿。
      </p>
      <p>
        预计文档正文中会存在一个[[JSON-LD11]]上下文，并且如媒体类型中的`ld+json`所示，凭证预计将是一个有效的
        <a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document">JSON-LD
          文档</a>。
      </p>
    </section>

  </section>

  <section class="appendix informative">
    <h2>可验证呈现的附加图表</h2>

    <p>
      下面的<a href="#info-graph-vp-mult-creds"></a>是<a href="#info-graph-vp"></a>的一个变体：
      一个引用两个[=可验证凭证=]的[=可验证呈现=]，并使用基于[[?VC-DATA-INTEGRITY]]的[=嵌入式证明=]。
      每个[=可验证凭证图=]都连接到它自己的单独[=证明图=]；`verifiableCredential`属性用于将[=可验证呈现=]连接到[=可验证凭证图=]。
      [=呈现=] [=证明图=]表示[=可验证呈现图=]的数字签名，两个[=可验证凭证图=]以及从[=可验证凭证图=]链接的[=证明图=]。
      在这种情况下，完整的[=可验证呈现=]由六个信息[=图=]组成。
    </p>

    <figure id="info-graph-vp-mult-creds">
      <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-graph-mult-creds.svg" alt="
Diagram with a 'verifiable presentation graph' on top, connected via a
'proof' to a 'verifiable presentation proof graph' on the bottom. The
verifiable presentation graph has an object, 'Presentation ABC', with 3
properties: 'type' with value 'VerifiablePresentation'; 'termsOfUse' with
value 'Do Not Archive'; and two instances of 'verifiableCredential',
detailed below. This graph is annotated with a parenthetical remark, '(the
default graph)'. This graph is connected, through 'verifiableCredential',
to the part of the figure that consists two variants of Figure 6 (one is
identical; the other has minor differences in the labels referring to
validity dates, the name of the person, and the values for the nonce and
the signature), except that these verifiable credential graphs are
annotated to be named graphs instead of a default graph. The verifiable
presentation proof graph has an object labeled 'Signature 8920' with 5
properties: 'type' with value 'DataIntegrityProof'; 'verificationMethod'
with value 'Example Presenter Public Key 11'; 'created' with value
'2024-01-02T12:43:56Z'; 'nonce' with value 'hasdkyruod87j'; and
'proofValue' with value 'zpewJHoan87='. This graph is annotated with the
parenthetical remark '(a named graph)'
            ">
            <figcaption style="text-align: center;">
              <a href="#info-graph-vp">？</a>的一个变体：与引用两个可验证凭证的[=可验证呈现=]相关联的信息[=图=]，使用基于[[[VC-DATA-INTEGRITY]]] [[?VC-DATA-INTEGRITY]]的[=嵌入式证明=]。
            </figcaption>
          </figure>
      
          <p>
            下面的<a href="#info-graph-vp-jwt-mult-creds"></a>显示了与<a href="#info-graph-vp-mult-creds"></a>相同的[=可验证呈现=]，但使用基于[[?VC-JOSE-COSE]]的[=封装证明=]。
            每个[=可验证凭证图=]包含一个单独的
            <a href="#defn-EnvelopedVerifiableCredential">`EnvelopedVerifiableCredential`</a>实例，
            通过`data:` URL [[RFC2397]]引用一个通过[=封装证明=]保护的可验证凭证。
          </p>

    <figure id="info-graph-vp-jwt-mult-creds">
      <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-jwt-mult-creds.svg" alt="
Diagram with, on the left, a box, labeled as 'JWT (Decoded)', and with
three textual labels stacked vertically, namely 'Header', 'Payload', and
'Signature'. The 'Header' label is connected, with an arrow, to a
separate rectangle on the right hand side containing six text fields:
'kid: aB8J-_Z', 'alg: ES384', and 'cty: vc+ld+json', iss:
https://example.com, iat: 1704690029, and typ: vp+ld+json+sd-jwt The
'Payload' label of the left side is connected, with an arrow, to a
separate rectangle, consisting of three related graphs (stacked
vertically) connected by two arrows labeled 'verifiableCredential'
starting from the top graph and connecting it to the two other graphs,
respectively. The top graph has a label 'verifiable presentation graph
(serialized in JSON)'; the other two are both labeled by 'verifiable
credential graph (serialized in JSON)'. The top graph in the rectangle
has and object 'Presentation ABC' with 3 properties: 'type' of value
VerifiablePresentation, 'termsOfUse' of value 'Do Not Archive'. One of
the the bottom graphs includes
'data:application/vc+ld+json+sd-jwt;QzVjV...RMjU' as a subject with a
single property: 'type' of value `EnvelopedVerifiableCredential`. The
last bottom graph is identical other, except for the subject which is
labeled as 'data:application/vc+ld+json+sd-jwt;RkOyT...KjOl'. Finally,
the 'Signature' label on the left side is connected, with an arrow, to a
separate rectangle, containing a single text field:
'cYjaSdfIoJH45NIqw3MYnasGIba...'.
        ">
        <figcaption style="text-align: center;">
          <a href="#info-graph-vp-jwt">？</a>的一个变体：与[=可验证呈现=]相关联的信息[=图=]，引用两个使用基于JOSE [[?VC-JOSE-COSE]]的[=封装证明=]的可验证凭证。
        </figcaption>
    </figure>


  </section>

  <section>
    <h2>修订历史</h2>

    <p>
      本节包含了此规范随时间所做的实质性更改。
    </p>

    <p>
      自
      <a href="https://www.w3.org/TR/2022/REC-vc-data-model-20220303/">
        v1.1 推荐规范</a>以来的变更：
    </p>
    <ul>
      <li>
        进行了许多编辑更新和修复，以使规范现代化并更容易理解特定概念。
      </li>
      <li>
        在数据完整性和本规范之间删除了关于 `proof` 的重复声明。
      </li>
      <li>
        澄清了发行者验证的过程。
      </li>
      <li>
        澄清了保护机制扩展点的要求。
      </li>
      <li>
        在算法部分添加了对 [[?INFRA]] 的依赖。
      </li>
      <li>
        添加了保护机制规范的要求。
      </li>
      <li>
        澄清了执行特定凭证类型处理的方法。
      </li>
      <li>
        添加了在可验证演示中嵌入封装的可验证凭证的机制。
      </li>
      <li>
        添加验证算法、安全机制接口和问题详细信息对象。
      </li>
      <li>
        调整`issuer`属性的允许值。
      </li>
      <li>
        提供更具体的指导，以表达语言信息以及默认语言和方向。
      </li>
      <li>
        为发行者和验证者实现添加新的符合类。
      </li>
      <li>
        添加有关密钥管理的新的安全注意事项。
      </li>
      <li>
        添加有关信任边界、基于元数据的关联、数据盗窃和使用Oblivious HTTP的隐私注意事项。
      </li>
      <li>
        正式定义词汇的基类和属性。
      </li>
      <li>
        提供警告，不要使用高级JSON-LD功能，以最大程度地提高互操作性。
      </li>
      <li>
        提供更明确的指导，涉及集合和数组。
      </li>
      <li>
        为发行者和凭证添加`name`和`description`字段的支持。
      </li>
      <li>
        添加有关拦截、重放和欺骗攻击的安全注意事项。
      </li>
      <li>
        在基本JSON-LD上下文中添加JWT和SD-JWT声明。
      </li>
      <li>
        澄清“凭证”和“可验证凭证”的区别。
      </li>
      <li>
        添加关于如何确保生态系统兼容性的部分。
      </li>
      <li>
        添加关于特定凭证类型处理的部分。
      </li>
      <li>
        添加关于验证和与持有者的相关性的部分。
      </li>
      <li>
        添加关于媒体类型精度和解释的部分。
      </li>
      <li>
        确保使用`dateTimeStamp`作为时间值。提供有关时间值和时区的正确使用的进一步指导。
      </li>
      <li>
        使`validFrom`变为可选。
      </li>
      <li>
        添加`relatedResource`功能。
      </li>
      <li>
        使基本上下文和词汇成为规范，并为其内容提供加密哈希。
      </li>
      <li>
        将`renderMethod`和`confidenceMethod`添加到保留属性列表中。
      </li>
      <li>
        更新规范中的示例。
      </li>
      <li>
        添加“入门指南”部分。
      </li>
      <li>
        添加保留属性的属性表，这些属性尚未标准化或有可能被删除。
      </li>
      <li>
        将数据模型序列化限制为紧凑文档形式的JSON-LD。
      </li>
      <li>
        更新ZKP部分以删除旧内容。
      </li>
      <li>
        在v2上下文中为演示文稿添加`termsOfUse`。
      </li>
      <li>
        在v2上下文中为未定义术语添加默认词汇。
      </li>
      <li>
        添加`application/vc+ld+json`和`application/vp+ld+json`的媒体类型。
      </li>
      <li>
        提供有关如何将符合要求的文档与其他数字凭证格式进行转换的指导。
      </li>
      <li>
        将对URI/IRI的引用更改为使用WHATWG URL规范。
      </li>
      <li>
        在数据完整性和JOSE/COSE安全机制上添加规范依赖。
      </li>
      <li>
        将`issuanceDate`/`expirationDate`重命名为`validFrom`/`validUntil`。
      </li>
      <li>
        添加JSON Schema支持，并更新示例以使用新格式。
      </li>
      <li>
        澄清`credentialSubject`值不能为字符串。
      </li>
      <li>
        创建更正式的词汇文档，引用此规范。
      </li>
      <li>
        定义v2.0 JSON-LD上下文。
      </li>
      <li>
        将VC-JWT部分迁移到单独的安全规范。
      </li>
      <li>
        将主题-持有者关系移至可验证凭证实现指南。
      </li>
      <li>
        将版本号增加到v2.0，并删除之前的REC跟踪评论。
      </li>
      <li>
        在可验证凭证数据完整性规范[[VC-DATA-INTEGRITY]]中添加规范依赖。
      </li>
      <li>
        由于v1.0和v1.1中缺乏实现，删除了关于“争议”的部分。
      </li>
    </ul>

    <p>
      自
      <a href="https://www.w3.org/TR/2019/REC-vc-data-model-20191119/">
        v1.0 推荐</a>以来的变化：
    </p>
    <ul>
      <li>
        添加此修订历史部分。
      </li>

      <li>
        更新先前的规范参考，将指向 RFC3339 的日期时间详细信息改为规范参考 XMLSCHEMA11-2，这更准确地反映了示例和库中的使用情况。
      </li>

      <li>
        放宽要求，允许在数据模型的 `credentialStatus` 和 `refreshService` 部分的 `id` 属性中使用无法解引用的 [=URLs=]。
      </li>

      <li>
        放宽零知识证明部分的规范性陈述，以支持新的零知识证明方案，例如 BBS+，这些方案是在 v1.0 规范作为推荐标准发布之后创建的。
      </li>

      <li>
        更新所有引用，指向所引用规范的最新版本。修复指向已不可用的论文的损坏链接，将其更新为可用论文的新位置。
      </li>

      <li>
        提高 SVG 图表的可访问性。
      </li>

      <li>
        修复一些示例中与 `issuer`、`issuanceDate`、`credentialStatus`、日期、失效链接和次要语法错误相关的编辑错误。
      </li>

      <li>
        将致谢从“文档状态”部分移至致谢附录。
      </li>
    </ul>
  </section>

  <section class="appendix informative">
    <h2>致谢</h2>

    <p>
      工作组感谢以下个人不仅对本文档内容的贡献，还对这个标准社区的辛勤工作，推动了变革、讨论和共识，尽管意见各异：Matt Stone、Gregg Kellogg、Ted Thibodeau Jr、Oliver Terbu、Joe
      Andrieu、David I. Lehn、Matthew Collier和Adrian Gropper。
    </p>

    <p>
      本规范的工作得到了由Christopher Allen、Shannon Appelcline、Kiara Robles、Brian Weller、Betty Dhamers、Kaliya Young、Manu
      Sporny、Drummond Reed、Joe Andrieu、Heather Vescent、Kim Hamilton Duffy、Samantha Chase和Andrew Hughes组织的Rebooting the
      Web of Trust社区的支持。由Phil Windley、Kaliya Young、Doc Searls和Heidi Nobantu Saul组织的Internet Identity
      Workshop的参与者也通过众多工作会议的设计来支持这项工作的完善，旨在教育、辩论和改进本规范。
    </p>

    <p>
      工作组还感谢我们的主席Dan Burnett、Matt Stone、Brent Zundel、Wayne Chang和Kristina Yasuda，以及我们的W3C工作人员联系人Kazuyuki Ashimura和Ivan
      Herman，他们在W3C标准化过程中的专业管理和稳定指导。
    </p>

    <p>
      本规范的部分工作得到了美国国土安全部科学与技术总局根据合同HSHQDC-17-C-00019的资助。本规范的内容不一定反映美国政府的立场或政策，不应推断出任何官方认可。
    </p>

    <p>
      工作组要感谢以下个人对规范进行审查并提供反馈意见（按字母顺序排列）：
    </p>

    <p>
      Christopher Allen, David Ammouial, Joe Andrieu, Bohdan Andriyiv, Ganesh
      Annan, Kazuyuki Ashimura, Tim Bouma, Pelle Braendgaard, Dan Brickley,
      Allen Brown, Jeff Burdges, Daniel Burnett, ckennedy422, David Chadwick,
      Chaoxinhu, Kim (Hamilton) Duffy, Lautaro Dragan, enuoCM, Ken Ebert, Eric
      Elliott, William Entriken, David Ezell, Nathan George, Reto Gmür, Ryan
      Grant, glauserr, Adrian Gropper, Joel Gustafson, Amy Guy, Lovesh
      Harchandani, Daniel Hardman, Dominique Hazael-Massieux, Jonathan Holt,
      David Hyland-Wood, Iso5786, Renato Iannella, Richard Ishida, Ian Jacobs,
      Anil John, Tom Jones, Rieks Joosten, Gregg Kellogg, Kevin, Eric Korb,
      David I. Lehn, Michael Lodder, Dave Longley, Christian Lundkvist, Jim
      Masloski, Pat McBennett, Adam C. Migus, Liam Missin, Alexander Mühle,
      Anthony Nadalin, Clare Nelson, Mircea Nistor, Grant Noble, Darrell
      O'Donnell, Nate Otto, Matt Peterson, Addison Phillips, Eric Prud'hommeaux,
      Liam Quin, Rajesh Rathnam, Drummond Reed, Yancy Ribbens, Justin Richer,
      Evstifeev Roman, RorschachRev, Steven Rowat, Pete Rowley, Markus
      Sabadello, Kristijan Sedlak, Tzviya Seigman, Reza Soltani, Manu Sporny,
      Orie Steele, Matt Stone, Oliver Terbu, Ted Thibodeau Jr, John Tibbetts,
      Mike Varley, Richard Varn, Heather Vescent, Christopher Lemmer Webber,
      Benjamin Young, Kaliya Young, Dmitri Zagidulin, and Brent Zundel.
    </p>
  </section>
</body>

</html>