<!DOCTYPE html>
<html>

<head>
  <title>Verifiable Credentials Data Model v2.0</title>
  <meta http-equiv='Content-Type' content='text/html;charset=utf-8' />
  <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
  <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
  <script src="./common.js" class="remove"></script>
  <script class="remove" src="https://cdn.jsdelivr.net/gh/digitalbazaar/respec-vc@2.0.1/dist/main.js"></script>
  <script class="removeOnSave" src="https://unpkg.com/reqlist/lib/reqlist.js"></script>
  <link class="removeOnSave" rel="stylesheet" type="text/css" href="https://unpkg.com/reqlist/lib/reqlist.css" />

  <script class="remove">
    var respecConfig = {
      group: "vc",

      // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus: "CRD",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "vc-data-model-2.0",

      // subtitle for the spec
      //subtitle: "Expressing information with verifiable provenance",

      // if you wish the publication date to be other than today, set this
      //publishDate: "2024-01-23",
      crEnd: "2024-03-23",
      //prEnd: "2019-10-01",
      implementationReportURI: "https://w3c.github.io/vc-data-model-2.0-test-suite/",
      //errata: "https://w3c.github.io/vc-data-model/errata.html",
      previousMaturity: "REC",
      previousPublishDate: "2022-03-03",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate:  "1977-03-15",
      // previousMaturity:  "WD",

      // extend the bibliography entries
      localBiblio: vcwg.localBiblio,
      doJsonLd: true,

      // Uncomment these to use the respec extension that generates a list of
      //   normative statements:
      preProcess: [/*prepare_reqlist*/],
      postProcess: [
        restrictRefs,
        window.respecVc.createVcExamples
        /*add_reqlist_button*/
      ],

      github: "https://github.com/w3c/vc-data-model/",
      includePermalinks: false,

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI: "https://w3c.github.io/vc-data-model/",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      // editors, add as many as you like
      // only "name" is required
      editors: [
        {
          name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          note: "v1.0, v1.1, v2.0", w3cid: 41758
        },
        {
          name: "Ted Thibodeau Jr", url: "https://github.com/TallTed",
          company: "OpenLink Software", companyURL: "https://www.openlinksw.com/",
          note: "v2.0", w3cid: 42501
        },
        {
          name: "Ivan Herman", url: "https://www.w3.org/People/Ivan/",
          company: "W3C", companyURL: "https://www.w3.org",
          note: "v2.0", w3cid: 7382, orcid: "0000-0003-0782-2704"
        },
        {
          name: "Michael B. Jones", url: "https://self-issued.info/",
          company: "Invited Expert",
          note: "v2.0", w3cid: 38745
        },
        {
          name: "Gabe Cohen", url: "https://github.com/decentralgabe",
          company: "Block", companyURL: "https://block.xyz/",
          note: "v2.0", w3cid: 116851
        },
      ],
      formerEditors: [
        {
          name: "Grant Noble", url: "https://www.linkedin.com/in/grant-noble-8253994a/",
          company: "ConsenSys", companyURL: "https://consensys.net/",
          note: "v1.0", w3cid: 110600
        },
        {
          name: "Dave Longley", url: "https://github.com/dlongley",
          company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
          note: "v1.0", w3cid: 48025
        },
        {
          name: "Daniel C. Burnett", url: "https://www.linkedin.com/in/daburnett/",
          company: "ConsenSys", companyURL: "https://consensys.net/",
          note: "v1.0", w3cid: 37473
        },
        {
          name: "Brent Zundel", url: "https://www.linkedin.com/in/bzundel/",
          company: "Evernym", companyURL: "https://www.evernym.com/",
          note: "v1.0", w3cid: 102128
        },
        {
          name: "Kyle Den Hartog", url: "https://www.linkedin.com/in/kyledenhartog/",
          company: "MATTR", companyURL: "https://mattr.global/",
          note: "v1.1", w3cid: 103517
        },
        {
          name: "Orie Steele", url: "https://github.com/OR13",
          company: "Transmute",
          companyURL: "https://transmute.industries/",
          note: "v2.0", w3cid: 109171
        },
        {
          name: "Oliver Terbu", url: "https://github.com/awoie",
          company: "Spruce Systems", companyURL: "https://spruceid.com/",
          note: "v2.0", w3cid: 110059
        }
      ],
      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:
        [
          {
            name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 41758
          },
          {
            name: "Dave Longley", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 48025
          },
          {
            name: "David Chadwick",
            url: "https://www.linkedin.com/in/davidwchadwick/",
            company: "Crossword Cybersecurity PLC",
            companyURL: "https://www.crosswordcybersecurity.com/",
            w3cid: 46156
          },
          {
            name: "Orie Steele", url: "https://github.com/OR13",
            company: "Transmute",
            companyURL: "https://www.transmute.industries/",
            note: "v2.0", w3cid: 109171
          }
        ],
      xref: ["URL", "I18N-GLOSSARY", "INFRA"],
      lint: { "informative-dfn": false },
      maxTocLevel: 2,
      inlineCSS: true
    };
  </script>
  <style>
    code {
      color: rgb(199, 73, 0);
      font-weight: bold;
    }

    pre {
      overflow-x: auto;
      white-space: pre-wrap;
    }

    pre .highlight {
      font-weight: bold;
      color: Green;
    }

    pre .subject {
      font-weight: bold;
      color: RoyalBlue;
    }

    pre .property {
      font-weight: bold;
      color: DarkGoldenrod;
    }

    pre .comment {
      font-weight: bold;
      color: SteelBlue;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    ol.algorithm {
      counter-reset: numsection;
      list-style-type: none;
    }

    ol.algorithm li {
      margin: 0.5em 0;
    }

    ol.algorithm li:before {
      font-weight: bold;
      counter-increment: numsection;
      content: counters(numsection, ".") ") ";
    }
  </style>
</head>

<body>
  <section id='abstract'>
    <p>
      [=凭证=]是我们日常生活的一部分；驾驶执照用于证明我们有驾驶汽车的能力，大学学位可以用来证明我们的教育水平，政府颁发的护照使我们能够在各国之间旅行。这个规范提供了一种在网络上表达这些类型的[=凭证=]的机制，这种机制是加密安全的，尊重隐私，且可由机器验证。
    </p>
  </section>

  <section id='sotd'>
    <p>
      工作组正在积极寻求对此规范的实施反馈。为了退出候选推荐阶段，工作组已设定了每个规范中的每个强制性功能至少需要两个独立实施的要求。请查看<a
        href="https://w3c.github.io/vc-data-model-2.0-test-suite/">
        实施报告</a>以获取更多详细信息。
    </p>

    <p>
      欢迎随时对此规范提出评论。
      请直接在
      <a href="https://github.com/w3c/vc-data-model/issues/">GitHub</a>上提交问题，
      或者，如果无法做到这一点，请发送到
      <a href="mailto:public-vc-comments@w3.org">public-vc-comments@w3.org</a>
      (<a href="mailto:public-vc-comments-request@w3.org?subject=subscribe">订阅</a>,
      <a href="https://lists.w3.org/Archives/Public/public-vc-comments/">档案</a>)。
    </p>

  </section>

  <section class="informative">
    <h2>简介</h2>

    <p>
      凭证是我们日常生活的一部分；驾驶执照用于证明我们有能力操作机动车辆，大学学位可用于证明我们的教育水平，政府颁发的护照使我们能够在国家之间旅行。这些凭证在现实世界中为我们提供了便利，但在网络上使用它们仍然难以捉摸。
    </p>

    <p>
      目前，在网络上表达教育资格、医疗数据、财务账户详细信息以及其他类型的第三方验证的机器可读个人信息是很困难的。在网络上表达数字凭证的困难使得在网络上获得与现实世界中相同的利益变得具有挑战性。
    </p>

    <p>
      本规范为在网络上表达凭证提供了一种标准方法，这种方法在密码学上是安全的，尊重隐私且可供机器验证。
    </p>

    <p>
      对于那些不熟悉与可验证凭证相关的概念的人，以下部分提供了一个概述：
    </p>

    <ul>
      <li>
        构成可验证凭证的组件
      </li>
      <li>
        构成可验证展示的组件
      </li>
      <li>
        可验证凭证和可验证展示预期有用的生态系统
      </li>
      <li>
        为本规范提供指导的用例和要求。
      </li>
    </ul>

    <section class="informative">
      <h3>什么是可验证凭证？</h3>

      <p>
        在现实世界中，凭证可能包括：
      </p>

      <ul>
        <li>
          与凭证主体相关的身份信息（例如，照片、姓名或身份证号）
        </li>
        <li>
          与颁发机构相关的信息（例如，市政府、国家机构或认证机构）
        </li>
        <li>
          与此凭证类型相关的信息（例如，荷兰护照、美国驾驶执照或健康保险卡）
        </li>
        <li>
          由颁发机构关于主体的特定属性或属性的相关信息（例如，国籍、有资格驾驶的车辆类别或出生日期）
        </li>
        <li>
          与凭证衍生的证据相关的信息
        </li>
        <li>
          与凭证约束相关的信息（例如，有效期或使用条款）。
        </li>
      </ul>

      <p>
        可验证凭证可以表示与实体凭证相同的所有信息。数字签名等技术的添加使可验证凭证比实体凭证更具篡改证据和更值得信赖。
      </p>

      <p>
        可验证凭证的持有者可以生成可验证的展示，然后与验证者共享这些可验证的展示，以证明他们具有某些特征的可验证凭证。
      </p>

      <p>
        可验证凭证和可验证展示可以快速传输，使它们在远程建立信任时比实体凭证更方便。
      </p>

      <p>
        虽然本规范试图改进表达数字凭证的便利性，但它还试图平衡这一目标与一系列保护隐私的目标。数字信息的持久性以及不同数字数据来源的收集和关联的便利性，构成了使用可验证且易于机器阅读的凭证可能加剧的隐私问题。本文档在<a
          href="#privacy-considerations"></a>部分概述并试图解决这些问题。本文档还提供了如何使用保护隐私的技术（例如零知识证明）使用此数据模型的示例。
      </p>

      <p>
        术语可验证凭证和可验证展示中的“可验证”是指凭证或展示具有可由验证者验证的特性，如本文档所定义。凭证的可验证性并不意味着其中编码的声明是真实的。相反，在建立可验证凭证或可验证展示的真实性和时效性后，验证者使用自己的业务规则验证包含的声明，然后才依赖它们。这种依赖仅在评估发行者、证明、主题和声明之后，根据一个或多个验证者策略进行。
      </p>
    </section>

    <section class="informative">
      <h3>生态系统概述</h3>

      <p>
        本节描述了核心参与者的角色以及在可验证凭证预期有用的生态系统中它们之间的关系。角色是一个抽象，可以用许多不同的方式实现。角色的分离表明了可能的接口和协议标准化。本规范引入了以下角色：
      </p>

      <dl>
        <dt>[=holder=]（持有者）</dt>
        <dd>
          通过拥有一个或多个可验证凭证并从中生成可验证展示来执行的实体角色。示例持有者包括学生、员工和客户。
        </dd>
        <dt>[=issuer=]（发行者）</dt>
        <dd>
          实体执行的角色，通过对一个或多个主体进行声明，从这些声明中创建可验证凭证，并将可验证凭证传输给持有者。示例发行者包括公司、非营利组织、行业协会、政府和个人。
        </dd>
        <dt>[=subject=]（主体）</dt>
        <dd>
          进行声明的实体。示例主体包括人类、动物和事物。在许多情况下，可验证凭证的持有者是主体，但在某些情况下不是。例如，父母（持有者）可能持有孩子（主体）的可验证凭证，或者宠物主人（持有者）可能持有他们宠物（主体）的可验证凭证。有关这些特殊情况的更多信息，请参阅可验证凭证实施指南[[VC-IMP-GUIDE]]中的
          <a href="https://www.w3.org/TR/vc-imp-guide/#subject-holder-relationships">
            主体-持有者关系</a>部分。
        </dd>
        <dt>[=verifier=]（验证者）</dt>
        <dd>
          通过接收一个或多个可验证凭证（可选地在可验证展示中）进行处理的实体角色。示例验证者包括雇主、安全人员和网站。
        </dd>
        <dt>[=verifiable data registry=]（可验证数据注册表）</dt>
        <dd>
          系统可能通过调解创建和验证标识符、密钥和其他相关数据（如可验证凭证模式、撤销注册表、发行者公钥等）来执行的角色，这些数据可能需要使用可验证凭证。某些配置可能需要可关联的主体标识符。示例可验证数据注册表包括可信数据库、分布式数据库、政府ID数据库和分布式分类帐。通常，在生态系统中会使用多种类型的可验证数据注册表。
        </dd>
      </dl>

      <figure id="roles">
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/ecosystem.svg" alt="示意图显示了
               凭证从发行者流向持有者，
               展示从持有者流向验证者，所有
               三方均可使用来自逻辑
               可验证数据注册表的信息">
        <figcaption style="text-align: center;">
          构成本规范基础的角色和信息流。
        </figcaption>
      </figure>

      <p class="note">
        上面的<a href="#roles"></a>提供了一个示例生态系统，以便将本规范的其他概念固定下来。其他生态系统（如受保护的环境或专有系统）也存在，其中可验证凭证也具有优势。
      </p>
    </section>

    <section class="informative">
      <h3>用例和要求</h3>

      <p>
        可验证凭证用例文档[[VC-USE-CASES]]概述了一些关键主题，读者可能会发现这些主题很有用，包括：
      </p>

      <ul>
        <li>
          对上述引入的
          <a href="https://www.w3.org/TR/vc-use-cases/#user-roles">角色</a>
          的更详细解释
        </li>
        <li>
          在市场垂直领域（如教育、金融、医疗、零售、专业许可和政府）中确定的
          <a href="https://www.w3.org/TR/vc-use-cases/#user-needs">需求</a>
        </li>
        <li>
          生态系统中角色执行的常见
          <a href="https://www.w3.org/TR/vc-use-cases/#user-tasks">任务</a>
          以及与之相关的要求
        </li>
        <li>
          工作组确定的常见
          <a href="https://www.w3.org/TR/vc-use-cases/#user-sequences">序列和流程</a>。
        </li>
      </ul>

      <p>
        通过记录和分析用例文档，为本规范确定了以下理想的生态系统特征：
      </p>
      <!-- 要求列表开始 -->
      <ul>
        <li>
          可验证凭证代表发行者以防篡改和尊重隐私的方式所作的声明。
        </li>
        <li>
          持有者可以将来自不同发行者的可验证凭证集合组装成一个单一的工件，即可验证展示。
        </li>
        <li>
          发行者可以颁发关于任何主体的可验证凭证。
        </li>
        <li>
          执行发行者、持有者或验证者的角色不需要任何权威机构的注册或批准，因为涉及的信任是双方之间的。
        </li>
        <li>
          可验证展示允许任何验证者验证来自任何发行者的可验证凭证的真实性。
        </li>
        <li>
          持有者可以从任何人那里接收可验证凭证。
        </li>
        <li>
          持有者可以通过任何用户代理与任何发行者和任何验证者互动。
        </li>
        <li>
          持有者可以共享可验证展示，然后可以验证它们，而无需向发行者透露验证者的身份。
        </li>
        <li>
          验证者可以验证可验证展示的真实性，而无需向发行者透露验证者的身份。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，而不需要共享主体的唯一标识符。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时尊重主体的隐私。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体选择性地披露信息。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体保留对披露给验证者的信息的控制。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行最小化。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行选择性披露。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行选择性披露，而无需泄露其他信息。
        </li>
        <li>
          可验证凭证和可验证展示可以用于传递有关主体的信息，同时允许主体对披露给验证者的信息进行选择性披露，而无需泄露其他信息，且不需要向发行者透露验证者的身份。
        </li>
      </ul>
      <!-- 要求列表结束 -->
    </section>
  </section>
  <section class="normative">
    <h2>术语</h2>

    <p>
      以下术语用于描述本规范中的概念。
    </p>

    <dl class="termlist definitions">
      <dt><dfn class="export" data-lt="claims">声明</dfn></dt>
      <dd>
        关于某个[=主体=]的断言。
      </dd>
      <dt><dfn class="export" data-lt="credential|credentials">凭证</dfn></dt>
      <dd>
        由一个[=发行者=]做出的一个或多个[=声明=]的集合。凭证中的[=声明=]
        可以关于不同的[=主体=]。本规范中使用的凭证的定义与
        <a href="https://csrc.nist.gov/glossary/term/credential">NIST的凭证定义</a>不同。
      </dd>
      <dt><dfn>数据最小化</dfn></dt>
      <dd>
        限制共享数据的行为，严格限制到完成任务或目标所必需的最小量。
      </dd>
      <dt><dfn data-lt="decentralized identifiers|DID|DIDs">去中心化标识符</dfn></dt>
      <dd>
        一种便携式基于URL的标识符，也被称为<strong><em>DID</em></strong>，
        与[=实体=]相关联。这些标识符最常用于
        [=可验证的凭证=]，并与[=主体=]关联，使得一个
        [=可验证的凭证=]可以轻易地从一个
        [=仓库=]迁移到另一个，而无需重新发行[=凭证=]。
        DID的一个例子是`did:example:123456abcdef`。
      </dd>
      <dt><dfn class="lint-ignore" data-lt="decentralized identifier documents|DID document|DID documents">去中心化
          标识符文档</dfn></dt>
      <dd>
        也被称为<strong><em>DID文档</em></strong>，这是一个可以通过[=可验证数据注册表=]访问的文档，
        包含与特定[=去中心化标识符=]相关的信息，如相关的[=仓库=]和公钥信息。
      </dd>
      <dt><dfn data-lt="default graph">默认图</dfn></dt>
      <dd>
        包含所有不明确属于
        [=命名图=]的[=声明=]的[=图=]。
      </dd>
      <dt><dfn data-lt="predicates|derived predicates">派生谓词</dfn></dt>
      <dd>
        关于[=可验证凭证=]中另一个属性值的可验证的布尔断言。
        这些在零知识证明风格的
        [=可验证呈现=]中很有用，因为它们可以限制信息的披露。
        例如，如果一个[=可验证的凭证=]包含一个用于表示特定高度（以厘米为单位）的属性，
        一个派生谓词可能会引用[=可验证凭证=]中的高度属性，证明
        [=发行者=]确认高度值满足最低高度要求，
        而实际上并未披露具体的高度值。例如，[=主体=]的身高超过150厘米。
      </dd>
      <dt><dfn class="lint-ignore">数字签名</dfn></dt>
      <dd>
        用于证明数字消息真实性的数学方案。
      </dd>
      <dt><dfn data-lt="entities|entity's">实体</dfn></dt>
      <dd>
        可以在陈述中作为抽象或具体名词引用的任何事物。
        实体包括但不限于人、组织、实物、文档、抽象概念、虚构角色和任意文本。任何
        实体都可能在生态系统中扮演角色，如果它有能力这样做。请注意，有些实体从根本上无法采取行动，例如，字符串"abc"
        不能发行凭证。
      </dd>
      <dt><dfn data-lt="graphs">图</dfn></dt>
      <dd>
        一组声明，形成一个由[=主体=]
        及其与其他[=主体=]或数据的关系组成的信息网络。每个[=声明=]
        都是图的一部分；在[=命名图=]的情况下，这是明确的，或者
        在[=默认图=]的情况下是隐含的。
      </dd>
      <dt><dfn class="export" data-lt="holders|holder's|holders'">持有者</dfn></dt>
      <dd>
        通过持有一个或多个
        [=可验证凭证=]并从中生成[=可验证呈现=]来执行的角色。持有者通常是，但不总是，他们持有的
        [=可验证凭证=]的[=主体=]。持有者将其
        [=凭证=]存储在[=凭证仓库=]中。
      </dd>
      <dt><dfn class="lint-ignore" data-lt="identities|identity's">身份</dfn></dt>
      <dd>
        跨上下文跟踪[=实体=]的手段。数字
        身份使得跟踪和定制[=实体=]在数字上下文中的交互成为可能，通常使用标识符和属性。身份信息的意外分发或使用可能会损害隐私。收集和使用此类信息应遵循
        [=数据最小化=]原则。
      </dd>
      <dt><dfn data-lt="identity providers|idp">身份提供者</dfn></dt>
      <dd>
        身份提供者，有时缩写为<em>IdP</em>，是一个为[=持有者=]创建、维护和管理身份信息的系统，
        同时为联盟或分布式网络中的[=依赖方=]应用程序提供身份验证服务。在这种情况下，[=持有者=]始终是[=主体=]。即使[=可验证凭证=]是持票人
        [=凭证=]，也假设[=可验证凭证=]仍然随着
        [=主体=]，如果没有，它们是被攻击者窃取的。本规范不使用此术语，除非将本文档中的概念与其他规范进行比较或映射。本规范将
        [=身份提供者=]概念拆分为两个独立的概念：[=发行者=]
        和[=持有者=]。
      </dd>
      <dt><dfn class="export" data-lt="issuers|issuer's">发行者</dfn></dt>
      <dd>
        一个[=实体=]可以通过对一个或多个[=主体=]进行[=声明=]，
        从这些[=声明=]中创建一个[=可验证凭证=]，
        并将[=可验证凭证=]传输给
        [=持有者=]来执行的角色。
      </dd>
      <dt><dfn data-lt="named graphs">命名图</dfn></dt>
      <dd>
        与特定属性相关联的[=图=]，例如
        `verifiableCredential`。这些属性
        导致独立的[=图=]，其中包含在相应的JSON对象中定义的所有[=声明=]。
      </dd>
      <dt><dfn class="export" data-lt="presentation|presentations">呈现</dfn></dt>
      <dd>
        从一个或多个[=可验证凭证=]，由一个或多个[=发行者=]发行的数据派生出来，
        并与特定的[=验证者=]共享。
      </dd>
      <dt><dfn class="export" data-lt="credential repository|credential repositories|repositories">仓库</dfn></dt>
      <dd>
        一个程序，如存储库或个人[=可验证凭证=]
        钱包，存储并保护对[=持有者的=]
        [=可验证凭证=]的访问。
      </dd>
      <dt><dfn class="export">选择性披露</dfn></dt>
      <dd>
        [=持有者=]做出关于分享哪些信息的细粒度决策的能力。
      </dd>
      <dt><dfn class="export" data-lt="subjects|subject's">主体</dfn></dt>
      <dd>
        制作[=声明=]的对象。
      </dd>
      <dt><dfn class="lint-ignore">用户代理</dfn></dt>
      <dd>
        一个程序，如浏览器或其他Web客户端，它调解
        [=持有者=]、[=发行者=]和[=验证者=]之间的
        通信。
      </dd>
      <dt><dfn class="export" data-lt="claim validation|validate">验证</dfn></dt>
      <dd>
        确保特定[=发行者=]的[=声明=]满足[=验证者=]对特定用途的业务要求的保证。本规范定义了验证者如何验证[=可验证凭证=]和
        [=可验证呈现=]。<br />
        它还规定[=验证者=]在依赖它们之前应验证[=可验证
        凭证=]中的声明。然而，这种验证的方法各不相同，超出了本规范的范围。预计[=验证者=]将信任某些[=发行者=]对某些声明，并
        应用他们自己的规则来确定哪些声明在哪些[=凭证=]
        对他们的系统来说是适合使用的。
      </dd>
      <dt><dfn class="export" data-lt="vc|vcs">可验证凭证</dfn></dt>
      <dd>
        可验证凭证是一种防篡改的凭证，其作者身份可以通过密码验证。可验证凭证可以用来构建[=可验证呈现=]，这也可以通过密码验证。
      </dd>
      <dt><dfn class="export" data-lt="verifiable data registries">可验证数据注册表</dfn></dt>
      <dd>
        一个系统可能通过调解识别符、密钥和其他相关数据（如
        [=可验证凭证=]模式、撤销注册表、发行者公钥等）的创建和[=验证=]
        来执行的角色，这些可能是使用[=可验证凭证=]所必需的。某些配置可能需要可关联的识别符对于[=主体=]。某些注册表，如UUID和公钥的注册表，可能只是识别符的命名空间。
      </dd>
      <dt><dfn class="export" data-lt="vp|vps">可验证呈现</dfn></dt>
      <dd>
        可验证呈现是一种防篡改的呈现，以这样一种方式编码，以便在密码学验证过程之后可以信任数据的作者身份。某些类型的可验证呈现可能包含从[=可验证
        凭证=]（例如，零知识证明）合成的数据，但不包含原始[=可验证
        凭证=]。
      </dd>
      <dt><dfn class="export" data-lt="verify|verified|verifying|verifiable|verifiability">验证</dfn></dt>
      <dd>
        评估一个[=可验证凭证=]或[=可验证
        呈现=]是否是发行者或
        呈现者的真实和当前陈述。这包括检查：凭证（或
        呈现）是否符合规范；证明方法是否满足；以及（如果存在）状态检查是否成功。验证凭证并不意味着评估凭证中编码的[=声明=]的真实性。
      </dd>
      <dt><dfn class="export"
          data-lt="verifier|verifiers|verifier's|credential verifiers|credential verifier's">验证者</dfn></dt>
      <dd>
        一个[=实体=]通过接收一个或多个
        [=可验证凭证=]，可选择地在
        [=可验证呈现=]中进行处理来执行的角色。其他规范可能将这个概念称为<dfn data-lt="relying parties">依赖方</dfn>。
      </dd>
      <dt><dfn data-lt="verification material">验证材料</dfn></dt>
      <dd>
        可能是一个密码公钥或用于验证证据的任何其他数据。
      </dd>
      <dt><dfn data-lt="URL|URLs">URL</dfn></dt>
      <dd>
        统一资源定位符，如[[URL]]所定义。URL可以被解引用，
        从而导致一个资源，如文档。解引用或获取URL的规则由URL [=url/scheme=]定义。本规范不使用术语URI或IRI，因为这些术语被认为对Web开发者来说很混乱。
      </dd>
    </dl>
  </section>

  <section class="informative">
    <h2>核心数据模型</h2>

    <p>
      以下部分概述了核心数据模型概念，如 [=claims=]、[=credentials=]、[=presentations=]、[=verifiable credentials=] 和 [=verifiable
      presentations=]，这些概念构成了本规范的基础。
    </p>

    <p class="note" title="凭证和可验证凭证之间的区别">
      读者可能会注意到，本节中描述的一些概念，如 [=credential=] 和 [=presentation=]，在本规范中没有定义媒体类型。然而，[=verifiable credential=] 或 [=verifiable
      presentation=] 这些概念被定义为 [=conforming documents=]，并且具有相关联的媒体类型。这些概念之间的具体区别 &mdash; 即 [=credential=] 和
      [=presentation=] 与 [=verifiable credential=] 和 [=verifiable presentation=] 之间的区别 &mdash; 仅仅在于 "可验证"
      对象以加密可验证的方式进行保护，而其他对象则没有。有关详细信息，请参见<a href="#securing-mechanisms">安全机制部分</a>。
    </p>

    <section class="informative">
      <h3>声明</h3>

      <p>
        一个[=claim=]是关于一个[=subject=]的陈述。一个[=subject=]是可以对其进行[=claims=]的事物。[=Claims=]使用<strong><em>主体</em></strong>-<dfn
          data-lt="property|properties">
          属性</dfn>-<dfn class="lint-ignore">值</dfn>关系来表示。
      </p>

      <figure id="basic-structure">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/claim.svg" alt="主体具有一个属性，该属性具有一个值">
        <figcaption style="text-align: center;">
          声明的基本结构。
        </figcaption>
      </figure>

      <p>
        如上图<a href="#basic-structure"></a>所示，[=claims=]的数据模型非常强大，可以用来表示各种各样的陈述。例如，某人是否从某个特定大学毕业，可以如下图<a
          href="#basic-example"></a>所示表示。
      </p>

      <figure id="basic-example">
        <img style="margin: auto; display: block; width: 60%;" src="diagrams/claim-example.svg"
          alt="Pat具有一个alumniOf属性，其值为Example University">
        <figcaption style="text-align: center;">
          一个基本的声明，表示Pat是“Example University”的校友。
        </figcaption>
      </figure>

      <p>
        单个[=claims=]可以合并在一起，以表达关于[=subject=]的信息[=graph=]。下图<a
          href="#multiple-claims"></a>中的示例通过添加Pat认识Sam的[=claims=]以及Sam被雇佣为教授的[=claims=]来扩展之前的[=claim=]。
      </p>

      <figure id="multiple-claims">
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/claim-extended.svg"
          alt="扩展先前的图表，添加一个名为knows的属性，其值为Sam，Sam具有一个名为jobTitle的属性，其值为Professor">
        <figcaption style="text-align: center;">
          多个声明可以组合在一起，以表达信息图。
        </figcaption>
      </figure>

      <p>
        到目前为止，已经介绍了[=claim=]和信息[=graph=]的概念。为了能够信任[=claims=]，预计将向图中添加更多信息。
      </p>
    </section>

    <section class="informative">
      <h3>凭证</h3>

      <p>
        一个[=credential=]是由相同的[=entity=]做出的一个或多个[=claims=]的集合。[=Credentials=]还可能包括一个标识符和元数据，用于描述[=credential=]的属性，如[=issuer=]、有效日期和时间段、代表性图像、[=verification
        material=]、吊销机制等。元数据可能由[=issuer=]签名。一个[=verifiable credential=]是一个防篡改的[=claims=]和元数据的集合，可以加密地证明谁发行了它。
      </p>

      <figure id="basic-vc">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/vc.svg" alt="一个可验证的凭证包含凭证元数据、声明和证明">
        <figcaption style="text-align: center;">
          可验证凭证的基本组件。
        </figcaption>
      </figure>

      <p>
        [=verifiable credentials=]的示例包括数字员工身份证、数字出生证明和数字教育证书。
      </p>

      <p class="note">
        [=Credential=]标识符通常用于识别特定实例的[=credential=]。这些标识符也可以用于关联。希望最小化关联的[=holder=]建议使用一种选择性披露方案，该方案不会泄露[=credential=]标识符。
      </p>

      <p>
        <a href="#basic-vc"></a>上面显示了一个[=verifiable
        credential=]的基本组件，但抽象了关于如何将[=claims=]组织成信息[=graphs=]的细节，然后将其组织成[=verifiable credentials=]。
      </p>
      <p>
        <a href="#info-graph-vc"></a>下面显示了一个使用基于[[?VC-DATA-INTEGRITY]]的[=embedded proof=]的更完整的[=verifiable
        credential=]描述。它由至少两个信息[=graphs=]组成。
        这些信息[=graphs=]中的第一个，即[=verifiable credential graph=]（它是[=default
        graph=]），通过[=credential=]元数据和其他[=claims=]来表达[=verifiable credential=]本身。
        第二个信息[=graph=]，由`proof`属性引用，是[=verifiable credential=]的<dfn>proof graph</dfn>，是一个单独的[=named graph=]。
        [=proof graph=]表达了数字证明，这种情况下是数字签名。
      </p>

      <figure id="info-graph-vc">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vc-graph.svg" alt="Diagram with a collections of
claims for a 'verifiable credential graph' on top
connected via a proof property (or predicate) to a 'verifiable credential proof
graph' on the bottom. The claims for a verifiable credential include 'Credential
123' as a subject with 4 properties: 'type' of value ExampleAlumniCredential,
'issuer' of Example University, 'validFrom' of 2010-01-01T19:23:24Z, and
credentialSubject of Pat, who also has an alumniOf property with value of
Example University.  The verifiable credential proof graph has an object
'Signature 456' subject with 5 properties: 'type' of DataIntegrityProof,
'verificationMethod' of Example University Public Key 7, 'created' of
2017-06-18T21:19:10Z, a 'nonce' of 34dj239dsj328, and 'proofValue' of
'zBavE110…3JT2pq'. The verifiable credential graph is also annotated with the
parenthetical remark '(the default graph)', the verifiable credential proof
graph is annotated with the parenthetical remark '(a named graph)'.">
        <figcaption style="text-align: center;">
          使用基于[[[VC-DATA-INTEGRITY]]]的[=embedded proof=]的基本可验证凭证的相关信息图。
        </figcaption>
      </figure>

      <p>
        <a href="#info-graph-vc-jwt"></a>下面显示了与<a href="#info-graph-vc"></a>相同的可验证凭证，
        但使用基于[[?VC-JOSE-COSE]]的JOSE。负载包含一个信息图，即可验证凭证图，其中包含凭证元数据和其他声明。
      </p>

      <figure id="info-graph-vc-jwt">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vc-jwt.svg" alt="Diagram with, on the left, a box, labeled as
'SD-JWT (Decoded)', and with three textual labels stacked vertically,
namely 'Header', 'Payload', and 'Signature'. The 'Header' label is
connected, with an arrow, to a separate rectangle on the right hand
side containing six text fields: 'kid: aB8J-_Z', 'alg: ES384', and
'cty: vc+ld+json', iss: https://example.com, iat: 1704690029, and typ:
vc+ld+json+sd-jwt The 'Payload' label on the left side is connected,
with an arrow, to a separate rectangle, containing a single graph. The
rectangle has a label: 'verifiable credential graph (serialized in
JSON)' The claims in the graph include 'Credential 123' as a subject
with 4 properties: 'type' with value 'ExampleAlumniCredential',
'issuer' with value 'Example University', 'validFrom' with value
'2010-01-01T19:23:24Z', and 'credentialSubject' with value 'Pat', who
also has an 'alumniOf' property with value 'Example University'.
Finally, the 'Signature' label on the left side is connected, with an
arrow, to a separate rectangle, containing a single text field:
'DtEhU3ljbEg8L38VWAfUA...'.
          ">
        <figcaption style="text-align: center;">
          使用基于[[[VC-JOSE-COSE]]] [[?VC-JOSE-COSE]]的[=enveloping proof=]的基本可验证凭证相关的信息图。
        </figcaption>
      </figure>

      <p class="note">
        可以有一个[=credential=]，例如婚姻证书，其中包含关于不同[=subjects=]的多个[=claims=]，这些主题不需要相关。
      </p>
      <p class="note">
        可以有一个[=credential=]，其中不包含关于发行[=credential=]的[=entity=]的任何[=claims=]。例如，一个只包含关于特定狗的[=claims=]，但发给其所有者的[=credential=]。
      </p>
    </section>

    <section class="informative">
      <h3>演示</h3>

      <p>
        增强隐私是本规范的一个关键设计特性。因此，对于使用这项技术的[=实体=]来说，能够仅表达适用于特定情境的个人形象的部分非常重要。一个人形象的子集被称为[=可验证的演示=]。不同形象的例子包括一个人的专业形象、他们的在线游戏形象、他们的家庭形象或匿名形象。
      </p>

      <p>
        [=可验证的演示=]可以表达来自多个[=可验证的凭证=]的数据，并包含编码为JSON-LD的任意附加数据。它们由[=持有人=]用于向[=验证者=]展示[=声明=]。也可以直接展示[=可验证的凭证=]。
      </p>

      <p>
        [=演示=]中的数据通常与同一个[=主题=]有关，但可能是由多个[=发行者=]发布的。这些信息的汇总通常表达了一个人、组织或[=实体=]的某个方面。
      </p>

      <figure id="basic-vp">
        <img style="margin: auto; display: block; width: 50%;" src="diagrams/presentation.svg"
          alt="可验证的演示包含演示元数据、可验证的凭证和证明">
        <figcaption style="text-align: center;">
          可验证演示的基本组件。
        </figcaption>
      </figure>

      <p>
        <a href="#basic-vp"></a>上面显示了[=可验证的演示=]的组件，但抽象了关于如何将[=可验证的凭证=]组织成信息[=图=]的细节，然后将这些信息[=图=]组织成[=可验证的演示=]。
      </p>
      <p id="info-graph-vp-explanation">
        <a
          href="#info-graph-vp"></a>下面显示了一个使用基于[[?VC-DATA-INTEGRITY]]的[=嵌入式证明=]的[=可验证的演示=]的更完整描述。它由至少四个信息[=图=]组成。其中第一个信息[=图=]，即[=可验证的演示图=]（它是[=默认图=]），通过[=演示=]元数据表达[=可验证的演示=]本身。[=可验证的演示=]通过`verifiableCredential`属性引用一个[=可验证的凭证=]。这个[=凭证=]是一个包含[=凭证=]元数据和其他[=声明=]的独立[=可验证的凭证图=]。这个[=凭证=]通过`proof`属性引用一个[=可验证的凭证=]的[=证明图=]，表达了[=凭证=]的证明（通常是数字签名）。这个[=可验证的凭证图=]及其链接的[=证明图=]分别构成第二和第三个信息[=图=]，每个都是一个单独的[=命名图=]。[=演示=]还通过`proof`属性引用[=演示=]的[=证明图=]，这是第四个信息[=图=]（另一个[=命名图=]）。这个[=演示=]的[=证明图=]表示[=可验证的演示图=]、[=可验证的凭证图=]以及从[=可验证的凭证图=]链接的[=证明图=]的数字签名。
      </p>
      <p>
        为了创建一个[=可验证的演示=]，[=持有人=]需要将一个或多个[=可验证的凭证=]组合在一起，并在需要时添加其他相关信息。然后，[=持有人=]需要对整个[=可验证的演示=]进行签名，以确保接收方可以验证其来源和完整性。这样，[=验证者=]就可以确信这些[=声明=]是真实的，并且是由相应的[=发行者=]颁发的。
      </p>

      <p>
        为了验证一个[=可验证的演示=]，[=验证者=]需要执行以下步骤：
      </p>

      <ol>
        <li>检查[=可验证的演示=]的数字签名以确保其来源和完整性。</li>
        <li>检查每个包含在[=可验证的演示=]中的[=可验证的凭证=]的数字签名。</li>
        <li>确保每个[=可验证的凭证=]都是由可信的[=发行者=]颁发的。</li>
        <li>确保每个[=可验证的凭证=]都没有过期或被撤销。</li>
        <li>根据需要，确保[=可验证的演示=]和[=可验证的凭证=]满足特定的业务规则和策略。</li>
      </ol>

      <p>
        一旦[=验证者=]完成了这些步骤，他们就可以信任[=可验证的演示=]中的[=声明=]，并据此做出决策。例如，根据所提供的年龄证明，他们可以决定是否允许用户访问年龄受限的内容。
      </p>

      <p>
        请注意，[=可验证的演示=]和[=可验证的凭证=]的验证过程可能会涉及与多个[=发行者=]和其他参与者的交互，以检查证书状态、获取公钥等。为了保护用户隐私，这些交互应尽可能地减少，并遵循最小披露原则，即仅披露验证所需的最少信息。
      </p>

      <p>
        本规范描述了创建和验证[=可验证的演示=]和[=可验证的凭证=]的通用方法和原则。实际应用中可能会有多种实现方式和技术，以满足不同场景和需求。这些实现应遵循本规范的核心原则，以确保互操作性和安全性。
      </p>

      <figure id="info-graph-vp">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-graph.svg" alt="Diagram with a
'verifiable presentation graph' on top connected via a 'proof' to
a 'verifiable presentation proof graph on the bottom.  The verifiable
presentation graph has and object 'Presentation ABC' with 3 properties: 'type'
of value VerifiablePresentation, 'termsOfUse' of value 'Do Not Archive'. The
graph is annotated with the parenthetical remark '(the default graph)'. This
graph is connected, through 'verifiableCredential', to the part of the figure
which is identical to Figure 6, except that the verifiable credential graph is
annotated to be a named graph instead of a default graph.
The verifiable presentation proof graph has an object with 'Signature 8910'
with 5 properties: 'type' with value 'DataIntegrityProof'; 'verificationMethod' with value 'Example
Presenter Public Key 11'; 'created' with value '2018-01-15T12:43:56Z';
'nonce' with value 'd28348djsj3239'; and 'proofValue' with value
'zp2KaZ...8Fj3K='. This graph is annotated with the parenthetical remark '(a
named graph)'">
        <figcaption style="text-align: center;">
          与基本的[=可验证呈现=]相关联的信息[=图=]，该呈现使用基于[[[VC-DATA-INTEGRITY]]] [[?VC-DATA-INTEGRITY]]的[=嵌入式证明=]。
        </figcaption>
      </figure>

      <p>
        <a href="#info-graph-vp-jwt"></a> 下面显示的是与 <a href="#info-graph-vp"></a> 相同的 [=可验证呈现=]，但使用基于 [[?VC-JOSE-COSE]] 的
        [=封装证明=]。有效负载仅包含两个信息图：通过呈现元数据表达 [=可验证呈现=] 本身的 [=可验证呈现图=]；以及相应的 [=可验证凭证图=]，由 `verifiableCredential`
        属性引用。[=可验证凭证图=] 包含单个 <a href="#defn-EnvelopedVerifiableCredential">`EnvelopedVerifiableCredential`</a> 实例，通过
        `data:` URL [[RFC2397]] 引用，指向通过 <a href="#info-graph-vc-jwt"></a> 上显示的 [=封装证明=] 保护的可验证凭证。
      </p>

      <figure id="info-graph-vp-jwt">
        <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-jwt.svg" alt="Diagram with, on the left, a box, labeled as
'JWT (Decoded)', and with three textual labels stacked vertically,
namely 'Header', 'Payload', and 'Signature'. The 'Header' label is
connected, with an arrow, to a separate rectangle on the right hand
side containing six text fields: 'kid: aB8J-_Z', 'alg: ES384', and
'cty: vc+ld+json', iss: https://example.com, iat: 1704690029, and typ:
vp+ld+json+sd-jwt The 'Payload' label of the left side is connected,
with an arrow, to a separate rectangle, consisting of two related
graphs (stacked vertically) connected by a an arrow labeled
'verifiableCredential'. The two graphs have each a label 'verifiable
presentation graph (serialized in JSON)' and 'verifiable credential
graph (serialized in JSON)', respectively. The top graph in the
rectangle has and object 'Presentation ABC' with 3 properties: 'type'
of value VerifiablePresentation, 'termsOfUse' of value 'Do Not
Archive'. The bottom graph includes
'data:application/vc+ld+json+sd-jwt;QzVjV...RMjU' as a subject with a
single property: 'type' of value `EnvelopedVerifiableCredential`.
Finally, the 'Signature' label on the left side is connected, with an
arrow, to a separate rectangle, containing a single text field:
'XaOOh4ljklxH7L99RTVSfOl...'.
          ">
        <figcaption style="text-align: center;">
          与基本[=可验证呈现=]相关的信息图，该呈现使用基于JOSE [[?VC-JOSE-COSE]]的[=封装证明=]。
          `data:` URL指向<a href="#info-graph-vc-jwt"></a>上显示的[=可验证凭证=]。
        </figcaption>
      </figure>


      <p class="note">
        可以有一个[=呈现=]，例如一组大学凭证，它们依赖于关于不同[=主题=]的多个[=凭证=]，这些主题通常是相关的，但不是必须的。
        这是通过使用`verifiableCredential`属性来引用多个[=可验证凭证=]来实现的。
        有关更多详细信息，请参见附录<a href="#additional-diagrams-for-verifiable-presentations"></a>。
      </p>

    </section>

    <section class="informative">
      <h3>具体生命周期示例</h3>

      <p>
        前面的章节使用图形描述介绍了[=claims=]、[=verifiable credentials=]和[=verifiable
        presentations=]的概念。本节提供了一个具体的简单但完整的生命周期示例，用本规范支持的一种具体语法表示数据模型。在
        <a href="#ecosystem-overview">可验证凭证生态系统</a>中，[=credentials=]和[=presentations=]的生命周期通常遵循以下路径：
      </p>

      <ol>
        <li>
          发行一个或多个[=verifiable credentials=]。
        </li>
        <li>
          将[=verifiable credentials=]存储在[=credential repository=]（如数字钱包）中。
        </li>
        <li>
          将[=verifiable credentials=]组合成一个[=verifiable presentation=]，供[=verifiers=]使用。
        </li>
        <li>
          [=verifier=]对[=verifiable presentation=]进行[=Verification=]。
        </li>
        <li>
          [=verifier=]对包含在[=verifiable presentation=]中的相关[=claims=]进行[=Validation=]。
        </li>
      </ol>

      <p>
        为了说明这个生命周期，我们将使用从大学兑换校友折扣的例子。在下面的例子中，Pat从一所大学获得了一份校友[=verifiable credential=]，并将这个[=verifiable
        credential=]存储在一个数字钱包中。
      </p>

      <pre class="example nohighlight" title="一个可验证凭证内容的简单示例">
{
  <span class='comment'>// 设置上下文，建立我们将使用的特殊术语
  // 如'issuer'和'alumniOf'。</span>
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class='comment'>// 指定凭证的标识符</span>
  "id": "http://university.example/credentials/1872",
  <span class='comment'>// 凭证类型，声明凭证中期望的数据</span>
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  <span class='comment'>// 发行凭证的实体</span>
  "issuer": "https://university.example/issuers/565049",
  <span class='comment'>// 凭证发行的时间</span>
  "validFrom": "2010-01-01T19:23:24Z",
  <span class='comment'>// 关于凭证主题的声明</span>
  "credentialSubject": {
    <span class='comment'>// 凭证唯一主题的标识符</span>
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    <span class='comment'>// 关于凭证唯一主题的断言</span>
    "alumniOf": {
      <span class='comment'>// 大学的标识符</span>
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      <span class='comment'>// 大学的名称</span>
      "name": "Example University"
    }
  }
}
        </pre>

      <p>
        然后，Pat尝试兑换校友折扣。[=verifier=]，一个票务销售系统，声明“Example
        University”的校友可以获得体育赛事季票的折扣。使用移动设备，Pat开始购买季票的过程。在这个过程中的一个步骤请求一个校友[=verifiable
        credential=]，这个请求被路由到Pat的数字钱包。数字钱包询问Pat是否愿意提供以前发行的[=verifiable credential=]。Pat选择了校友[=verifiable
        credential=]，然后将其组合成一个[=verifiable presentation=]。[=verifiable presentation=]被发送到[=verifier=]并进行[=verified=]。
      </p>
      <p>
        一旦被[=verified=]为真实和当前的，季票的卖家然后验证[=verifiable credential=]的[=issuer=]是否被认可为校友状态的声明——它是，因为它是由Example
        University发行的——并且今天的日期在由`validFrom`和`validUntil`属性定义的有效期内。由于期望[=holder=]是[=verifiable
        credential=]的[=subject=]，[=verifier=]也确认校友声明的`id`与[=verifiable presentation=]的创建者的`id`匹配。
      </p>
      <p>
        在[=verified=]了凭证和演示，并验证了相关的声明后，票务销售商安全地为Pat启用了校友折扣，确信Pat有合法的权利享受这个折扣。
      </p>
      <pre class="example nohighlight" title="一个可验证演示的简单示例">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": "VerifiablePresentation",
  <span class='comment'>// 在上一个示例中发行的可验证凭证</span>
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/1872",
    "type": ["VerifiableCredential", "ExampleAlumniCredential"],
    "issuer": "https://university.example/issuers/565049",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "alumniOf": {
        "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
        "name": "Example University"
      }
    }
  }]
}
        </pre>

      <p class="note">
        上面的例子是未加密的。对于有兴趣了解更多关于保护[=verifiable credentials=]的实现者，可以参见规范[[[VC-JOSE-COSE]]]
        [[VC-JOSE-COSE]]和[[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]]
        以及[[[VC-SPECS]]]
        [[VC-SPECS]]的"Proofs"部分。
      </p>
    </section>
  </section>

  <section class="normative">
    <h2>基本概念</h2>

    <p>
      本节介绍了规范的一些基本概念，为文档后面的<a href="#advanced-concepts"></a>部分做准备。
    </p>

    <section class="informative">
      <h3>入门</h3>

      <p>
        本规范旨在简化新类型的[=可验证凭证=]原型的设计。开发者可以复制下面的模板，并将其粘贴到常见的[=可验证凭证=]工具中，以开始发布、持有和验证原型凭证。
      </p>

      <p>
        预计开发者会将下面的`MyPrototypeCredential`更改为他们想要创建的凭证类型。由于[=可验证凭证=]涉及主题，因此`credentialSubject`对象中的每个属性值对表示凭证主题的特定属性。一旦开发者添加了若干这样的属性值组合，修改后的对象可以发送给[=可验证凭证=]发行者软件，为开发者创建一个[=可验证凭证=]。从原型设计的角度来看，这就是开发者需要做的所有事情。
      </p>

      <pre class="example nohighlight" title="创建原型可验证凭证的模板">
{
  "@context": ["https://www.w3.org/ns/credentials/v2"],
  "type": ["VerifiableCredential", "MyPrototypeCredential"],
  "credentialSubject": {
    "mySubjectProperty": "mySubjectValue"
  }
}
        </pre>

      <p>
        一旦开发者将他们的凭证原型设计到他们认为所有凭证属性都稳定的程度，建议他们为他们的应用程序生成词汇表和上下文文件，并将它们发布在稳定的URL上，以便其他开发者可以使用相同的词汇表和上下文实现互操作性。这个过程在第<a
          href="#extensibility"></a>节中有介绍。或者，开发者可以重用现有的词汇表和上下文文件，以适应他们的用例。他们可以浏览[[[VC-SPECS]]] [[VC-SPECS]]以获取可重用资源。
      </p>

    </section>
    <section>
      <h3>上下文</h3>

      <p>
        当两个软件系统需要交换数据时，它们需要使用双方都理解的术语。作为一个类比，考虑一下两个人如何交流。两个人必须使用相同的语言，他们使用的词语对彼此必须具有相同的含义。这可能被称为
        <em>对话的上下文</em>。
      </p>
      <p>
        [=可验证的凭证=]和[=可验证的展示=]有许多由[=URLs=]
        [[URL]]标识的属性和值。然而，这些[=URLs=]可能很长，对人类并不友好。在这种情况下，短格式的人类友好别名可能更有帮助。本规范使用`@context`
        [=属性=]将这种短格式别名映射到特定的[=可验证的凭证=]和[=可验证的展示=]所需的[=URLs=]。
      </p>
      <p class="note">
        在JSON-LD中，`@context` [=属性=]也可以用来传递其他细节，如数据类型信息，语言信息，转换规则等，这些超出了本规范的需要，但可能在未来或相关工作中有用。更多信息，请参见
        <a href="https://www.w3.org/TR/json-ld11/#the-context">第3.1节：上下文</a>
        的[[[JSON-LD11]]] [[JSON-LD11]]规范。
      </p>
      <p>
        [=可验证的凭证=]和[=可验证的展示=]必须包含一个`@context` [=属性=]。
      </p>

      <dl>
        <dt><dfn class="export">@context</dfn></dt>
        <dd>
          `@context` [=属性=]的值必须是一个有序集，其中第一项是一个[=URL=]，值为
          `https://www.w3.org/ns/credentials/v2`。作为参考，附录<a href="#base-context"></a>提供了基础上下文的副本。
          数组中的后续项必须由任何组合的[=URLs=]和/或对象组成，每个对象都可以作为
          <a data-cite="JSON-LD11#the-context">JSON-LD上下文</a>处理。
        </dd>
      </dl>
      <p class="note">
        本规范要求存在`@context` [=属性=]
        ，此属性由[[JSON-LD11]]定义。
      </p>
      <pre class="example nohighlight" title="使用@context属性的示例">
{
  <span class="highlight">"@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ]</span>,
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

      <p>
        上面的例子使用基础上下文[=URL=]
        (`https://www.w3.org/ns/credentials/v2`)来确定对话是关于一个[=可验证的凭证=]。第二个[=URL=]
        (`https://www.w3.org/ns/credentials/examples/v2`)确定对话是关于示例的。
      </p>

      <p class="note">
        本文档使用示例上下文[=URL=]
        (`https://www.w3.org/ns/credentials/examples/v2`)来演示示例。实现期望不使用此[=URL=]进行任何其他目的，如在试点或生产系统中使用。
      </p>

      <p>
        在`https://www.w3.org/ns/credentials/v2`上可用的数据是一个静态文档，永远不会更新，应该被下载和缓存。可验证凭证数据模型的相关人类可读词汇文档可在
        <a href="https://www.w3.org/2018/credentials/">https://www.w3.org/2018/credentials/</a>获得。
        这个概念在<a href="#extensibility"></a>章节中有进一步的扩展。
      </p>

    </section>

    <section>
      <h3>标识符</h3>

      <p>
        当对特定事物（如人、产品或组织）进行陈述时，使用该事物的全球唯一标识符可能会很有用。
        全球唯一标识符使其他人能够对同一事物进行陈述。本规范定义了可选的`id`
        [=属性=]用于此类标识符。`id` [=属性=]
        允许在[=可验证的凭证=]中对特定事物进行陈述，并由[=发行者=]在表达
        [=可验证的凭证=]中的对象或[=持有者=]在表达
        [=可验证的展示=]中的对象时设置。`id`值的示例
        包括UUIDs (`urn:uuid:0c07c1ce-57cb-41af-bef2-1b932b986873`)，HTTP URLs
        (`https://id.example/things#123`)和DIDs (`did:example:1234abcd`)。
      </p>

      <p>
        <em>如果</em> `id` [=属性=]存在：
      </p>

      <ul>
        <li>
          `id` [=属性=]必须表达一个标识符，其他人预期会在对该标识符标识的特定事物进行陈述时使用这个标识符。
        </li>
        <li>
          `id` [=属性=]不能有多个值。
        </li>
        <li>
          `id` [=属性=]的值必须是一个[=URL=]，该URL可能会被解引用。
        </li>
      </ul>

      <p class="note">
        开发者应记住，在需要匿名性的场景中，标识符可能会造成伤害。鼓励开发者在考虑此类场景时仔细阅读<a href="#identifier-based-correlation"></a>部分。
        在<a href="#privacy-considerations"></a>部分记录的其他类型的关联机制也会产生隐私问题。在隐私是重要考虑因素的地方，`id` [=属性=]
        可以省略。有些用例不需要，或明确要求省略，`id` [=属性=]。
      </p>

      <dl>
        <dt><dfn class="export">id</dfn></dt>
        <dd>
          `id` [=属性=]的值必须是单个[=URL=]。
          建议`id`中的[=URL=]是一个可以被解引用的URL，如果被解引用，将得到一个包含有关`id`的机器可读信息的文档。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="id属性的使用" data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class="highlight">"id": "http://university.example/credentials/3732"</span>,
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    <span class="highlight">"id": "did:example:ebfeb1f712ebc6f1c276e12ec21"</span>,
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        上述示例使用了两种类型的标识符。第一个标识符用于[=可验证的凭证=]，使用基于HTTP的URL。第二个
        标识符用于[=可验证的凭证=]的[=主题=]（即[=声明=]所涉及的事物），并使用一种[=去中心化标识符=]，也称为[=DID=]。
      </p>

      <p class="note">
        截至本文发布，[=DIDs=]是一种新型标识符，对于[=可验证的凭证=]的有效性并非必需。具体来说，
        [=可验证的凭证=]并不依赖[=DIDs=]，[=DIDs=]也并不依赖[=可验证的凭证=]。然而，预计许多
        [=可验证的凭证=]将使用[=DIDs=]，实现此规范的软件库可能需要解析[=DIDs=]。
        [=DID=]-基础的URL用于表达与[=主题=]、[=发行者=]、[=持有者=]、凭证状态列表、
        加密密钥以及与[=可验证的凭证=]相关的其他机器可读信息相关联的标识符。
      </p>
    </section>

    <section>
      <h3>类型</h3>

      <p>
        处理本文档中指定的对象类型的软件系统
        使用类型信息来确定提供的
        [=可验证凭证=]或[=可验证陈述=]是否适用
        于预期的用例。本规范为表达类型信息定义了一个`type`
        [=属性=]。这种类型信息
        可以在附录中描述的[=验证=]过程中使用
        <a href="#validation"></a>。
      </p>

      <p>
        [=可验证凭证=]和[=可验证陈述=]必须具有
        `type` [=属性=]。也就是说，任何没有`type` [=属性=]的
        [=凭证=]或
        [=陈述=]<em>不是[=可验证的=]</em>，因此既不是[=可验证凭证=]
        也不是[=可验证陈述=]。
      </p>

      <dl>
        <dt><dfn class="export" data-lt="type|types">type</dfn></dt>
        <dd>
          `type` [=属性=]的值必须是，或映射到（通过
          解释`@context`属性），一个或多个[=URLs=]。
          如果提供了多个[=URL=]，则[=URLs=]必须解释为
          无序集合。应使用语法便利功能来简化开发者
          使用。这些便利功能可能包括JSON-LD术语。建议
          `type`中的每个[=URL=]都是一个，如果取消引用，结果
          是一个包含关于
          `type`的机器可读信息的文档。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="使用type属性" data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  <span class="highlight">"type": ["VerifiableCredential", "ExampleDegreeCredential"]</span>,
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        关于本规范，下表列出了必须指定[=类型=]的对象。
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>对象</th>
            <th>类型</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              [=可验证凭证=]&nbsp;对象
            </td>
            <td>
              `VerifiableCredential`以及可选的更具体的
              [=可验证凭证=] [=类型=]。例如，<br>
              `"type": ["VerifiableCredential", "ExampleDegreeCredential"]`
            </td>
          </tr>

          <tr>
            <td>
              [=可验证陈述=]&nbsp;对象
            </td>
            <td>
              `VerifiablePresentation`以及可选的更具体的
              [=可验证陈述=] [=类型=]。例如，<br>
              `"type": ["VerifiablePresentation", "ExamplePresentation"]`
            </td>
          </tr>

          <tr>
            <td>
              <a href="#status">credentialStatus</a>&nbsp;对象
            </td>
            <td>
              有效的[=凭证=]状态[=类型=]。例如，<br>
              `"type": "BitstringStatusListEntry"`
            </td>
          </tr>

          <tr>
            <td>
              <a href="#terms-of-use">termsOfUse</a>&nbsp;对象
            </td>
            <td>
              有效的使用条款[=类型=]。例如，<br>
              `"type": "ExampleTermsPolicy"`
            </td>
          </tr>

          <tr>
            <td>
              <a href="#evidence">evidence</a>&nbsp;对象
            </td>
            <td>
              有效的证据[=类型=]。例如，<br>
              `"type": "ExampleEvidence"`
            </td>
          </tr>

        </tbody>
      </table>

      <p class="note">
        可验证凭证数据模型的[=类型=]系统与[[JSON-LD11]]的系统相同，详细信息在
        <a href="https://www.w3.org/TR/json-ld/#specifying-the-type">第3.5节:
          指定类型</a>和
        <a href="https://www.w3.org/TR/json-ld/#json-ld-grammar">第9节: JSON-LD
          语法</a>中有详细描述。在使用JSON-LD上下文（参见第
        <a href="#extensibility"></a>节）时，本规范将
        `@type`关键字别名为`type`，以使JSON-LD文档
        更易于理解。虽然应用开发者和文档作者不需要理解JSON-LD类型系统的具体细节，但希望支持互操作扩展性的本规范的实现者需要理解。
      </p>

      <p>
        所有[=凭证=]、[=陈述=]和封装对象应该
        指定，或与，更窄的[=类型=]（如
        `ExampleDegreeCredential`，例如）相关联，以便软件系统可以
        更容易地检测和处理这些额外的信息。
      </p>

      <p>
        在处理本规范中定义的封装对象时（例如，与`credentialSubject`对象或
        深层嵌套在其中的对象相关联），软件系统应使用
        在层次结构中更高的封装对象中指定的[=类型=]信息。具体来说，一个
        封装对象，如[=凭证=]，应传达关联对象[=类型=]，以便[=验证者=]可以快速确定基于封装对象[=类型=]的关联对象的内容。
      </p>

      <p>
        例如，一个具有`type`为
        `ExampleDegreeCredential`的[=凭证=]对象，向[=验证者=]发出信号，表示
        与`credentialSubject`属性关联的对象包含以下的
        标识符：
      </p>

      <ul>
        <li>
          在`id`属性中的[=主题=]。
        </li>
        <li>
          在`type`属性中的学位类型。
        </li>
        <li>
          在`name`属性中的学位标题。
        </li>
      </ul>

      <p>
        这使得实现者可以依赖与
        `type`属性关联的值进行[=验证=]。[=类型=]及其关联属性的期望应至少在人类可读的规范中记录，最好在另一个机器可读的表示中记录。
      </p>

      <p class="note">
        本规范中描述的数据模型中使用的类型系统允许
        以多种方式将类型与数据关联。实现者和作者被敦促阅读可验证凭证
        实施指南[[?VC-IMP-GUIDE]]中关于类型的部分。
      </p>

    </section>

    <section>
      <h3>名称和描述</h3>

      <p>
        在显示一个[=credential=]时，由[=issuer=]提供的文本可以为
        [=credential=]提供一个名称以及其目的的简短描述。`name` 和 `description` [=properties=]
        就是为了实现这些目的。
      </p>

      <dl>
        <dt><dfn class="export">name</dfn></dt>
        <dd>
          一个可选的属性，表示[=credential=]的名称。如果
          存在，`name` [=property=]的值必须是一个字符串或
          如<a href="#language-and-base-direction"></a>所述的语言值对象。理想情况下，一个
          [=credential=]的名称简洁、易于阅读，并能让个人
          快速区分他们可能持有的其他任何[=credentials=]。
        </dd>
        <dt><dfn class="export">description</dfn></dt>
        <dd>
          一个可选的属性，传达关于[=credential=]的具体细节。如果
          存在，`description` [=property=]的值必须是一个
          字符串或如<a href="#language-and-base-direction"></a>所述的语言值对象。理想情况下，一个
          [=credential=]的描述长度不超过几句话，传达足够的
          关于[=credential=]的信息，以提醒个人其内容
          而无需查看全部的[=claims=]。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of the name and description property"
        data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": "Example University",
    "description": "A public university focusing on teaching examples."
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": "Example University Degree",
  "description": "2015 Bachelor of Science and Arts Degree",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        名称和描述还支持以不同的语言表达内容。
        要表达带有语言和[=基本方向=]信息的字符串，
        可以使用包含`@value`、`@language`和`@direction`属性的对象，
        分别表示文本值、语言标签和基本方向。
        有关详细信息，请参见
        <a href="#language-and-base-direction"></a>。
      </p>

      <pre class="example nohighlight" title="Usage of the name and description property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": [{
      "@value": "Example University",
      "@language": "en"
    }, {
      "@value": "Université de Exemple",
      "@language": "fr"
    }, {
      "@value": "جامعة المثال",
      "@language": "ar",
      "@direction": "rtl"
    }],
    "description": [{
      "@value": "A public university focusing on teaching examples.",
      "@language": "en"
    }, {
      "@value": "Une université publique axée sur l'enseignement des exemples.",
      "@language": "fr"
    }, {
      "@value": "جامعة عامة تركز على أمثلة التدريس.",
      "@language": "ar",
      "@direction": "rtl"
    }]
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": [{
    "@value": "Example University Degree",
    "@language": "en"
  }, {
    "@value": "Exemple de Diplôme Universitaire",
    "@language": "fr"
  }, {
    "@value": "مثال الشهادة الجامعية",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "description": [{
    "@value": "2015 Bachelor of Science and Arts Degree",
    "@language": "en"
  }, {
    "@value": "2015 Baccalauréat Scientifique et Arts",
    "@language": "fr"
  }, {
    "@value": "2015 بكالوريوس العلوم والآداب",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": [{
        "@value": "Bachelor of Science and Arts Degree",
        "@language": "en"
      }, {
        "@value": "Baccalauréat Scientifique et Arts",
        "@language": "fr"
      }, {
        "@value": "بكالوريوس العلوم والآداب",
        "@language": "ar",
        "@direction": "rtl"
      }]
    }
  }
}
        </pre>
    </section>

    <section>
      <h3>凭证主体</h3>

      <p>
        一个可验证凭证包含关于一个或多个主体的声明。本规范定义了一个 `credentialSubject` 属性，用于表达关于一个或多个主体的声明。
      </p>

      <p>
        一个可验证凭证必须具有 `credentialSubject` 属性。
      </p>

      <dl>
        <dt><dfn class="export" id="defn-credentialSubject">credentialSubject</dfn></dt>
        <dd>
          `credentialSubject` 属性的值被定义为一组对象，其中每个对象必须是一个或多个声明的主体，这些声明必须被序列化在 `credentialSubject` 属性内部。
          每个对象也可以包含一个 `id` 来标识主体，如第 <a href="#identifiers"></a> 节所述。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of the credentialSubject property"
        data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  <span class="highlight">"credentialSubject"</span>: {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        可以在可验证凭证中表达与多个主体相关的信息。下面的示例指定了两个配偶作为主体。请注意，使用数组表示法将多个主体与 `credentialSubject` 属性关联起来。
      </p>

      <pre class="example nohighlight" title="Specifying multiple subjects in a verifiable credential">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "https://example.com/issuer/123",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": <span class="highlight">[{
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Jayden Doe",
    "spouse": "did:example:c276e12ec21ebfeb1f712ebc6f1"
  }, {
    "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
    "name": "Morgan Doe",
    "spouse": "did:example:ebfeb1f712ebc6f1c276e12ec21"
  }]</span>
}
        </pre>

    </section>

    <section>
      <h3>发行者</h3>

      <p>
        本规范定义了一个用于表示[=verifiable credential=]的[=issuer=]属性。
      </p>

      <p>
        一个[=verifiable credential=]必须具有一个`issuer`[=property=]。
      </p>

      <dl>
        <dt><var id="defn-issuer">issuer</var></dt>
        <dd>
          `issuer`[=property=]的值必须是一个[=URL=]，或者是一个包含`id`[=property=]的对象，其值为[=URL=]；在任何情况下，发行者都选择这个[=URL=]以全球无歧义的方式识别自己。建议该[=URL=]为一个可解引用的URL，解引用后的结果是一个关于[=issuer=]的控制器文档，如[[VC-DATA-INTEGRITY]]或[[VC-JOSE-COSE]]中定义的，可用于[=verify=]在[=credential=]中表达的信息。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of issuer property"
        data-vc-vm="https://university.example/issuers/14#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": "https://university.example/issuers/14"</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p>
        还可以通过将一个对象与发行者属性关联起来来表达有关发行者的其他信息：
      </p>

      <pre class="example nohighlight vc" title="Usage of issuer expanded property"
        data-vc-vm="did:example:76e12ec712ebc6f1c221ebfeb1f#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": {
    "id": "did:example:76e12ec712ebc6f1c221ebfeb1f",
    "name": "Example University"
  }</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p class="note">
        `issuer` [=property=] 的值也可以是一个 JWK（例如，`"https://example.com/keys/foo.jwk"`）或者一个
        [=DID=]（例如，`"did:example:abfe13f712120431c276e12ecab"`）。
      </p>

    </section>

    <section>
      <h3>有效期</h3>

      <p>
        本规范定义了`validFrom` [=property=]，以帮助发行者表达[=credential=]生效的日期和时间，以及`validUntil`
        [=property=]，用于表达[=credential=]失效的日期和时间。
      </p>

      <p>
        在比较日期和时间时，计算是“时间性”的，这意味着字符串值被转换为存在于时间轴上的一个点的“时间值”。然后通过检查要比较的日期和时间相对于时间轴上的特定点的位置来进行时间比较。
      </p>

      <dl>
        <dt><var id="defn-validFrom">validFrom</var></dt>
        <dd>
          如果存在，`validFrom` [=property=]的值必须是一个
          [<a data-cite="XMLSCHEMA11-2#dateTime">XMLSCHEMA11-2</a>]
          `dateTimeStamp`字符串值，表示[=credential=]生效的日期和时间，可以是未来或过去的日期和时间。请注意，此值表示与`credentialSubject`
          [=property=]关联的信息生效的最早时间点。如果还存在`validUntil`值，则
          `validFrom`值必须表示与`validUntil`值表示的日期时间相同或更早的日期时间。
        </dd>
        <dt><var id="defn-validUntil">validUntil</var></dt>
        <dd>
          如果存在，`validUntil` [=property=]的值必须是一个
          [<a data-cite="XMLSCHEMA11-2#dateTime">XMLSCHEMA11-2</a>]
          `dateTimeStamp`字符串值，表示[=credential=]失效的日期和时间，可以是过去或未来的日期和时间。请注意，此值表示与`credentialSubject`
          [=property=]关联的信息有效的最晚时间点。如果还存在`validFrom`值，则`validUntil`
          值必须表示与`validFrom`值表示的日期时间相同或更晚的日期时间。
        </dd>
      </dl>

      <pre class="example nohighlight vc" title="Usage of validFrom and validUntil property"
        data-vc-vm="https://university.example/issuers/14#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  <span class="highlight">"validFrom": "2010-01-01T19:23:24Z"</span>,
  <span class="highlight">"validUntil": "2020-01-01T19:23:24Z"</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

      <p class="note">
        如果`validFrom`和`validUntil`不存在，则认为[=可验证凭证=]的有效期无限。在这种情况下，假定[=可验证凭证=]从创建时开始有效。
      </p>

      <h4>表示时间</h4>

      <p>
        实现者应该了解，表示和处理时间值并非像看起来那么简单，并且在世界不同地区有各种各样的特殊性。例如：
      </p>

      <ul>
        <li>
          除了公历日历系统外，其他日历系统也被各个地区积极使用。
        </li>
        <li>
          在处理夏令时/夏时制时，重要的是要了解：1) 并非所有地区都遵循夏令时，2) 开始和结束的日期或时间并不一定相同，3) 调整的幅度或方向并不总是与其他类似地区相匹配。
        </li>
        <li>
          跳秒可能不会在所有软件系统中考虑，尤其是对于在引入跳秒之前的日期和时间。跳秒会影响那些依赖于从纪元开始的精确毫秒偏移的高度敏感系统。然而，请注意，对于大多数应用程序，唯一受影响的时间点是跳秒本身的那一秒。也就是说，最近一次跳秒之后的时刻总是可以表示为下一天的第一个时刻（例如，`2023-01-01T00:00:00Z`），无论所讨论的系统是否理解跳秒。
        </li>
      </ul>

      <p>
        这些只是一些例子，说明实际的一天时间，如墙上的时钟所示，在一个地区可能存在，而在另一个地区可能不存在。因此，实现者应该使用更通用的时间值，如锚定在`Z`时区的值，而不是受夏令时/夏时制影响的值。
      </p>

      <p>
        本规范试图增加通用认可的日期和时间组合的数量，并通过使用首次由[<a data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a>]规范建立的
        `dateTimeStamp`构造来减少时间值误解的可能性。为了减少不同时区之间的误解，所有在[=符合规范的文档=]中表示的时间值都应该以`dateTimeStamp`
        格式指定，要么是世界协调时间（UTC），用`Z`表示，要么是相对于UTC的时区偏移。没有偏移的错误序列化的时间值必须解释为UTC。相对于UTC的有效时区偏移的示例包括`Z`、`+01:00`、`-08:00`和
        `+14:00`。请参阅本节末尾的正则表达式，以获取所有可接受值的正式定义。
      </p>

      <p>
        时区定义有时会被其管理机构更改。在更换或发布新的[=可验证证书=]时，实现者应确保当地时区规则的更改不会导致意外的有效期间隙。例如，考虑时区`America/Los_Angeles`，其原始偏移为UTC-8，并在2024年投票决定停止遵循夏令时。一个给定的[=可验证证书=]，其`validUtil`
        值为`2024-07-12T12:00:00-07:00`，可能会被重新发布，使其`validFrom`值为`2024-07-12T12:00:00-08:00`，这将导致一个小时的间隙，在这个间隙内，[=可验证证书=]将无效。
      </p>

      <p>
        希望检查`dateTimeStamp`值有效性的实现者可以使用下面提供的正则表达式，该正则表达式是从[<a
          data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a>]规范中复制过来的，以方便使用。为避免疑虑，[[XMLSCHEMA11-2]]中的正则表达式是规范性定义。实现者应注意，并非所有通过下面正则表达式的`dateTimeStamp`值都是有效的时间点。例如，下面的正则表达式允许每个月有31天，这包括闰年和闰秒，以及那些不存在的地方的日子。话虽如此，现代系统库生成的`dateTimeStamp`值在生成有效的`dateTimeStamp`值时通常是无误的。下面显示的正则表达式（减去为了可读性而包含的空白），在处理现代系统上库生成的日期和时间时通常是足够的。
      </p>

      <pre class="example nohighlight"
        title="Regular expression to detect a valid XML Schema 1.1: Part 2 dateTimeStamp">
-?([1-9][0-9]{3,}|0[0-9]{3})
-(0[1-9]|1[0-2])
-(0[1-9]|[12][0-9]|3[01])
T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))
(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))
        </pre>

    </section>

    <section>
      <h3>安全机制</h3>

      <p>
        本规范认可两类安全机制：使用封装证明的机制和使用嵌入式证明的机制。
      </p>

      <p>
        一个<dfn class="export">封装证明</dfn>是包裹了此数据模型序列化的证明。[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]中定义了一种建议的封装证明机制。
      </p>

      <p>
        一个<dfn class="export">嵌入式证明</dfn>是一种证明包含在数据模型序列化中的机制。[[[VC-DATA-INTEGRITY]]]
        [[VC-DATA-INTEGRITY]]中定义了一种建议的嵌入式证明机制。
      </p>

      <p>
        这两类安全机制并非互斥。根据第<a href="#securing-mechanism-specifications"></a>节的规则，还可以定义其他安全机制规范。
      </p>

      <pre class="example nohighlight" title="A verifiable credential utilizing an embedded proof">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.gov/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-rdfc-2022",
    "created": "2021-11-13T18:19:39Z",
    "verificationMethod": "https://university.example/issuers/14#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z58DAdFfa9SkqZMVPxAQp...jQCrfFPP2oumHKtz"
  }</span>
}
        </pre>

      <pre class="example nohighlight" title="A verifiable credential that uses an enveloping proof in SD-JWT format">
eyJhbGciOiJFUzM4NCIsImtpZCI6IkdOV2FBTDJQVlVVMkpJVDg5bTZxMGM3U3ZjNDBTLWJ2UjFTT0
Q3REZCb1UiLCJ0eXAiOiJ2YytsZCtqc29uK3NkLWp3dCIsImN0eSI6InZjK2xkK2pzb24ifQ
.
eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvbnMvY3JlZGVudGlhbHMvdjIiLCJodHRwcz
ovL3d3dy53My5vcmcvbnMvY3JlZGVudGlhbHMvZXhhbXBsZXMvdjIiXSwiaXNzdWVyIjoiaHR0cHM6
Ly91bml2ZXJzaXR5LmV4YW1wbGUvaXNzdWVycy81NjUwNDkiLCJ2YWxpZEZyb20iOiIyMDEwLTAxLT
AxVDE5OjIzOjI0WiIsImNyZWRlbnRpYWxTY2hlbWEiOnsiX3NkIjpbIlNFOHp4bmduZTNNbWEwLUNm
S2dlYW1rNUVqU1NfOXRaNlN5NDdBdTdxRWMiLCJjT3lySEVrSlZwdEtSdURtNkNZVTREajJvRkExd0
JQRjFHcTJnWEo1NXpzIl19LCJjcmVkZW50aWFsU3ViamVjdCI6eyJkZWdyZWUiOnsibmFtZSI6IkJh
Y2hlbG9yIG9mIFNjaWVuY2UgYW5kIEFydHMiLCJfc2QiOlsibVNfSVBMa0JHcTIxbVA3Z0VRaHhOck
E0ZXNMc1ZKQ1E5QUpZNDFLLVRQSSJdfSwiX3NkIjpbIlhTSG9iU05Md01PVl9QNkhQMHNvMnZ1clNy
VXZ3UURYREJHQWtyTXk3TjgiXX0sIl9zZCI6WyJQNE5qWHFXa2JOc1NfRzdvdmlLdm1NOG0yckhDTm
5XVVV2SXZBbW9jb2RZIiwieFNvSHBKUXlCNGV1dmg4SkFJdDFCd1pjNFVEOHY5S3ZOTmVLMk9OSjFC
QSJdLCJfc2RfYWxnIjoic2hhLTI1NiIsImlzcyI6Imh0dHBzOi8vdW5pdmVyc2l0eS5leGFtcGxlL2
lzc3VlcnMvNTY1MDQ5IiwiaWF0IjoxNzAzNjI1OTAxLCJleHAiOjE3MzUyNDgzMDEsImNuZiI6eyJq
d2siOnsia3R5IjoiRUMiLCJjcnYiOiJQLTM4NCIsImFsZyI6IkVTMzg0IiwieCI6Inl1Zlo1SFUzcU
NfOTRMbkI3Zklzd0hmT0swQlJra0Z5bzVhd1QyX21ld0tJWUpLMVNfR0QySVB3UjRYUTZpdFEiLCJ5
IjoiRmEtV2pOd2NLQ1RWWHVDU2tCY3RkdHJOYzh6bXdBTTZWOWxudmxxd1QyQnRlQ0ZHNmR6ZDJoMF
VjeXluTDg0dCJ9fX0
.
M7BFJB9LEV_xEylSJpP00fd_4WjrOlXshh0dUv3QgOzw2MEGIfSfi9PoCkHJH7TI0InsqkD6XZVz38
MpeDKekgBW-RoDdJmxnifYOEJhKpJ5EN9PvA007UPi9QCaiEzX
~
WyJFX3F2V09NWVQ1Z3JNTkprOHNXN3BBIiwgImlkIiwgImh0dHA6Ly91bml2ZXJzaXR5LmV4YW1wbG
UvY3JlZGVudGlhbHMvMTg3MiJd
~
WyJTSEc4WnpfRDVRbFMwU0ZrZFUzNXlRIiwgInR5cGUiLCBbIlZlcmlmaWFibGVDcmVkZW50aWFsIi
wgIkV4YW1wbGVBbHVtbmlDcmVkZW50aWFsIl1d
~
WyJqZzJLRno5bTFVaGFiUGtIaHV4cXRRIiwgImlkIiwgImh0dHBzOi8vZXhhbXBsZS5vcmcvZXhhbX
BsZXMvZGVncmVlLmpzb24iXQ
~
WyItQmhzaE10UnlNNUVFbGt4WGVXVm5nIiwgInR5cGUiLCAiSnNvblNjaGVtYSJd~WyJ0SEFxMEUwN
nY2ckRuUlNtSjlSUWRBIiwgImlkIiwgImRpZDpleGFtcGxlOjEyMyJd
~
WyJ1Ynd6bi1kS19tMzRSMGI0SG84QTBBIiwgInR5cGUiLCAiQmFjaGVsb3JEZWdyZWUiXQ
        </pre>

    </section>

    <section>
      <h3>状态</h3>

      <p>
        本规范为[=verifiable credential=]的状态信息（如是否被暂停或撤销）的发现定义了`credentialStatus` [=property=]。
      </p>

      <p>
        下面为与<strong id="defn-credentialStatus">credentialStatus</strong> [=property=]关联的对象值定义了以下属性：
      </p>

      <dl>
        <dt>id</dt>
        <dd>
          `id` [=property=]是可选的。它可以用于为凭证状态对象提供唯一标识符。如果存在，必须遵循第<a href="#identifiers"></a>节的规范性指南。
        </dd>
        <dt>type</dt>
        <dd>
          `type` [=property=]是必需的。它用于表示对象所表达的状态信息的类型。必须遵循第<a href="#types"></a>节的相关规范性指南。
        </dd>
      </dl>

      <p>
        [=credential=]状态信息的确切内容由特定的`credentialStatus`
        [=type=]定义决定，具体取决于诸如实现简单性和是否增强隐私等因素。预期该值将提供足够的信息来确定[=credential=]的当前状态，并且可以从URL检索机器可读信息。例如，对象可以包含指向外部文档的链接，该文档注明[=credential=]是否被暂停或撤销。
      </p>

      <pre class="example nohighlight" title="Usage of the status property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://w3id.org/vc/status-list/2021/v1"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialStatus": {
    "id": "https://university.example/credentials/status/3#94567",
    "type": "BitstringStatusListEntry",
    "statusPurpose": "revocation",
    "statusListIndex": "94567",
    "statusListCredential": "https://university.example/credentials/status/3"
  }</span>
}
        </pre>

      <p>
        定义状态方案的数据模型、格式和协议超出了本规范的范围。存在一个可验证的凭证规范目录
        [[?VC-SPECS]]，其中包含了实施者想要实施[=可验证的凭证=]
        状态检查的可用状态方案。
      </p>

      <p>
        创建状态方案的规范作者提供了以下指南：
      </p>

      <ul>
        <li>
          状态方案绝对不能以使得能够追踪个人的方式实施，例如，当一个[=验证者=]对特定的[=持有人=]
          或[=主题=]感兴趣时，[=发行者=]被通知（直接或间接）。不可接受的方法包括"电话回家"，即
          每次使用凭证都会联系凭证的[=发行者=]，以检查特定个人的状态，或者"伪名减少"，即
          每次使用凭证都会导致从[=发行者=]那里请求信息，这些信息可以被[=发行者=]用来推断
          [=验证者=]对特定个人的兴趣。
        </li>
      </ul>

    </section>

    <section>
      <h3>展示</h3>

      <p>
        [=可验证展示=] 可用于汇总来自多个 [=可验证凭证=] 的信息。
      </p>
      <p>
        [=可验证展示=] 应该非常短暂，并绑定到由 [=验证者=] 提供的挑战。实现这一点的细节取决于安全机制、传输协议和 [=验证者=] 策略。除非特定的安全机制或嵌入协议定义了其他要求，否则 [=验证者=] 通常无法假定
        [=可验证展示=] 与所提供的 [=可验证凭证=] 之间存在任何关联。
      </p>

      <p>
        [=可验证展示=] 的 [=默认图=] 也被称为 <dfn>可验证展示图</dfn>。
      </p>

      <p>
        下面为 [=可验证展示=] 定义了以下属性：
      </p>

      <dl>
        <dt>|id|</dt>
        <dd>
          `id` [=属性=] 是可选的。它可以用于为 [=可验证展示=] 提供唯一标识符。如果存在，必须遵循第 <a href="#identifiers"></a> 节的规范性指南。
        </dd>
        <dt>|type|</dt>
        <dd>
          `type` [=属性=] 必须存在。它用于表示 [=可验证展示=] 的类型。此属性的一个值必须是 `VerifiablePresentation`，但可以包含其他类型。必须遵循第 <a
            href="#types"></a> 节的相关规范性指南。
        </dd>
        <dt><var id="defn-verifiableCredential">verifiableCredential</var></dt>
        <dd>
          `verifiableCredential` [=属性=] 可以存在。该值必须是一个或多个 [=可验证凭证=] 和/或
          <a href="#enveloped-verifiable-credentials">封装的可验证凭证</a>
          对象（明确地说，值不能是非对象值，如数字、字符串或URL）。这些类型的对象称为
          <a href="#verifiable-credential-graphs">可验证凭证图</a>，并且必须使用
          <a href="#securing-mechanisms">安全机制</a>来表达已加密的信息。
          请参阅第 <a href="#verifiable-credential-graphs"></a> 节以获取更多详细信息。
        </dd>
        <dt><var id="defn-holder">holder</var></dt>
        <dd>
          [=可验证展示=] 可以包含一个 `holder`
          [=属性=]。如果存在，其值必须是一个 [=URL=] 或包含 `id` [=属性=] 的对象。建议 `holder` 中的 [=URL=] 或其 `id` 是一个可以解引用的 URL，解引用后会得到一个包含关于
          [=持有者=] 的机器可读信息的文档，该信息可用于 [=验证=] 在 [=可验证展示=] 中表达的信息。
          如果 `holder` [=属性=] 不存在，则预期关于 [=持有者=] 的信息将通过安全机制获得，或者与 [=可验证展示=] 的 [=验证=] 无关。
        </dd>
      </dl>

      <p>
        下面的示例显示了一个 [=可验证展示=]：
      </p>

      <pre class="example nohighlight" title="Basic structure of a presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5",
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{ <span class="comment">...</span> }]
}
        </pre>

      <p>
        上述的 `verifiableCredential` 属性的内容是本规范所描述的可验证凭证图。
      </p>

      <section>
        <h4>封装的可验证凭证</h4>

        <p>
          一个[=可验证的展示=]可以包含一个或多个使用安全机制保护的
          [=可验证的凭证=]，这种安全机制会"封装"载荷，例如[[[?VC-JOSE-COSE]]] [[?VC-JOSE-COSE]]。
          这可以通过将`verifiableCredential`属性与一个`type`为`EnvelopedVerifiableCredential`的对象关联来实现。
        </p>

        <dl>
          <dt id="defn-EnvelopedVerifiableCredential">封装的可验证凭证</dt>
          <dd>
            用于将包含封装的[=可验证凭证=]的对象与[=可验证的展示=]中的`verifiableCredential`属性关联。
            对象的`@context`属性必须存在并包含一个上下文，
            例如<a href="#base-context">此规范的基础上下文</a>，
            至少定义了`id`、`type`和`EnvelopedVerifiableCredential`
            这些术语，这些术语由此规范提供的基础上下文定义。对象的`id`
            值必须是一个`data:` URL [[RFC2397]]，它用
            <a href="#dfn-enveloping-proof">封装</a>的安全方案表达了一个安全的
            [=可验证凭证=]，例如[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]。对象的`type`值必须是
            `EnvelopedVerifiableCredential`。
          </dd>
        </dl>

        <p>
          下面的例子展示了一个包含封装的[=可验证凭证=]的[=可验证的展示=]：
        </p>

        <pre class="example nohighlight" title="Basic structure of a presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "id": "data:application/vc+ld+json+sd-jwt;QzVjV...RMjU",
    "type": "EnvelopedVerifiableCredential"
  }]</span>
}
        </pre>

      </section>

      <section>
        <h4>使用派生凭证的演示</h4>

        <p>
          一些零知识密码学方案可能使[=持有人=]能够
          间接证明他们持有来自[=可验证凭证=]的[=声明=]
          而无需揭示该[=可验证凭证=]中的所有声明。在这些
          方案中，[=可验证凭证=]可用于派生可呈现的
          数据，这些数据经过加密断言，使得[=验证者=]可以信任
          该值（如果他们信任[=颁发者=]）。
        </p>
        <p>
          一些选择性披露方案可以共享从[=可验证凭证=]派生的[=声明=]子集。
        </p>

        <p class="note">
          有关包含派生数据而非直接嵌入[=可验证凭证=]的ZKP风格[=可验证演示=]的示例，请参见第<a href="#zero-knowledge-proofs"></a>节。
        </p>

        <figure>
          <img style="margin: auto; display: block; width: 50%;" src="diagrams/claim-example-2.svg" alt="Pat拥有一个
                 overAge属性，其值为21">
          <figcaption style="text-align: center;">
            表示Pat年龄超过21岁的基本声明。
          </figcaption>
        </figure>
      </section>
      <section>
        <h4>包含持有人声明的展示</h4>
        <p>
          [=持有人=]可以在[=可验证的展示=]中使用`verifiableCredential`
          [=属性=]，包含来自任何[=发行人=]的[=可验证的凭证=]，包括他们自己。当[=可验证凭证=]的[=发行人=]是[=持有人=]时，该[=可验证凭证=]中的[=声明=]被认为是<em>自我声明</em>。这些自我声明的声明可以通过保护包含它们的[=可验证展示=]的相同机制或任何适用于其他[=可验证凭证=]的机制来保护。
        </p>
        <p>
          这些自我声明的[=声明=]的<a
            href="#dfn-subjects">主题</a>不受限制，因此这些[=声明=]可以包括关于[=持有人=]、其他包含的[=可验证凭证=]之一，甚至包含自我声明的[=可验证凭证=]的[=可验证展示=]的声明。在每种情况下，`id`
          [=属性=]用于在声明关于它的对象中识别特定的[=主题=]，就像在不是自我声明的[=可验证凭证=]中所做的那样。
        </p>
        <p>
          包含仅使用与[=可验证展示=]相同的机制来保护的自我声明的[=可验证凭证=]的[=可验证展示=]必须包含`holder` [=属性=]。
        </p>
        <p>
          为[=可验证凭证=]定义的所有规范性要求都适用于自我声明的[=可验证凭证=]。
        </p>
        <p>
          当使用与[=可验证展示=]相同的机制来保护自我声明的[=可验证凭证=]时，[=可验证凭证=]的`issuer` [=属性=]的值必须与[=可验证展示=]的`holder` [=属性=]相同。
        </p>
        <p>
          下面的示例显示了一个[=可验证展示=]，其中嵌入了使用与[=可验证展示=]相同的机制来保护的自我声明的[=可验证凭证=]。
        </p>

        <pre class="example nohighlight"
          title="A verifiable presentation, secured with an embedded Data Integrity proof, with a self-asserted verifiable credential">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleFoodPreferenceCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      "favoriteCheese": "Gouda"
    },
    { <span class="comment">...</span> }
  }],
  "proof": [{ <span class="comment">...</span> }]
}
          </pre>
        <p>
          下面的示例显示了一个嵌入了自我声明的可验证凭证的可验证展示，该可验证凭证包含关于可验证展示的声明。它使用与可验证展示相同的机制进行保护。
        </p>

        <pre class="example nohighlight"
          title="A verifiable presentation, secured with an embedded Data Integrity proof, with a self-asserted verifiable credential about the verifiable presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleAssertCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
      "assertion": "This VP is submitted by the subject as evidence of a legal right to drive"
    },
    "proof": { <span class="comment">...</span> }
  }],
  "proof": { <span class="comment">...</span> }
}
          </pre>
      </section>
    </section>

    <section>
      <h3>数据模式</h3>

      <p>
        当对给定的数据集合强制执行特定结构时，数据模式很有用。本规范考虑的数据模式至少有两种：
      </p>

      <ul>
        <li>
          数据验证模式，用于确定[=凭证=]或[=可验证凭证=]的结构和内容符合已发布的模式。
        </li>
        <li>
          数据编码模式，用于将[=可验证凭证=]的内容映射到另一种表示格式，例如在零知识证明中使用的格式。
        </li>
      </ul>

      <p>
        重要的是要理解，数据模式与`@context`属性的目的不同，后者既不强制数据结构或数据语法，也不支持定义到替代表示格式的任意编码。
      </p>
      <p>
        本规范为表达数据模式定义了以下[=属性=]，可以由[=发行者=]包含在其发行的[=可验证凭证=]中：
      </p>

      <dl>
        <dt><var id="defn-credentialSchema">credentialSchema</var></dt>
        <dd>
          <p>
            `credentialSchema`
            [=属性=]的值必须是一个或多个数据模式，这些模式为[=验证者=]提供了足够的信息，以确定提供的数据是否符合提供的模式。每个`credentialSchema`必须指定其`type`（例如，`JsonSchema`），以及一个必须是标识模式文件的[=URL=]的`id`
            [=属性=]。每个数据模式的具体内容由特定类型定义决定。
          </p>
          <p>
            如果存在多个模式，则根据每个关联的`credentialSchema` `type`属性所概述的处理规则确定有效性。
          </p>
        </dd>
      </dl>

      <p class="note">
        `credentialSchema`
        [=属性=]提供了注释类型定义或将其锁定到词汇表特定版本的机会。[=可验证凭证=]的作者可以使用`credentialSchema`包含其词汇表的静态版本，该版本被锁定到某种内容完整性保护机制。`credentialSchema`
        [=属性=]还使得可以对[=凭证=]进行语法检查，并使用如JSON Schema [[?VC-JSON-SCHEMA]] 验证等[=验证=]机制。
      </p>

      <pre class="example nohighlight" title="Usage of the credentialSchema property to perform JSON schema validation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential", "ExamplePersonCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    },
    "alumniOf": {
      "name": "Example University"
    }
  },
  <span class="highlight">"credentialSchema": [{
    "id": "https://example.org/examples/degree.json",
    "type": "JsonSchema"
  },
  {
    "id": "https://example.org/examples/alumni.json",
    "type": "JsonSchema"
  }]</span>
}
        </pre>

      <p>
        在上面的示例中，发行者指定了一个`credentialSchema`，它指向一个[[?VC-JSON-SCHEMA]]文件，可以被验证者用来确定可验证凭证是否格式正确。
      </p>

      <p class="note">
        有关与JSON Schema [[?VC-JSON-SCHEMA]]或其他可选模式验证机制的链接信息，请参阅可验证凭证实施指南[[VC-IMP-GUIDE]]文档。
      </p>

      <p>
        数据模式还可以用于指定到其他格式的映射，例如用于执行零知识证明的格式。有关使用`credentialSchema` [=属性=]与零知识证明的更多信息，请参见第<a
          href="#zero-knowledge-proofs"></a>节。
      </p>

      <pre class="example nohighlight"
        title="Usage of the credentialSchema property to perform zero-knowledge validation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialSchema": {
    "id": "https://example.org/examples/degree",
    "type": "ZkpExampleSchema2018"
  }</span>
}
        </pre>

      <p>
        在上面的示例中，发行者指定了一个`credentialSchema`，它指向一种将输入数据转换为格式的方法，然后可以由验证者使用该格式确定可验证凭证所提供的证明是否格式正确。
      </p>


    </section>

  </section>

  <section>
    <h2>高级概念</h2>

    <p>
      在第<a href="#basic-concepts"></a>节介绍的基本概念基础上，本节探讨了关于可验证凭证的更复杂的主题。
    </p>

    <section class="informative">
      <h3>生命周期详细信息</h3>

      <p>
        第<a href="#ecosystem-overview"></a>节提供了
        [=可验证凭证=]生态系统的概述。本节将提供更详细的关于
        生态系统预期运行方式的信息。
      </p>

      <figure id="life-cycle-details">
        <img style="margin: auto; display: block; width: 85%;" src="diagrams/ecosystemdetail.svg" alt="图表显示如何
         凭证从发行者流向持有者，可选地
         从一个持有者流向另一个持有者；以及如何
         展示从持有者流向验证者，其中
         所有参与方可以从逻辑上
         可验证的数据注册处获取信息">
        <figcaption style="text-align: center;">
          本规范的角色和信息流动。
        </figcaption>
      </figure>

      <p class="issue" title="需要将验证过程添加到图像中。">
        需要将验证过程添加到上面的图像中。
      </p>

      <p>
        [=可验证凭证=]生态系统中的角色和信息流动如下：
      </p>

      <ul>
        <li>
          一个[=发行者=] <dfn class="export" data-lt="issue">发行</dfn> 一个
          [=可验证凭证=]给一个[=持有者=]。发行总是在涉及[=凭证=]的任何其他行动之前发生。
        </li>
        <li>
          一个[=持有者=]可能会<dfn class="export" data-lt="transfers">转移</dfn>其一个或多个[=可验证
          凭证=]给另一个[=持有者=]。
        </li>
        <li>
          一个[=持有者=] <dfn class="export" data-lt="present">展示</dfn>其一个或
          多个[=可验证凭证=]给一个[=验证者=]，可选地
          在一个[=可验证的展示=]内部。
        </li>
        <li>
          一个[=验证者=] [=验证=]所展示的
          [=可验证的展示=]和[=可验证的凭证=]的真实性，并
          检查任何<a href="#status">凭证状态</a>（如果存在）
          的[=可验证的凭证=]。
        </li>
        <li>
          在[=验证=]之后，一个[=验证者=]验证所展示的[=可验证凭证=]中的相关声明，
          使用他们自己的业务逻辑来评估哪些发行者适合哪些声明，以及哪些主题适合所请求的使用。
        </li>
        <li>
          一个[=发行者=]可能会<dfn class="export" data-lt="revoke">撤销</dfn>一个
          [=可验证的凭证=]。
        </li>
        <li>
          一个[=持有者=]可能会<dfn class="export" data-lt="delete">删除</dfn>一个
          [=可验证的凭证=]。
        </li>
      </ul>

      <p class="note">
        上述行动的顺序并不固定，有些行动可能会被执行多次。这样的行动重复可能是立即的，也可能在任何以后的时间点。
      </p>

      <p>
        最常见的行动序列预计是：
      </p>

      <ol>
        <li>
          一个[=发行者=] <a href="#lifecycle-details">发行</a> 一个[=可验证
          凭证=]给一个[=持有者=]。
        </li>
        <li>
          该[=持有者=]<a href="#lifecycle-details">向</a>
          一个[=验证者=]展示。
        </li>
        <li>
          该[=验证者=] <a href="#lifecycle-details">验证</a>。
        </li>
        <li>
          该[=验证者=] <a href="#lifecycle-details">验证</a>声明。
        </li>
        <li>
          该[=验证者=] 应用有效声明</a>。
        </li>
      </ol>

      <p>
        本规范没有定义任何用于传输
        [=可验证凭证=]或[=可验证展示=]的协议，但假设
        其他规范确实指定了它们如何在实体之间传输，那么
        这个可验证凭证数据模型就直接适用。
      </p>

      <p>
        本规范既没有定义授权框架，也没有
        限制[=验证者=]在[=验证=]一个[=可验证凭证=]或[=可验证
        展示=]之后可能做出的业务决策。相反，[=验证者=]
        在将任何声明视为有效之前应用自己的业务规则，
        考虑到[=持有者=]，[=可验证凭证=]的[=发行者=]，[=可验证凭证=]的声明，以及[=验证者=]自己的政策。
      </p>

      <p>
        尤其是，第<a href="#terms-of-use"></a>节和
        可验证凭证
        实施指南[[VC-IMP-GUIDE]]中的<a href="https://w3c.github.io/vc-imp-guide/#subject-holder-relationships">
          主题-持有者关系</a>部分说明了[=验证者=]如何
        确定：
      </p>

      <ul>
        <li>
          [=持有者=]是否是[=可验证凭证=]的[=主题=]。
        </li>
        <li>
          [=主题=]与[=持有者=]之间的关系。
        </li>
        <li>
          原始[=持有者=]是否将[=可验证凭证=]传递给
          随后的[=持有者=]。
        </li>
        <li>
          使用[=可验证凭证=]的[=持有者=]
          或[=验证者=]的任何限制。
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>信任模型</h3>

      <p>
        [=可验证凭证=]的信任模型如下：
      </p>

      <ul>
        <li>
          [=验证者=]信任[=颁发者=]颁发其收到的[=凭证=]。为建立这种信任，预期[=凭证=]应该：
          <ul>
            <li>
              使用<a href="#securing-mechanisms">安全机制</a>保护[=凭证=]，确立
              [=颁发者=]生成了[=凭证=]（即，它是一个
              [=可验证凭证=]），或
            </li>
            <li>
              以清晰确立[=颁发者=]生成了[=可验证凭证=]且
              [=可验证凭证=]在传输或存储过程中未被篡改的方式传输。这种
              信任可能会因[=验证者=]的风险评估而削弱。
            </li>
          </ul>
        </li>
        <li>
          所有[=实体=]信任[=可验证数据注册表=]具有防篡改性，并且是哪些数据由哪些
          [=实体=]控制的正确记录。
        </li>
        <li>
          [=持有者=]和[=验证者=]信任[=颁发者=]为[=主题=]颁发
          真实（即，非虚假）的[=凭证=]，并在适当时撤销它们。
        </li>
        <li>
          [=持有者=]信任[=存储库=]安全存储[=凭证=]，
          不向除[=持有者=]以外的任何人发布它们，并且在其保管期间不
          损坏或丢失它们。
        </li>
      </ul>

      <p>
        与其他信任模型相比，这种信任模型确保：
      </p>

      <ul>
        <li>
          [=颁发者=]和[=验证者=]不需要信任
          [=存储库=]
        </li>
        <li>
          [=颁发者=]不需要了解或信任[=验证者=]。
        </li>
      </ul>

      <p>
        通过解耦[=身份提供者=]和
        [=依赖方=]之间的信任，创建了更灵活、更具动态性的信任模型，
        从而增加了市场竞争和客户选择。
      </p>

      <p>
        有关此信任模型与工作组研究的各种威胁模型之间的交互方式的更多信息，请参阅可验证凭证用例文档[[VC-USE-CASES]]。
      </p>

      <p class="note">
        本规范详细介绍的数据模型并不意味着传递性信任模型，例如由更传统的证书颁发机构信任模型提供的那种。在可验证凭证数据模型中，[=验证者=]要么直接信任[=颁发者=]，要么不信任[=颁发者=]。虽然可以使用可验证凭证数据模型构建传递性信任模型，但实施者应该
        <a href="https://datatracker.ietf.org/doc/draft-iab-web-pki-problems/">了解
          安全弱点</a>，这些弱点是由
        <a href="https://www.usenix.org/conference/imc-05/perils-transitive-trust-domain-name-system">
          广泛委托信任</a>的方式引入的，这种方式是证书颁发机构系统所采用的。
      </p>
    </section>

    <section>
      <h3>可扩展性</h3>

      <p>
        可验证凭证数据模型的目标之一是实现无需许可的创新。为实现这一目标，数据模型需要在多个方面具有可扩展性。数据模型需要：
      </p>

      <ul>
        <li>
          通过使用基于[=graph=]的数据模型，对复杂的多实体关系进行建模。
        </li>
        <li>
          通过使用[[?LINKED-DATA]]，扩展用于描述数据模型中信息的机器可读词汇，无需使用集中式系统来实现。
        </li>
        <li>
          通过使用JOSE或COSE [[VC-JOSE-COSE]]，数据完整性证明[[VC-DATA-INTEGRITY]]，以及可验证凭证规范目录[[?VC-SPECS]]中列出的各种加密套件，支持多种类型的加密证明格式。
        </li>
        <li>
          通过使用[[JSON-LD11]]，在受软件开发人员和网页作者欢迎的数据格式中提供上述所有可扩展性机制。
        </li>
      </ul>

      <p>
        这种数据建模方法通常被称为<em>开放世界假设</em>，意味着任何实体都可以对任何其他实体发表任何言论。尽管这种方法似乎与构建简单且可预测的软件系统相冲突，但在开放世界假设下，平衡可扩展性与程序正确性总是比在封闭软件系统中更具挑战性。
      </p>

      <p>
        本节其余部分通过一系列示例描述了如何实现可扩展性和程序正确性。
      </p>

      <p>
        让我们假设我们从下面显示的[=verifiable credential=]开始。
      </p>

      <pre class="example nohighlight vc" title="A simple credential"
        data-vc-vm="https://university.example/issuers/14#keys-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe"
  }
}
        </pre>

      <p>
        这个可验证凭证声明与与`did:example:abcdef1234567`关联的实体具有值为`Jane Doe`的`name`。
      </p>

      <p>
        现在假设开发人员想要扩展可验证凭证以存储两个额外的信息：一个内部公司参考号和Jane的最喜欢的食物。
      </p>

      <p>
        首先要做的是创建一个包含两个新术语的JSON-LD上下文，如下所示。
      </p>

      <pre class="example nohighlight" title="A JSON-LD context">
{
  "@context": {
    "referenceNumber": "https://example.com/vocab#referenceNumber",
    "favoriteFood": "https://example.com/vocab#favoriteFood"
  }
}
        </pre>

      <p>
        创建完这个 JSON-LD 上下文后，开发人员将其发布到某个地方，以便[=验证者=]可以访问并处理[=可验证凭证=]。
        假设上述 JSON-LD 上下文发布在 `https://example.com/contexts/mycontext.jsonld`，
        我们可以通过包含上下文并添加新的[=属性=]和[=凭证=]的[=类型=]来扩展这个示例。
      </p>

      <pre class="example nohighlight" title="A verifiable credential with a custom extension">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    <span class="highlight">"https://example.com/contexts/mycontext.jsonld"</span>
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential", "CustomExt12"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  <span class="highlight">"referenceNumber": 83294847,</span>
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe",
    <span class="highlight">"favoriteFood": "Papaya"</span>
  }
}
        </pre>

      <p>
        这个例子演示了如何以无需许可和去中心化的方式扩展可验证凭证数据模型。所示的机制还确保以这种方式创建的[=可验证凭证=]提供了一种防止命名空间冲突和语义模糊的机制。
      </p>

      <p>
        这样的动态扩展性模型确实增加了实施负担。为这样的系统编写的软件必须根据应用的风险特性来确定是否接受带有扩展的[=可验证凭证=]。一些应用可能只接受某些扩展，而高度安全的环境可能不接受任何扩展。这些决定由这些应用的开发者来做，明确地说，这不是本规范的领域。
      </p>

      <p>
        开发者被敦促确保扩展JSON-LD上下文的高可用性。无法解引用上下文的实现将产生错误。确保扩展JSON-LD上下文始终可用的策略包括使用内容寻址URL来获取上下文，将上下文文档与实现捆绑在一起，或启用上下文的积极缓存。
      </p>

      <p>
        实施者被建议密切关注本规范中的扩展点，例如在<a href="#proofs-signatures"></a>、<a href="#status"></a>、<a href="#data-schemas"></a>、<a
          href="#refreshing"></a>、<a href="#terms-of-use"></a>和<a
          href="#evidence"></a>等部分。虽然本规范并未为这些扩展点定义具体的实现，但可验证凭证规范目录[[?VC-SPECS]]提供了一个非官方的，由开发者可以从这些扩展点使用的扩展的策略列表。
      </p>

      <section>
        <h4>语义互操作性</h4>

        <ul>
          <li>
            基于JSON-LD的处理器在JSON-LD上下文重新定义
            <a href="https://www.w3.org/TR/json-ld/#dfn-active-context">活动上下文</a>中的任何术语时，必须产生错误。
            更改现有术语定义的唯一方法是引入一个新术语，该术语在新术语的范围内清除活动上下文。对此功能感兴趣的作者应阅读JSON-LD 1.1规范中的
            `@protected` 功能。
          </li>
        </ul>

        <p>
          任何寻求互操作性的实现者都应发布一个描述`@context` [=property=]的值预期顺序的人类可读文档。期望JSON-LD实现者在寻求互操作性时，在`@context`
          [=property=]中指定的URL上发布机器可读描述（即，一个普通的JSON-LD上下文文档）。
        </p>
      </section>
    </section>

    <section>
      <h2>相关资源的完整性</h2>
      <p>
        当在[=可验证的凭证=]中包含指向外部资源的链接时，我们希望知道签名时指向的资源是否与验证时的资源相同。这适用于远程检索外部资源的情况，也适用于[=发行者=]和/或[=验证者=]可能拥有资源的本地缓存副本的情况。
      </p>
      <p>
        我们还希望知道在[=可验证的凭证=]中使用的JSON-LD上下文的内容在[=发行者=]和[=验证者=]使用时是否相同。
      </p>
      <p>
        为了验证由[=可验证的凭证=]引用的资源在验证时与发行时是否相同，实施者可以包含一个名为<code
          id="defn-relatedResource">relatedResource</code>的属性，该属性存储一个对象数组，描述每个由[=可验证的凭证=]引用的资源的额外完整性元数据。如果存在`relatedResource`，则数组中必须有一个对象，用于在可验证的凭证中使用的每个上下文的每个远程资源。
      </p>
      <p class="issue" title="Mandatory listing of contexts in relatedResouce are under debate.">
        目前正在VCWG中讨论是否需要在`relatedResource`中列出上下文。这个要求可能会在规范的未来版本中被移除。
      </p>
      <p>
        `relatedResource`数组中的每个对象必须包含以下内容：命名为`id`的资源的[[URL]]，以及使用<a
          href="https://www.w3.org/TR/SRI/#integrity-metadata">子资源完整性</a>中指定的方法构建的资源的<code
          id="defn-digestSRI">digestSRI</code>信息。
      </p>
      <p class="issue" title="Unification of cryptographic hash expression formats are under discussion">
        工作组目前正在尝试确定是否可以在所有的VCWG核心规范中统一加密哈希表达格式。这种机制的候选者包括`digestSRI`和`digestMultibase`。工作组目前正在讨论统一的利弊。
      </p>
      <p>
        `relatedResource`中每个`id`不得有多于一个的对象。
      </p>
      <p>
        `relatedResource`数组中的对象可以包含一个名为`mediaType`的属性，该属性指示指定`resource`的预期媒体类型。如果包含了`mediaType`，其值应该：
      </p>
      <ul>
        <li>
          是<a href="https://www.iana.org/assignments/media-types/media-types.xhtml">IANA媒体类型</a>注册表中列出的有效媒体类型
        </li>
        <li>
          在检索内容时使用，例如通过`Accept` HTTP头
        </li>
        <li>
          与检索到的内容媒体类型匹配，例如通过`Content-Type` HTTP头。
        </li>
      </ul>

      <p>
        [=可验证凭证=]中包含`id` [[URL]]属性的任何对象都可以通过在对象中包含`digestSRI`来按照本节的规定添加完整性信息。
      </p>
      <p>
        对于希望进行选择性披露的任何对象，不应将其作为`relatedResource`数组中的一个对象包含进去。
      </p>
      <p>
        编写根据[=符合性文档=]中对象的`id`获取资源的算法的规范作者需要考虑该资源的内容是否对该文档的有效性至关重要。如果是，除非资源具有预期的媒体类型，并且其字节散列到预期的摘要，否则规范必须产生验证错误。
      </p>
      <p>
        实施者被敦促咨询适当的资源，例如
        <a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">
          FIPS 180-4安全哈希标准</a>和
        <a href="https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF">
          商业国家安全算法套件2.0</a>以确保他们选择了当前且可靠的哈希算法。在编写本文时，`sha384`应被视为实施者使用的最低强度哈希算法。
      </p>
      <p class="issue">
        工作组正在讨论我们是否将采用[[SRI]]中定义的子资源完整性的更多方面，并将其纳入[[JSON-LD11]]规范，如该规范的<a
          href="https://www.w3.org/TR/json-ld11/#security">
          当前安全考虑</a>所述，VC中的这个哈希可以作为确保发行VC时使用的缓存上下文与远程资源匹配的额外检查。
      </p>
      <p>
        下面是一个引用JSON-LD上下文的相关资源完整性对象的示例。
      </p>

      <pre class="example nohighlight" title="Usage of the relatedResource property">
"relatedResource": [{
  "id": "https://www.w3.org/ns/credentials/v2",
  "digestSRI":
    "sha384-lHKDHh0msc6pRx8PhDOMkNtSI8bOfsp4giNbUrw71nXXLf13nTqNJoRp3Nx+ArVK",
},{
  "id": "https://www.w3.org/ns/credentials/examples/v2",
  "digestSRI":
    "sha384-zNNbQTWCSUSi0bbz7dbua+RcENv7C6FvlmYJ1Y+I727HsPOHdzwELMYO9Mz68M26",
}]
        </pre>

      <p>
        `credentialSubject`中引用完整性保护图像的对象示例。
      </p>

      <pre class="example nohighlight" title="An integrity-protected image that is associated with a credentialSubject">
"credentialSubject": {
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "image": {
    "id": "https://university.example.org/images/58473",
    "digestSRI":
      "sha384-ZfAwuJmMgoX3s86L7x9XSPi3AEbiz6S/5SyGHJPCxWHs5NEth/c5S9QoS1zZft+J",
    "mediaType": "application/svg+xml",
  },
  ...
}
        </pre>
    </section>

    <section>
      <h3>刷新</h3>

      <p class="issue" title="(AT RISK) 特性取决于独立实现的演示">
        该特性处于风险状态，如果在候选推荐阶段结束前，至少没有两个独立的、可互操作的实现针对单个扩展类型进行演示，它将从规范中删除。如果删除此特性，该属性将包含在第<a
          href="#reserved-extension-points"></a>节中，以期待未来的实现和包含在规范中。
      </p>

      <p>
        对于系统来说，启用过期的[=verifiable credential=]的手动或自动刷新是很有用的。有关[=verifiable credentials=]的有效期的更多信息，请参见第<a
          href="#validity-periods"></a>节。本规范定义了一个`refreshService` [=property=]，使[=issuer=]能够包含指向刷新服务的链接。
      </p>
      <p>
        [=issuer=]可以将刷新服务作为[=verifiable credential=]内部的一个元素，如果它既适用于[=verifier=]，也适用于[=holder=]（或两者），或者在[=verifiable
        presentation=]内部，如果它仅适用于[=holder=]。在后一种情况下，这使得[=holder=]在创建[=verifiable
        presentation=]与[=verifier=]共享之前可以刷新[=verifiable credential=]。在前一种情况下，将刷新服务包含在[=verifiable
        credential=]内部，使得[=holder=]或[=verifier=]可以执行未来的[=credential=]更新。
      </p>
      <p>
        只有在[=credential=]已过期或[=issuer=]不发布[=credential=]状态信息时，才预期使用刷新服务。建议[=Issuers=]不要将`refreshService`
        [=property=]放在一个不包含公共信息或其刷新服务未以某种方式受保护的[=verifiable credential=]中。
      </p>
      <p class="note">
        将`refreshService` [=property=]放在[=verifiable
        credential=]中，使其对[=verifiers=]可用，可能会从[=holder=]中移除控制和同意，并允许[=verifiable
        credential=]直接发给[=verifier=]，从而绕过[=holder=]。
      </p>

      <dl>
        <dt><var id="defn-refreshService">refreshService</var></dt>
        <dd>
          `refreshService` [=property=]的值必须是一个或多个刷新服务，为接收者的软件提供足够的信息，以便接收者可以刷新[=verifiable
          credential=]。每个`refreshService`值必须指定其`type`（例如，`ManualRefreshService2018`）和其`id`，即服务的[=URL=]。预期需要从URL检索机器可读的信息。每个刷新服务的确切内容由特定的`refreshService`
          [=type=]定义确定。
        </dd>
      </dl>

      <pre class="example nohighlight" title="Usage of the refreshService property by an issuer">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"refreshService": {
    "id": "https://university.example/refresh/3732",
    "type": "ManualRefreshService2018"
  }</span>
}
        </pre>

      <p>
        在上面的示例中，[=issuer=]指定了一个手动的`refreshService`，可以通过将[=holder=]或[=verifier=]指向`https://university.example/refresh/3732`来使用。
      </p>

    </section>

    <section>
      <h3>使用条款</h3>

      <p>
        使用条款可以被[=发行者=]或[=持有者=]用于传达在发行[=可验证凭证=]或[=可验证展示=]时所遵循的条款。[=发行者=]将其使用条款放置在[=可验证凭证=]内。[=持有者=]将其使用条款放置在[=可验证展示=]内。本规范定义了一个用于表达使用条款信息的`termsOfUse`
        [=属性=]。
      </p>

      <p>
        `termsOfUse` [=属性=]的值可能用于告知[=验证者=]以下任何或所有内容，以及其他事项：
      </p>

      <ul>
        <li>
          发行[=可验证凭证=]时所使用的程序或政策，例如，提供指向公共位置的指针（以避免“回拨”隐私问题），在该位置可以找到这些程序或政策，或者定义它们的标准的名称
        </li>
        <li>
          适用于向[=验证者=]展示此[=可验证凭证=]的[=发行者=]的规则和政策，例如，提供指向公共位置的指针（以避免“回拨”隐私问题），在该位置可以找到这些规则或政策
        </li>
        <li>
          在其授权下发行此特定[=可验证凭证=]的实体的身份
        </li>
      </ul>

      <dl>
        <dt><var id="defn-termsOfUse">termsOfUse</var></dt>
        <dd>
          `termsOfUse`
          [=属性=]的值必须指定创建者发行[=凭证=]或[=展示=]所遵循的一个或多个使用条款政策。如果接收者（[=持有者=]或[=验证者=]）不愿意遵守指定的使用条款，则他们需要自行承担责任，并且如果违反了规定的使用条款，可能会承担法律责任。每个`termsOfUse`值必须指定其[=类型=]，例如，`IssuerPolicy`，并可以指定其实例`id`。每个使用条款的具体内容由特定的`termsOfUse`
          [=类型=]定义来确定。
        </dd>
      </dl>

      <pre class="example nohighlight" title="Usage of the termsOfUse property by an issuer">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:did:123456",
  "type": [
    "VerifiableCredential",
    "EbsiTermsOfUseExample"
  ],
  "issuer": "did:ebsi:zz7XsC9ixAXuZecoD9sZEM1",
  "validFrom": "2021-11-01T00:00:00Z",
  "validUntil": "2021-10-30T00:00:00Z",
  "credentialSubject": {
    "id": "did:key:z2dmzD81cgPx8Vki7JbuuMmFYrWPgYoytykUZ3eyqht1j9KbrDt4zxXoDrBWYFiATYZ8G9JMeEXC7Kki24fbTwtsJbGe5qcbkYFunSzcDokMRmj8UJ1PbdCGh33mf97K3To89bMzd15qrYq3VkDztoZqfmujkJVpvTbqoXWXqxmzNDbvMJ",
    "personalIdentifier": "IT/DE/1234",
    "familyName": "Castafiori",
    "firstName": "Bianca",
    "dateOfBirth": "1930-10-01"
  },
  "credentialSchema": {
    "id": "https://api-test.ebsi.eu/trusted-schemas-registry/v2/schemas/z3MgUFUkb722uq4x3dv5yAJmnNmzDFeK5UC8x83QoeLJM",
    "type": "JsonSchema"
  },
  "termsOfUse": {
    "id": "https://api-test.ebsi.eu/trusted-issuers-registry/v4/issuers/did:ebsi:zz7XsC9ixAXuZecoD9sZEM1/attributes/7201d95fef05f72667f5454c2192da2aa30d9e052eeddea7651b47718d6f31b0",
    "type": "IssuanceCertificate"
  }
}
        </pre>

      <p>
        在上述示例中，[=发行者=] 断言作为欧洲区块链服务基础设施（EBSI）认证发行者，它遵守 EBSI 政策作为认证发行者，并在 EBSI 受信任发行者注册中注册。[=termsOfUse=] [=id=] 可以由
        [=验证者=] 解析，以确认 [=发行者=] 已获得由 EBSI 信任链中更高级别的受信任发行者颁发的认证 VC（JWT 格式）[?EBSI]。
      </p>


      <pre class="example nohighlight" title="Usage of the termsOfUse property by a holder">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    {
        "@protected": true,
        "VerifiablePresentationTermsOfUseExtension": {
          "@id": "https://www.w3.org/2018/credentials/examples#VerifiablePresentationExtension",
          "@context": {
            "@protected": true,
            "termsOfUse": {
              "@id": "https://www.w3.org/2018/credentials#termsOfUse",
              "@type": "@id"
            }
          }
        }
    }
  ],
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/3732",
    "type": ["VerifiableCredential", "ExampleDegreeCredential"],
    "issuer": "https://university.example/issuers/14",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "degree": {
        "type": "ExampleBachelorDegree",
        "name": "Bachelor of Science and Arts"
      }
    }
  }],
  <span class="highlight">"termsOfUse": [{
    "type": "HolderPolicy",
    "id": "http://example.com/policies/credential/6",
    "profile": "http://example.com/profiles/credential",
    "prohibition": [{
      "assigner": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "assignee": "https://wineonline.example.org/",
      "target": "http://university.example/credentials/3732",
      "action": ["3rdPartyCorrelation"]
    }]
  }]</span>
}
        </pre>

      <p>
        在上述示例中，[=持有者=]（`assigner`）同时也是[=主题=]，表达了一项使用条款，禁止[=验证者=]
        （`assignee`，`https://wineonline.example.org`）使用提供的信息通过第三方服务关联[=持有者=]或[=主题=]。如果[=验证者=]使用第三方
        服务进行关联，他们将违反[=持有者=]创建[=展示=]的条款。
      </p>

      <p>
        本功能还预计将被政府颁发的
        [=可验证凭证=]用于指导数字钱包将其使用限制在类似的政府组织中，以试图保护公民免受敏感数据意外使用的影响。同样，一些
        由私营行业颁发的[=可验证凭证=]预计将限制
        在组织内部的部门之间使用，或在工作时间内使用。实施者被敦促在可验证凭证实施指南
        [[?VC-IMP-GUIDE]]文档的相应部分阅读有关这个迅速发展的功能的更多信息。
      </p>

    </section>

    <section>
      <h3>证据</h3>

      <p class="issue" data-number="1303" title="(AT RISK) 特性取决于独立实现的演示">
        该特性存在风险，如果在候选推荐阶段结束时，至少没有两个独立的、可互操作的实现针对单个扩展类型进行演示，那么该特性将从规范中删除。如果删除了此功能，该属性将包含在第
        <a href="#reserved-extension-points"></a>节中，以期待未来的实现和包含在规范中。
      </p>

      <p>
        [=发行者=]可以包含证据，以便在[=可验证凭证=]中向[=验证者=]提供额外的支持信息。这可以被[=验证者=]用来建立它依赖[=可验证凭证=]中的声明的信心。
      </p>
      <p>
        例如，[=发行者=]可以在发行[=凭证=]之前检查[=主题=]提供的实体文件或执行一系列背景检查。在某些场景中，这些信息对于[=验证者=]在确定依赖某个[=凭证=]所涉及的风险时非常有用。
      </p>

      <p>
        本规范定义了用于表示证据信息的`evidence` [=属性=]。
      </p>

      <dl>
        <dt><dfn id="defn-evidence" class="export">evidence</dfn></dt>
        <dd>
          `evidence` [=属性=]的值必须是一个或多个证据方案，为[=验证者=]提供足够的信息，以确定[=发行者=]收集的证据是否满足其对[=凭证=]的信心要求。每个证据方案由其[=类型=]标识。`id`
          [=属性=]是可选的，
          但如果存在，应包含一个指向有关此证据实例的更多信息的URL。每个证据方案的确切内容由特定的`evidence` [=类型=]定义确定。
        </dd>
      </dl>

      <p class="note">
        有关规范如何支持附件和对[=凭证=]和非凭证数据的引用的信息，请参阅可验证凭证实施指南[[VC-IMP-GUIDE]]文档。
      </p>

      <pre class="example nohighlight" title="Usage of the evidence property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"evidence": {
    "id": "https://university.example/evidence/f2aeec97-fc0d-42bf-8ca7-0548192d4231",
    "type": ["DocumentVerification"],
    "verifier": "https://university.example/issuers/14",
    "evidenceDocument": "DriversLicense",
    "subjectPresence": "Physical",
    "documentPresence": "Physical",
    "licenseNumber": "123AB4567"
  }</span>
}
        </pre>

      <p class="note">
        在这个`evidence`示例中，[=issuer=]声称他们将[=credential=]的[=subject=]与实体驾驶执照的副本进行了匹配，该副本上有所述的驾驶执照号码。这张驾驶执照在发证过程中被用来验证“Example
        University”在发放证书之前对主体进行了验证，以及他们是如何做到这一点的（实体验证）。
      </p>

      <p class="note">
        `evidence` [=property=] 提供的信息与所使用的保护机制的信息不同。`evidence` [=property=]
        用于表达与[=可验证凭证=]的完整性相关的支持信息，如文件证据。相反，保护机制用于表达与[=发行者=]的真实性和[=可验证凭证=]的完整性相关的机器可验证的数学证明。有关保护机制的更多信息，请参见第<a
          href="#securing-mechanisms"></a>节。
      </p>

    </section>

    <section>
      <h3>零知识证明</h3>

      <p>
        零知识证明是一种加密方法，它使用户能够证明对一个值的知识，而不需要披露实际的值。这种数据模型支持使用零知识证明机制进行安全保护。
      </p>
      <p>
        一些由零知识证明机制实现的，与[=可验证的凭证=]兼容的功能：
      </p>
      <ul>
        <li>
          [=持有者=]向[=验证者=]选择性披露在[=可验证的凭证=]中的属性。这使得[=持有者=]能够为[=验证者=]提供他们需要的精确信息，而不是更多。这也使得在呈现时，无需涉及[=发行者=]，就能生成一个按照[=验证者=]的数据模式格式化的派生[=可验证的凭证=]。这为[=持有者=]使用他们的发行[=可验证的凭证=]提供了很大的灵活性。
        </li>
        <li>
          对与[=验证者=]共享的签名值进行盲化。盲签名允许进行不可链接的证明，这消除了在向一个或多个[=验证者=]进行多次展示时，[=持有者=]关联的常见来源。这使得[=持有者=]在每次展示时都可以分享不同的签名值，从而减少了分享的数据量。
        </li>
        <li>
          保护[=持有者=]和/或[=主题=]的隐私识别。这使得[=持有者=]可以证明一个[=凭证=]是发给他们的，或者[=主题=]可以证明一个[=凭证=]是关于他们的，而无需分享一个标识符。这也减少了需要分享的数据量。这种能力也可以用来将来自多个[=发行者=]的多个[=可验证的凭证=]合并成一个单一的[=可验证的展示=]，而不需要向[=验证者=]揭示[=可验证的凭证=]或[=主题=]的标识符。
        </li>
      </ul>
      <p>
        并非所有的零知识证明机制都支持所有的功能。关于特定零知识证明机制提供的功能和技术的具体细节，以及使用它们与[=可验证的凭证=]的规范要求，将在一个用于保护[=可验证的凭证=]的零知识证明机制的规范中找到。
      </p>
      <p>
        我们注意到，在大多数情况下，[=持有者=]使用零知识机制与[=可验证的凭证=]需要[=发行者=]以支持这些功能的方式保护[=可验证的凭证=]。
      </p>
      <p>
        当[=持有者=]选择性地披露了一部分[=可验证的凭证=]时，重要的是[=验证者=]检查在派生[=可验证的凭证=]中提供的信息是否与[=发行者=]提供的`credentialSchema`[=属性=]中的模式兼容。[=验证者=]也可以在请求[=持有者=]的数据时，向[=持有者=]提供一个模式，并确保派生的[=可验证的凭证=]与该模式兼容。我们在这个规范中没有定义这样一个请求模式，但一个实现这种方法的例子是[[?PRES-EX]]。
      </p>
      <p class="note">
        `credentialSchema`的实现者被鼓励考虑选择性披露凭证的影响，并根据构造提供处理指南。如果一个模式没有考虑到选择性披露，那么验证可能会失败。
      </p>
      <p>
        下面的图示说明了如何使用数据模型在零知识中发行和展示[=可验证的凭证=]。
      </p>
      <p class="issue">
        将来会在这里添加利用<a href="https://w3c.github.io/vc-di-bbs/">vc-di-bbs</a>的示例，或者删除这一部分。
      </p>

      <figure>
        <img style="margin: auto; display: block; width: 75%;" src="diagrams/zkp-cred-pres.svg" alt="Verifiable
            Credential 1 and Verifiable Credential 2 on the left map
            to Derived Credential 1 and Derived Credential 2 inside a
            Presentation on the right.  Verifiable Credential 1
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains GivenName, FamilyName, and
            Birthdate and Proof contains Signature, Proof of
            Correctness, and Attributes.  Verifiable Credential 2
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains University, which contains
            Department, which contains DegreeAwarded, and Proof contains Signature, Proof of
            Correctness, and Attributes.  The Presentation diagram on
            the right contains Context, Type, ID,
            VerifiableCredential, and Proof, where
            VerifiableCredential contains Derived Credential 1 and
            Derived Credential 2 and Proof contains Common Link
            Secret.  Derived Credential 1 contains Context, Type, ID,
            Issuer, Issue Date, CredentialSubject, and Proof, where
            CredentialSubject contains AgeOver18 and Proof contains
            Knowledge of Signature.  Derived Credential 2 contains
            Context, Type, ID, Issuer, Issue Date, CredentialSubject,
            and Proof, where CredentialSubject contains Degree and
            Proof contains Knowledge of Signature.  A line links
            Birthdate in Verifiable Credential 1 to AgeOver18 in
            Derived Credential 1.  A line links DegreeAwarded in
            Verifiable Credential 2 to Degree in Derived Credential 2.">
        <figcaption style="text-align: center;">
          ZKP [=presentation=] 中凭证和派生凭证之间关系的可视化示例。
        </figcaption>

      </figure>

      <p>
        对于创建提供不可链接性的<a href="#securing-mechanisms">安全机制</a>规范的作者，提供以下准则：

      <ul>
        <li>
          不可链接的安全机制不得设计成会泄露信息，从而使得 [=verifier=] 能够在多个 [=verifiable presentations=] 到不同的 [=verifiers=] 之间关联一个 [=holder=]。
        </li>
      </ul>
      </p>


    </section>

    <section class="informative">
      <h3>授权</h3>

      <p>
        [=可验证凭证=] 旨在作为可靠识别 [=subjects=] 的手段。尽管承认基于角色的访问控制（RBACs）和基于属性的访问控制（ABACs）
        依赖于此身份识别作为授权 [=subjects=] 访问资源的手段，但本规范不提供完整的 RBAC 或 ABAC 解决方案。在没有相应的授权框架的情况下，
        本规范不适用于授权。
      </p>

      <p>
        工作组在创建本规范期间考虑了授权用例，并正在作为建立在本规范之上的体系结构层的工作中继续推进该工作。
      </p>
    </section>


    <section class="normative">
      <h3>保留的扩展点</h3>

      <p>
        本规范保留了若干[=属性=]作为可能的扩展点。虽然一些实现者对这些属性表示了兴趣，
        但将它们包含在本规范中被认为是过早的；这些扩展点可能在本规范的未来版本中被更正式地定义。需要注意的是，这些属性并未由本规范定义，实现者需谨慎使用这些属性，因为它们被认为是实验性的。
      </p>
      <p>
        实现者可以使用这些属性，但在规范化指定它们的过程中，应预期它们和/或它们的含义会发生变化。
        实现者在没有公开披露描述其实现的规范的情况下，不应使用这些属性。
      </p>

      <p>
        为了避免关于如何使用以下属性的冲突，实现必须在与保留属性关联的值中指定一个`type`属性。有关添加`type`信息的更多信息，请参阅<a href="#types"></a>部分。
      </p>
      <p class="issue" title="工作组正在考虑的扩展点">
        工作组正在讨论是否在<a href="https://www.w3.org/ns/credentials/v2">https://www.w3.org/ns/credentials/v2</a>中保留额外的扩展点。
        <br /><br />
        工作组目前计划只保留在社区组中孵化的至少有草案规范的扩展点。
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>Reserved&nbsp;Property</th>
            <th>Description</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>`confidenceMethod`</td>
            <td>
              一个用于指定验证者可能使用的一种或多种方法的属性，以提高对可验证凭证或可验证呈现中的属性值的准确性的信心，包括但不限于诸如`initialRecipient`（又名`issuee`）、`presenter`、`authorizedPresenter`、`holder`等属性。相关的词汇表URL必须是`https://www.w3.org/2018/credentials#confidenceMethod`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                如果在候选推荐阶段结束前至少有一个规范和两个独立实现被证明，则此属性保留可能会被删除，以支持规范中现有的部分。如果没有发生这种情况，此保留将保留，但规范中现有的部分将被删除。
                参见<a href="https://w3c-ccg.github.io/confidence-method-spec/">可验证凭证信心方法</a>。
              </p>
            </td>
          </tr>
          <tr>
            <td>`evidence`</td>
            <td>
              用于指定发放凭证所需的证据的属性。关联的词汇表 URL 必须是 `https://www.w3.org/2018/credentials#evidence`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                该属性的保留可能会被删除，以支持规范中的现有部分，如果在候选推荐阶段结束时至少有一个具有两个独立实现的规范得以证明。如果未能实现该目标，
                该保留将保留，但规范中的现有部分将被移除。
              </p>
            </td>

          </tr>
          <tr>
            <td>`refreshService`</td>
            <td>
              用于指定凭证如何进行刷新的属性。关联的词汇表 URL 必须是 `https://www.w3.org/2018/credentials#refreshService`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                该属性的保留可能会被删除，以支持规范中的现有部分，如果在候选推荐阶段结束时至少有一个具有两个独立实现的规范得以证明。如果未能实现该目标，
                该保留将保留，但规范中的现有部分将被移除。
              </p>
            </td>

          </tr>
          <tr>
            <td>`renderMethod`</td>
            <td>
              用于指定一种或多种将凭证呈现为视觉、听觉或触觉格式的方法的属性。关联的词汇表 URL 必须是 `https://www.w3.org/2018/credentials#renderMethod`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                此保留属性存在风险，如果在候选推荐阶段结束时未能证明至少有一个具有两个独立实现的规范，将从规范中移除。
                请参阅<a href="https://w3c-ccg.github.io/vc-render-method/">可验证凭证呈现方法</a>。
              </p>
            </td>

          </tr>
          <tr>
            <td>`termsOfUse`</td>
            <td>
              用于指定凭证使用条款的属性。关联的词汇表 URL 必须是 `https://www.w3.org/2018/credentials#termsOfUse`。
              <p class="issue" title="(AT RISK) Reservation depends on implementations">
                此保留属性存在风险，如果在候选推荐阶段结束时未能证明至少有一个具有两个独立实现的规范，将从规范中移除。
              </p>
            </td>

          </tr>
        </tbody>
      </table>


      <p>
        与本规范中定义的扩展点相关联的规范的非官方列表，以及本节中定义的保留扩展点，可在可验证凭证规范目录 [[?VC-SPECS]] 中找到。
        目录中涉及保留扩展点的项目应被视为实验性质。
      </p>
      

    </section>

    <section class="normative">
      <h3>生态系统兼容性</h3>

      <p>
        有许多数字凭证格式本身并不使用本文档中提供的数据模型，但与本规范中的许多概念保持一致。在出版时，这些数字凭证格式的例子包括
        <a href="https://www.rfc-editor.org/rfc/rfc7519.html">
          JSON Web Tokens</a> (JWTs)，
        <a href="https://www.rfc-editor.org/rfc/rfc8392.html">
          CBOR Web Tokens</a> (CWTs)，
        <a href="https://www.iso.org/standard/69084.html">ISO-18013-5:2021</a>
        (mDLs)，
        <a href="https://hyperledger.github.io/anoncreds-spec/">
          AnonCreds</a>，
        <a href="https://datatracker.ietf.org/doc/draft-mcnally-envelope/">
          Gordian Envelopes</a>，和
        <a href="https://datatracker.ietf.org/doc/draft-ssmith-acdc/">
          Authentic Chained Data Containers</a> (ACDCs)。
      </p>

      <p>
        如果概念上对齐的数字凭证格式可以根据本节提供的规则转换为
        [=符合规范的文档=]，它们被认为是<em>"与W3C可验证凭证生态系统兼容"</em>。描述如何执行转换以实现与可验证凭证生态系统兼容性的规范：
      </p>

      <ul>
        <li>
          必须确定将此数据模型的转换是单向还是可往返。
        </li>
        <li>
          在执行可往返转换时，必须保留`@context`值。
        </li>
        <li>
          在转换为本规范描述的数据模型时，必须产生一个[=符合规范的文档=]。
        </li>
        <li>
          必须为输入文档指定一个注册的媒体类型。
        </li>
        <li>
          应提供一个测试套件，证明将指定的转换算法应用于本规范中的数据模型会产生
          一个[=符合规范的文档=]。
        </li>
        <li>
          应确保转换后的[=符合规范的文档=]中使用的所有语义都遵循链接数据的最佳实践。请参阅
          第<a href="#getting-started"></a>节，第
          <a href="#extensibility"></a>节，以及链接数据最佳实践[[?LD-BP]]
          以获取更多指导。
        </li>
      </ul>

      <p class="note" title="什么构成了一个可验证的凭证？">
        建议读者注意，只有当数字凭证是一个[=符合规范的文档=]并且至少使用了一种安全机制（如本规范中各自的要求所述）时，才被认为与W3C可验证凭证生态系统兼容。虽然一些社区可能会称一些不是[=符合规范的文档=]的数字凭证格式为“可验证凭证”，但这样做并不能使该数字凭证符合本规范。
      </p>

    </section>

    <section>
      <h3>可验证凭证图</h3>

      <p>
        在表达[=可验证凭证=]（例如在[=展示=]中）时，确保一个[=可验证凭证=]中的数据不会被误认为是另一个[=可验证凭证=]中的相同数据是很重要的。例如，如果有两个[=可验证凭证=]，每个都包含以下形式的对象：`{"type": "Person", "name": "Jane
        Doe"}`，就无法判断一个对象是否在描述与另一个对象相同的人。换句话说，在确认两个[=可验证凭证=]讨论的是相同实体和/或属性之前，合并两个[=可验证凭证=]之间的数据可能会导致数据集损坏。
      </p>

      <p>
        为了确保来自不同[=可验证凭证=]的数据不会意外地混合在一起，使用<dfn class="export">可验证凭证图</dfn>的概念来封装每个[=可验证凭证=]。对于简单的[=可验证凭证=]，即JSON-LD文档包含一个可能带有关联证明的单一凭证时，此图是[=默认图=]。对于[=展示=]，与[=展示=]的`verifiableCredential`属性关联的每个值都是一个单独的[=命名图=]，类型为<dfn class="export">VerifiableCredentialGraph</dfn>，其中包含一个[=可验证凭证=]或一个
        <a href="#enveloped-verifiable-credentials">封装的可验证凭证</a>。
      </p>
      <p>
        使用这些[=图=]在执行JSON-LD处理时会产生具体效果，这样可以正确地将一个图中的图节点标识符与另一个图中的图节点标识符分开。将输入限制为特定于应用程序的JSON-LD文档的实现者在将一个[=可验证凭证=]中的数据与另一个[=可验证凭证=]中的数据合并时，也需要考虑到这一点，例如，当`credentialSubject.id`在两个[=可验证凭证=]中都相同时，但对象可能包含前一段中描述的"Jane Doe"形式的对象。在不包含使用全局标识符（如URL）的`id`属性的情况下，不要合并看似具有相似属性的对象非常重要。
      </p>
    </section>

    <section>
      <h3>安全机制规范</h3>

      <p>
        如第<a href="#securing-mechanisms">节</a>所述，实现者在保护[=符合规范的文档=]时可以使用多种策略。为了最大化实用性和互操作性，希望建立新的保护[=符合规范的文档=]方法的规范作者可以参考本节的指南。
      </p>

      <p>
        安全机制规范必须记录为[=符合规范的文档=]提供内容完整性保护的规范性算法。这些算法可以是通用的，也可以用于保护除[=符合规范的文档=]之外的其他数据。
      </p>

      <p>
        安全机制规范必须提供一种验证机制，该机制仅返回已经被保护的[=符合规范的文档=]中的信息，不包括任何安全机制信息，如`proof`或JOSE/COSE头参数和签名。规范可以提供额外的机制来传达其他可能有用的信息（例如，在验证过程中或用于调试目的），如安全机制数据。安全机制的验证算法必须提供一个接口，该接口接收字节序列（[=字节序列=] |inputBytes|）或文档（[=映射=] |inputDocument|）和媒体类型（[=字符串=] |inputMediaType|）作为输入，并返回至少包含以下[=结构/项目=]的验证结果：
      </p>

      <dl>
        <dt>[=布尔值=] |status|</dt>
        <dd>
          验证状态，如果验证成功，则值为`true`，如果验证失败，则值为`false`。
        </dd>
        <dt>[=映射=] |document|</dt>
        <dd>
          一个仅包含成功保护的信息的文档。
        </dd>
        <dt>[=字符串=] |mediaType|</dt>
        <dd>
          一个在[[RFC6838]]中定义的媒体类型。
        </dd>
      </dl>

      <p class="issue atrisk" title="控制器文档引用可能会发生变化">
        工作组目前正在尝试在[[[?DID-CORE]]]、[[[?VC-DATA-INTEGRITY]]]和[[[?VC-JOSE-COSE]]]之间对控制器文档的定义进行对齐。目标是让每个先前声明的规范和本规范都可以引用一个关于控制器文档的规范性声明。在候选推荐阶段，对控制器文档的规范性引用预计会发生变化。
      </p>

      <p>
        安全机制规范应为对验证至关重要的URL引用的任何信息提供完整性保护。可以实现此保护的机制在第<a href="#integrity-of-related-resources">节</a>和第<a href="#base-context">节</a>中有讨论。
      </p>

      <p>
        创建新类型[=嵌入式证明=]的安全机制规范必须为保护[=可验证凭证=]和[=可验证演示文稿=]指定一个[=属性=]。嵌入式安全机制所使用的属性要求如下：
      </p>

      <ul>
        <li>
          该属性必须将[=可验证凭证=]或[=可验证演示文稿=]与可分离且可保护的[=证明图=]关联起来。
        </li>
        <li>
          该属性必须定义[=证明图=]所使用的所有术语。例如，该机制可以定义词汇表规范和`@context`文件，就像它们被本规范使用的那样。
        </li>
        <li>
          在[=可验证凭证=]中，该属性必须保护[=默认图=]。
        </li>
        <li>
          在[=可验证演示文稿=]中，该属性必须保护[=演示文稿=]的[=默认图=]以及[=演示文稿=]中每个[=可验证凭证=]相关的[=证明图=]。
        </li>
        <li>
          [[VC-DATA-INTEGRITY]]中定义的`proof`属性可以被嵌入式安全机制使用。
        </li>
      </ul>

      <p>
        安全机制规范应在<a data-cite="?VC-SPECS#securing-mechanisms">安全机制</a>部分[[[?VC-SPECS]]] [[?VC-SPECS]]中注册安全机制。
      </p>

      <p class="note" title="选择安全机制取决于用例">
        有多种可接受的安全机制，本规范并未规定任何特定的安全机制用于[=可验证凭证=]或[=可验证演示文稿=]。制定本规范的工作组确实对两种安全机制选项进行了标准化，分别是：[[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]]和[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]。社区已知的其他安全机制可以在[[[?VC-SPECS]]] [[?VC-SPECS]]的<a data-cite="?VC-SPECS#securing-mechanisms">安全机制</a>部分找到。
      </p>

    </section>

  </section>

  <section>
    <h2>语法</h2>

    <p>
      如<a href="#core-data-model"></a>、<a href="#basic-concepts"></a>和
      <a href="#advanced-concepts"></a>章节所述的数据模型是
      [=可验证凭证=]或[=可验证展示=]的规范结构表示。所有
      序列化都是以特定格式表示该数据模型。本节指定了如何在JSON-LD中实现数据模型
      用于`application/vc+ld+json`，可验证凭证的基本媒体类型。
      尽管语法映射仅提供给JSON-LD，应用程序和
      服务可以使用任何其他能够映射回`application/vc+ld+json`的数据表示语法（如XML、YAML或
      CBOR）。由于[=验证=]和[=验证=]要求是基于
      数据模型，所有序列化语法都必须确定性地
      转换为数据模型以进行处理，[=验证=]或比较。
    </p>

    <p>
      本规范中属性值的预期元数以及保存这些值的
      结果数据类型可能因属性而异。
      如果存在，以下属性表示为单个值：
    </p>

    <ul>
      <li>
        `id` [=属性=]
      </li>
      <li>
        `issuer` [=属性=]
      </li>
      <li>
        `validFrom` [=属性=]
      </li>
      <li>
        `validUntil` [=属性=]。
      </li>
    </ul>

    <p>
      所有其他属性（如果存在）表示为单个值
      或值数组。
    </p>

    <section>
      <h3>JSON-LD</h3>

      <p>
        [[!JSON-LD11]] 是一种基于 JSON 的格式，用于序列化
        <a href="https://www.w3.org/TR/ld-glossary/#linked-data">链接数据</a>。该
        语法旨在轻松集成到已经使用 JSON 的部署系统中，
        并为从 JSON 升级到 [[!JSON-LD11]] 提供平滑升级路径。它主要
        用于在基于 Web 的编程环境中使用链接数据，
        构建可互操作的 Web 服务，并将链接数据存储在基于 JSON 的
        存储引擎中。
      </p>

      <p>
        [[!JSON-LD11]] 在扩展本规范中描述的数据模型时非常有用。数据模型的实例以 JSON-LD 紧凑形式 [[!JSON-LD11]] 编码，并包括 `@context` [=property=]。 
        <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD 上下文</a>
        在 [[!JSON-LD11]] 规范中详细描述，其用法在第 <a href="#contexts"></a> 节和
        第 <a href="#extensibility"></a> 节中进一步阐述。
      </p>

      <p>
        可以使用或组合多个上下文来以惯用的 JSON 表达关于 [=verifiable credentials=] 的任意信息。
        <a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD 上下文</a>，
        可在 `https://www.w3.org/ns/credentials/v2` 获取，是一个静态
        文档，永远不会更新，因此可以在客户端下载和缓存。可验证凭据数据模型的关联词汇文档可在 `https://www.w3.org/2018/credentials` 获取。
      </p>

      <p>
        本规范限制了对数据模型的 JSON-LD 表示的使用。JSON-LD <a href="https://www.w3.org/TR/json-ld/#compacted-document-form">紧凑文档形式</a> 必须用于基本媒体类型 `application/vc+ld+json` 中的数据模型的所有表示。
      </p>

      <p>
        如第 <a href="#credential-type-specific-processing"></a> 节中详细阐述的那样，某些软件应用可能不执行通用的 JSON-LD 处理。 [=conforming documents=] 的作者应注意，如果在 `@context` 值中使用 JSON-LD 关键字全局影响 [=verifiable credential=] 或 [=verifiable presentation=] 中的值（例如，通过全局设置 `@base` 关键字），互操作性可能会降低。例如，全局设置这些值可能会在执行 [=credential type-specific processing=] 的实现中触发对 `@context` 值的错误实现的 JSON Schema 检查，而该实现并未期望在 `@context` 值中表达 `@base` 值。
      </p>

      <p>
        为了提高互操作性，建议 [=conforming document=] 作者不要使用在执行 [=credential type-specific processing=] 时不容易检测到的 JSON-LD 功能。这些功能包括：
      </p>

      <ul>
        <li>
          在 `@context` 值中使用 JSON-LD 关键字，全局修改文档值处理，例如全局设置 `@base`
        </li>
        <li>
          在 `@context` 属性中内联声明 JSON-LD 上下文。
        </li>
        <li>
          使用 JSON-LD 术语和类型的完整 URL（例如，
          `https://www.w3.org/2018/credentials#VerifiableCredential` 或
          `https://vocab.example/myvocab#SomeNewType`）而不是使用任何这样的值的简短形式（例如，`VerifiableCredential` 或 `SomeNewType`），这些值要么被明确定义为 JSON-LD `@context` 映射（例如，
          `https://www.w3.org/ns/credentials/v2`），要么通过适用于所有未定义术语的 `@vocab` 功能隐式定义。
        </li>
      </ul>

      </p>

      <section>
        <h3>语法糖</h3>

        <p>
          总的来说，本文档中描述的数据模型和语法设计使得开发者可以复制粘贴示例，将
          [=可验证凭证=]集成到他们的软件系统中。这种方法的设计目标是在确保不同软件系统之间实现全球互操作性的同时，降低进入门槛。本节描述了其中一些方法，这些方法可能不会被大多数开发者注意到，但其细节对于实现者来说是有趣的。[[!JSON-LD11]]提供的最值得注意的语法糖包括：
        </p>

        <ul>
          <li>
            `@id` 和 `@type` 关键字分别被别名为
            `id` 和 `type`，使开发者能够将本规范用作地道的 JSON。
          </li>
          <li>
            数据类型，如整数、日期、度量单位和 URL，会自动进行类型化，以便为需要它们的用例提供更强的类型保证。
          </li>
          <li>
            `verifiableCredential` [=属性=]
            被定义为
            <a href="https://www.w3.org/TR/json-ld11/#graph-containers">JSON-LD 1.1 图形
              容器</a>。这要求创建 [=命名图=]，用于隔离由不同实体声明的数据集。这确保了，例如，每个 [=发行者=] 提供的数据图与 [=持有者=] 提供的数据图之间的适当加密分离，以确保每个图的信息来源得以保留。
          </li>
          <li>
            使用 [[!JSON-LD11]] 1.1 的 `@protected` 属性功能
            确保本规范定义的术语不能被覆盖。这意味着只要在
            [=可验证凭证=] 或 [=可验证展示=] 的顶部进行相同的 `@context` 声明，
            对于数据模型的所有用户理解的术语，无论他们是否使用 [[!JSON-LD11]] 处理器，都可以保证互操作性。
          </li>
        </ul>
      </section>
      <section>
        <h3>列表和数组</h3>
        <p>
          当使用[[JSON-LD11]] 1.1时，列表、数组，甚至列表的列表都是可能的。
          我们鼓励那些希望在需要列表和数组的用例中使用RDF语义的人遵循
          <a href="https://www.w3.org/TR/json-ld11/#lists">JSON-LD 1.1中的列表</a>的指导。
        </p>
        <p>
          一般来说，JSON数组是有序的，而JSON-LD数组在没有使用`@list`关键字的情况下是无序的。
        </p>
        <p class="note">
          虽然可以在不进行任何JSON-LD处理的情况下使用此数据模型，
          但那些这样做并使用数组的人需要注意，除非遵循上述指导，否则无法保证JSON-LD中数组中项目的顺序。这可能导致意外的行为。
        </p>
        <p>
          如果JSON结构或排序对您的应用程序很重要，
          我们建议您通过`@context`将这些元素标记为`@json`。
        </p>
        <pre class="example" title="A @context file that defines a matrix as an embedded JSON data structure">
{
  "@context":
    {
      "matrix": {
        "@id": "https://website.example/vocabulary#matrix",
        "@type": "@json"
      }
    }
}
          </pre>
        <pre class="example" title="A verifiable credential with an embedded JSON data structure">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    "https://website.example/matrix/v1"
  ],
  "id": "http://university.example/credentials/1872",
  "type": [
    "VerifiableCredential",
    "ExampleMatrixCredential"
  ],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "matrix": [
      [1,2,3,4,5,6,7,8,9,10,11,12],
      [1,1,1,1,1,1,1,1,0,0,0,0],
      [0,0,1,1,1,1,1,1,1,0,0,0]
    ]
  }
}
          </pre>
      </section>
    </section>
    <section>
      <h3>媒体类型</h3>

      <p>
        媒体类型，如[[RFC6838]]中定义，标识用于表达
        [=可验证证书=]的语法以及其他有用的处理指南。
      </p>
      <p>
        本规范中用于表达数据模型的语法应由媒体类型标识，且在定义或使用与[=可验证证书=]相关的媒体类型时，应遵循本节概述的约定。
      </p>
      <p>
        与核心数据模型相关的有两种媒体类型，列在<a href="#iana-considerations">考虑因素</a>一节中：
        `application/vc+ld+json` 和 `application/vp+ld+json`。
      </p>
      <p>
        `application/vc+ld+json` 和 `application/vp+ld+json` 媒体类型并不暗示任何特定的安全机制，但是预期将与安全机制一起使用。需要应用一个安全机制来保护这些媒体类型的完整性。不论用于通信的媒体类型是什么，都不要假设内容的安全性。
      </p>

      <section class="informative">
        <h3>媒体类型精度</h3>

        <p>
          有时，开发者或系统可能使用较低精度的媒体类型来传递
          [=可验证证书=]或[=可验证展示=]。使用较低精度媒体类型的一些原因包括：
        </p>

        <ul>
          <li>
            当文件扩展名不可用且无法确定媒体类型时，Web服务器默认为`text/plain`或`application/octet-stream`。
          </li>
          <li>
            开发者添加的文件扩展名导致媒体类型比文件内容的精度低。例如，`.json`可能导致`application/json`的媒体类型，而`.jsonld`可能导致`application/ld+json`的媒体类型。
          </li>
          <li>
            协议要求对于特定交易使用较不精确的媒体类型；例如，`application/json`而不是`application/vp+ld+json`。
          </li>
        </ul>

        <p>
          实施者被敦促在可能从有效载荷确定预期的媒体类型的情况下，不要引发错误，前提是在给定协议中使用的媒体类型是可接受的。例如，如果一个应用程序只接受符合`application/vc+ld+json`媒体类型相关规则的有效载荷，但有效载荷被标记为`application/json`或`application/ld+json`，则应用程序可能执行以下步骤来确定有效载荷是否也符合更高精度的媒体类型：
        </p>

        <ol>
          <li>
            将有效载荷解析为JSON文档。
          </li>
          <li>
            确保`@context`字段的第一个元素匹配`https://www.w3.org/2018/credentials/v2`。
          </li>
          <li>
            如果JSON文档包含一个顶级`type`字段，其中包含一个`VerifiablePresentation`元素，则假设其为`application/vp+ld+json`媒体类型。仍然期望执行额外的后续检查（根据本规范），以确保有效载荷表达了一个符合规范的可验证展示。
          </li>
          <li>
            如果JSON文档包含一个顶级`type`字段，其中包含一个`VerifiableCredential`元素，则假设其为`application/vc+ld+json`媒体类型。仍然期望执行额外的后续检查（根据本规范），以确保有效载荷表达了一个符合规范的可验证证书。
          </li>
        </ol>

        <p>
          在任何可能的情况下，建议实施者对本规范定义的所有有效载荷使用最精确（最高精度）的媒体类型。实施者还建议认识到，用较低精度媒体类型标记的有效载荷并不意味着有效载荷不符合用更高精度类型标记的规则。同样，用较高精度媒体类型标记的有效载荷并不意味着有效载荷将满足与媒体类型相关的要求。接收有效载荷的系统，无论其关联的媒体类型如何，都应执行适当的检查，以确保有效载荷符合在给定系统中使用的要求。
        </p>
      </section>
      <section class="informative">
        <h2>HTTP</h2>
        <p>
          预期HTTP端点将在接受标头和指示内容类型时使用与
          [=可验证证书=]和[=可验证展示=]相关的媒体类型。
        </p>
        <p>
          尽管如此，HTTP服务器可能会忽略接受标头并返回另一种内容类型，或返回错误代码，例如
          <a data-cite="RFC7231#section-6.5.13">`415 Unsupported Media Type`</a>。
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>凭证类型特定处理</h2>

      <p>
        <dfn>通用JSON-LD处理</dfn>被定义为一种利用JSON-LD软件库对[=符合要求的文档=]进行各种<a data-cite="?JSON-LD11#forms-of-json-ld">转换</a>的机制。
        <dfn>凭证类型特定处理</dfn>被定义为一种处理[=符合要求的文档=]的轻量级机制，不需要JSON-LD软件库。一些[=可验证凭证=]的消费者只需要处理特定类型的凭证。这些消费者可以使用凭证类型特定处理而不是通用处理。凭证类型特定处理可能是可取的场景包括但不限于以下几种：
      </p>

      <ul>
        <li>
          在对[=符合要求的文档=]应用安全机制之前，或在验证受安全机制保护的[=符合要求的文档=]之后，确保
          <a href="https://csrc.nist.gov/glossary/term/data_integrity">数据完整性</a>。
        </li>
        <li>
          在执行JSON Schema验证时，如第<a href="#data-schemas"></a>节所述。
        </li>
        <li>
          在将[=可验证凭证=]或[=可验证展示=]序列化或反序列化到存储或索引其内容的系统中。
        </li>
        <li>
          在软件应用程序中操作[=可验证凭证=]或[=可验证展示=]，在执行需要[=通用JSON-LD处理=]的安全机制的验证或验证之后。
        </li>
        <li>
          当应用程序选择使用`+json`结构化媒体类型后缀处理媒体类型时。
        </li>
      </ul>

      <p>
        也就是说，只要消费或生成的文档是[=符合要求的文档=]，就允许进行[=凭证类型特定处理=]。如果需要这种类型的处理，建议实施者遵循以下规则：
      </p>

      <ul>
        <li>
          确保与`@context`属性关联的所有值按预期顺序排列，上下文文件的内容与每个文件的已知良好加密哈希匹配，领域专家认为内容适用于预期的用例。
        </li>
      </ul>

      <p>
        使用静态上下文文件和JSON Schema是实现上述规则的一种可接受方法。在执行[=凭证类型特定处理=]时，这可以确保正确识别、类型化和排序术语。
      </p>

      <p>
        上述规则保证了通过`@context`机制将字面JSON键映射到URI的两种处理机制之间的语义互操作性。虽然[=通用JSON-LD处理=]可以使用其算法中提供的以前未见过的`@context`值来验证所有术语是否正确指定，但执行[=凭证类型特定处理=]的实现只接受特定的`@context`值，这些值是实现事先设计好的，从而在不调用任何JSON-LD API的情况下实现相同的语义。换句话说，通过使用`@context`以导致相同的[=符合要求的文档=]语义的方式，明确说明了数据交换发生的上下文，以便两种处理机制都能使用。
      </p>

    </section>

  </section>

  <section class="normative">
    <h2>算法</h2>

    <p>
      本节包含可供实现使用的算法，以执行常见操作，如验证。以算法表述的一致性要求使用[[[INFRA]]] [[INFRA]]中的规范性概念。有关实现要求的更多指导，请参阅[[[INFRA]]]中关于<a data-cite="INFRA#conformance">一致性</a>的部分。
    </p>

    <p class="issue atrisk" title="在候选推荐之前需要解决的问题">
      与本节相关的有一个问题需要在工作组进入候选推荐阶段之前解决。在这些问题得到解决之前，整个部分都处于风险之中。
    </p>

    <p class="issue" data-number="1377"></p>

    <p class="note" title="实现者可以包括额外的检查、警告和错误。">
      建议实现者注意，本节中的算法包含了实现用于测试对本规范的一致性的最基本的检查集。预计实现将提供额外的检查，为开发人员报告有用的警告，以帮助调试潜在问题。同样，实现可能会提供额外的检查，这可能导致报告新类型的错误，以阻止有害内容。这些额外检查中的任何一个都可能被整合到本规范的未来版本中。
    </p>

    <section class="normative">
      <h3>验证</h3>

      <p>
        本节包含一个算法，该算法是[=符合验证器实现=]在验证[=可验证凭证=]或[=可验证演示=]时必须运行的。该算法接受一串字节（[=字节序列=] |inputBytes|）或一个文档（[=map=] |inputDocument|）和一个媒体类型（[=string=] |inputMediaType|）作为输入，并返回一个包含以下内容的[=map=]：
      </p>

      <ul>
        <li>
          状态（[=boolean=] |status|）
        </li>
        <li>
          一个[=符合的文档=]（[=map=] |document|）
        </li>
        <li>
          媒体类型（[=string=] |mediaType|）
        </li>
        <li>
          与保护机制相关联的验证方法的控制器（[=string=] |controller|）
        </li>
        <li>
          与用于验证保护机制的验证方法相关联的控制器文档（[=map=] |controllerDocument|）
        </li>
        <li>
          零个或多个警告（[=ProblemDetails=]的[=list=] |warnings|）
        </li>
        <li>
          零个或多个错误（[=ProblemDetails=]的[=list=] |errors|）
        </li>
      </ul>

      <p>
        验证算法如下：
      </p>

      <ol class="algorithm">
        <li>
          通过执行以下步骤，确保保护机制已正确保护[=符合的文档=]：
          <ol class="algorithm">
            <li>
              使用|inputMediaType|和[[[?VC-SPECS]]] [[?VC-SPECS]]的<a data-cite="?VC-SPECS#securing-mechanisms">保护机制</a>部分，或实现已知的其他机制，来确定在验证保护机制时使用的加密套件，从而设置|verifyProof|函数。|verifyProof|函数必须实现在<a href="#securing-mechanisms"></a>中描述的接口。
              <div class="issue" title="“确定”的机制正在详细说明">
                目前，工作组担心“确定”的算法可能需要更正式地定义。目前，没有实现遇到确定适当的|verifyProof|算法使用的问题，但工作组正在尝试看看在这里说更多是否值得。可以添加额外的示例语言，说明实现可能有一个可接受的加密套件的允许列表——这些将用作查找要验证的匹配证明的输入。
              </div>
            </li>
            <li>
              将|result|设置为将|inputBytes|和|inputMediaType|传递给|verifyProof|函数的结果。如果调用成功，|result|将包含|status|、|document|、|mediaType|、|controller|、|controllerDocument|、|warnings|和|errors|属性。
            </li>
            <li>
              如果|result|.|status|设置为`false`，则将<a href="#CRYPTOGRAPHIC_SECURITY_ERROR">CRYPTOGRAPHIC_SECURITY_ERROR</a>添加到|result|.|errors|。
            </li>
          </ol>
        </li>
        <li>
          如果|result|.|status|设置为`true`，确保|result|.|document|是一个[=符合的文档=]。如果不是，将|result|.|status|设置为`false`，从|result|中删除|document|属性，并至少向|result|.|errors|添加一个<a href="#MALFORMED_VALUE_ERROR">MALFORMED_VALUE_ERROR</a>。可能包含其他警告和错误以帮助任何调试过程。
        </li>
        <li>
          返回|result|。
        </li>
      </ol>

      <p>
        验证保护机制的状态和验证输入文档是否为[=符合的文档=]的步骤可以按照与上述不同的顺序执行，只要实现对相同的无效输入返回错误。实现可能产生与上述不同的错误。
      </p>

    </section>

    <section>
      <h3>问题详情</h3>

      <p>
        当实现在处理文档时检测到异常时，可以使用<dfn>ProblemDetails</dfn>对象将问题报告给其他软件系统。这些类型对象的接口遵循[[RFC9457]]对数据进行编码。一个[=ProblemDetails=]对象包括以下属性：
      </p>

      <dl>
        <dt>type</dt>
        <dd>
          `type` [=property=] 必须存在，其值必须是一个 [=URL=]，用于标识问题的类型。
        </dd>
        <dt>code</dt>
        <dd>
          `code` [=property=] 是可选的。
          如果存在，其值必须是一个整数，用于标识问题的类型。
          整数代码在只提供整数返回值的系统中很有用。
        </dd>
        <dt>title</dt>
        <dd>
          `title` [=property=] 必须存在，其值应提供一个简短但具体的问题的人类可读字符串。
        </dd>
        <dt>detail</dt>
        <dd>
          `detail` [=property=] 必须存在，其值应提供一个较长的问题的人类可读字符串。
        </dd>
      </dl>

      <p>
        本规范定义了以下问题描述类型和代码：
      </p>

      <dl>
        <dt id="PARSING_ERROR">
          https://www.w3.org/TR/vc-data-model#PARSING_ERROR
          (-64)
        </dt>
        <dd>
          在解析输入时出现错误。
        </dd>
        <dt id="CRYPTOGRAPHIC_SECURITY_ERROR">
          https://www.w3.org/TR/vc-data-model#CRYPTOGRAPHIC_SECURITY_ERROR
          (-65)
        </dt>
        <dd>
          文档的安全机制检测到自创建以来文档内容的修改；
          检测到潜在的篡改。请参阅
          <a href="#verification"></a>部分。
        </dd>
        <dt id="MALFORMED_VALUE_ERROR">
          https://www.w3.org/TR/vc-data-model#MALFORMED_VALUE_ERROR
          (-66)
        </dt>
        <dd>
          与特定[=property=]关联的值格式错误。在[=ProblemDetails=]对象中应提供[=property=]的名称和属性路径。请参阅
          <a href="#verification"></a>部分。
        </dd>
        <dt id="RANGE_ERROR">
          https://www.w3.org/TR/vc-data-model#RANGE_ERROR
          (-67)
        </dt>
        <dd>
          提供的值超出了关联值的预期范围，
          例如，给定的数组索引值大于数组的当前大小。
        </dd>
      </dl>

      <p>
        实现可以通过指定其他类型、代码或属性来扩展[=ProblemDetails=]对象。有关使用此机制的进一步指导，请参阅[[RFC9457]]中的
        <a data-cite="RFC9457#name-extension-members">扩展成员</a>部分。
      </p>

    </section>

  </section>

  <section class="informative">
    <h2>隐私考虑</h2>

    <p>
      本节详细介绍了将可验证凭证数据模型部署到生产环境中的一般隐私考虑和具体隐私影响。
    </p>

    <section class="informative">
      <h3>隐私范围</h3>

      <p>
        重要的是要认识到，隐私有一个范围，从伪名到强烈识别。根据用例，人们对于他们愿意提供的信息以及从所提供的信息中可以得出的信息有不同的舒适度。
      </p>

      <figure>
        <img style="margin: auto; display: block; width: 80%;" src="diagrams/privacy-spectrum.svg" alt="水平条形图，左侧为红色，中间为橙色，右侧为绿色。红色部分的文字为'高度关联（全球ID），例如，政府ID，邮寄地址，信用卡号码'。橙色部分的文字为'通过勾结关联（个人身份信息），例如，姓名，生日，邮政编码'。绿色部分的文字为'不可关联（化名），例如，年龄超过21岁'。">
        <figcaption style="text-align: center;">
          从伪名到完全识别的隐私范围。
        </figcaption>
      </figure>

      <p>
        例如，大多数人在购买酒精时可能希望保持匿名，因为所需的监管检查仅基于一个人是否超过特定年龄。另一方面，对于医生为患者开具的医疗处方，配药的药房需要更强烈地识别医疗专业人员和患者。因此，并没有一种适用于所有用例的隐私方法。隐私解决方案是针对特定用例的。
      </p>

      <p class="note">
        即使对于那些在购买酒精时希望保持匿名的人，也可能仍需要提供照片身份证明以向商家提供适当的保证。商家可能不需要知道您的姓名或其他详细信息（除了您是否超过特定年龄），但在许多情况下，仅提供年龄证明可能仍然不足以满足法规要求。
      </p>

      <p>
        可验证凭证数据模型力求支持完整的隐私范围，并且在任何特定交易的正确匿名程度上不持哲学立场。以下各节为希望避免特定对隐私不友好的场景的实施者提供指导。
      </p>
    </section>

    <section class="informative">
      <h3>软件信任边界</h3>

      <p>
        在本规范所描述的<a href="#ecosystem-overview">生态系统</a>中存在各种信任关系。个人使用Web浏览器时，信任Web浏览器（也称为<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>）不会将他们的个人信息上传到数据代理；同样，填充本规范所描述的生态系统中的角色的实体信任代表这些角色的软件。示例包括以下内容：
      </p>

      <ul>
        <li>
          [=发行者=]的<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>（发行者软件），例如在线教育平台，预期只向发行者确认已完成其教育计划的个人发行[=可验证凭证=]。
        </li>
        <li>
          [=验证者=]的<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>（验证软件），例如招聘网站，预期只允许具有有效验证状态的个人访问，这些个人向平台提供[=可验证凭证=]和[=可验证演示文稿=]。
        </li>
        <li>
          [=持有者=]的<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>（持有者软件），例如数字钱包，预期只有在[=持有者=]同意释放该信息时才会向[=验证者=]泄露信息。
        </li>
      </ul>

      <p>
        上述示例并非详尽无遗，这些角色中的用户还可以期望从他们用来实现目标的软件中获得各种其他功能。简而言之，预计软件将为用户的最佳利益服务，违反该期望将导致信任的破裂，软件将被不违反信任的其他软件替代。强烈建议实施者编写不违反其服务用户信任的软件。实施者还建议在他们创建的软件中提供审计功能，以便用户或受信任的第三方可以检查软件是否确实在为他们的最佳利益服务。
      </p>

      <p>
        建议读者注意，某些软件（例如为单个[=验证者=]和多个[=持有者=]提供服务的网站）可能作为<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">用户代理</a>同时为这两个角色提供服务，但可能无法始终同时为所有各方的最佳利益服务。例如，如果该网站检测到多个[=持有者=]之间存在欺诈性[=可验证凭证=]的使用尝试，它可能会向[=验证者=]报告此类异常，这可能被认为不符合犯规的[=持有者=]的最佳利益，但符合[=验证者=]以及任何<em>不</em>犯此类违规行为的[=持有者=]的最佳利益。强烈建议在软件以这种方式运行时，通过诸如网站使用政策之类的机制明确软件是在谁的最佳利益下运行。
      </p>
    </section>

    <section class="informative">
      <h3>个人身份信息</h3>

      <p>
        存储在`credential.credentialSubject`字段中与[=可验证凭证=]相关的数据在与[=验证者=]共享时容易受到隐私侵犯。例如政府发行的标识符、邮寄地址和全名等个人身份信息，可以很容易地用来确定、追踪和关联一个[=实体=]。即使是看似不具有个人身份特征的信息，如出生日期和邮政编码的组合，也具有非常强大的关联和去匿名化能力。
      </p>

      <p>
        强烈建议实施者在[=持有者=]分享这类特征的数据时进行警告。强烈建议[=发行者=]在可能的情况下提供保护隐私的[=可验证凭证=]。例如，当一个[=验证者=]想要确定一个[=实体=]是否已满18岁时，发行`ageOver` [=可验证凭证=]而不是出生日期[=可验证凭证=]。
      </p>

      <p>
        由于[=可验证凭证=]通常包含个人身份信息(PII)，因此强烈建议实施者在存储和传输[=可验证凭证=]时使用保护数据免受非法访问的机制。可以考虑的机制包括传输层安全性(TLS)或其他在传输过程中加密数据的方式，以及加密或数据访问控制机制来保护存储在[=可验证凭证=]中的数据。
      </p>
    </section>

    <section class="informative">
      <h3>基于标识符的关联</h3>

      <p>
        [=可验证凭证=]的[=主体=]使用`credential.credentialSubject.id`字段进行识别。用于识别[=主体=]的标识符在跨多个网络域或长时间使用时，关联风险更大。
      </p>

      <p>
        同样地，披露[=凭证=]标识符（`credential.id`）会导致多个[=验证者=]或[=发行者=]与[=验证者=]串通关联[=持有者=]的情况。如果[=持有者=]希望减少关联，他们应使用允许在[=可验证呈现=]过程中隐藏标识符的[=可验证凭证=]方案。这类方案要求[=持有者=]生成标识符，甚至允许在保持标识符嵌入并签署在[=可验证凭证=]中的同时，将标识符对[=发行者=]进行隐藏。
      </p>

      <p>
        如果在[=可验证凭证=]系统中需要强大的反关联特性，强烈建议标识符采用以下方式之一：
      </p>

      <ul>
        <li>
          绑定到单一来源
        </li>
        <li>
          一次性使用
        </li>
        <li>
          根本不使用，而是用短时、一次性的持票人令牌替代。
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>基于签名的关联</h3>

      <p>
        使用安全机制保护[=凭证=]的内容。当在多个会话或域中使用相同的值且值不变时，用于表示安全机制的值会增加关联风险。
      </p>

      <p>
        如果需要强大的反关联特性，建议使用第三方成对签名、零知识证明或群签名等技术，每次重新生成签名值和元数据。
      </p>

      <p class="note">
        即使在使用反关联签名时，[=可验证凭证=]中可能仍然包含信息，从而使所使用的密码学的反关联特性失效。
      </p>
    </section>

    <section class="informative">
      <h3>基于长期标识符的关联</h3>

      <p>
        [=可验证凭证=]可能包含可用于关联个人的长期标识符。这些类型的标识符包括
        [=主题=]标识符、电子邮件地址、政府颁发的标识符、
        机构颁发的标识符、地址、医疗保健生命体征、
        [=可验证凭证=]特定的JSON-LD上下文，以及许多其他类型的
        长期标识符。
      </p>

      <p>
        向[=持有者=]提供软件的组织应努力识别
        [=可验证凭证=]中包含可用于关联个人的信息的字段，并在此类信息被
        共享时警告[=持有者=]。
      </p>
    </section>

    <section class="informative">
      <h3>基于元数据的关联</h3>

      <p>
        在第<a href="#basic-concepts"></a>节和第<a href="#advanced-concepts"></a>节中描述的不同扩展点的使用
        如果使用特定扩展类型或类型组合的[=颁发者=]数量相对较少，
        可能会成为一种无意识或不希望的关联机制。
        例如，仅由特定国家使用的某些类型的加密技术，或特定司法管辖区使用的吊销格式，
        或特定地区使用的凭证类型，都可以作为一种机制
        降低[=持有者=]在向[=验证者=]选择性披露信息时期望的匿名性。
      </p>

      <p>
        建议[=颁发者=]在颁发预期以匿名方式使用的[=可验证凭证=]时减少基于元数据的关联可能性，
        通过减少可用于缩小[=持有者=]匿名性的扩展类型。使用具有全球应用的凭证类型、
        扩展和技术概况优于具有国家应用的凭证类型，而具有国家应用的凭证类型优于仅具有地方应用的凭证类型。
      </p>
    </section>

    <section class="informative">
      <h3>设备追踪和指纹识别</h3>

      <p>
        存在一些外部机制，用于在互联网和Web上追踪和关联个体，这些机制不包括[=可验证的凭证=]。这些机制包括互联网协议（IP）地址追踪、网络浏览器指纹识别、永久cookies、广告网络追踪器、移动网络位置信息以及应用内全球定位系统（GPS）API。使用[=可验证的凭证=]无法阻止这些其他追踪技术的使用。此外，当这些技术与[=可验证的凭证=]一起使用时，可能会发现新的可关联信息。例如，生日与GPS位置的组合可以被用来在多个网站上强烈关联一个个体。
      </p>

      <p>
        建议尊重隐私的系统在使用[=可验证的凭证=]时阻止这些其他追踪技术的使用。在某些情况下，可能需要在代表[=持有者=]传输[=可验证的凭证=]的设备上禁用追踪技术。
      </p>

      <p>
        Oblivious HTTP协议[[?OHTTP]]是实施者在获取与[=可验证的凭证=]或[=可验证的展示=]相关的外部资源时可能会考虑使用的一种机制。Oblivious HTTP允许客户端向源服务器发送多个请求，而该服务器无法将这些请求链接到该客户端，甚至无法识别这些请求来自同一个客户端，同时只对用于转发消息的节点有限的信任。因此，Oblivious HTTP是一种可以用来减少设备追踪和指纹识别可能性的保护隐私的机制。以下包含了Oblivious HTTP如何使生态系统参与者受益的具体示例。
      </p>

      <ul>
        <li>
          使用数字钱包的[=持有者=]可以减少他们在访问存储在其数字钱包中的[=可验证的凭证=]内的外部链接时被第三方追踪的可能性。例如，数字钱包可能会获取并呈现链接的图像，或者通过获取外部链接的撤销列表来检查[=可验证的凭证=]的有效性。
        </li>
        <li>
          [=验证者=]可以减少向[=发行者=]发出已收到特定[=可验证的凭证=]的信号。例如，[=验证者=]在对[=可验证的凭证=]进行状态检查时，可能会获取外部链接的撤销列表。
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>偏爱抽象声明</h3>

      <p>
        为了让[=可验证凭证=]的接收者在各种情况下使用它们，而无需透露比交易所需更多的个人身份信息（PII），[=发行者=]应考虑将发布在[=凭证=]中的信息限制为预期目的所需的最小集合。避免在[=凭证=]中放置个人身份信息的一种方法是使用一种抽象的[=属性=]，该属性满足[=验证者=]的需求，而无需提供关于[=主题=]的具体信息。
      </p>
      <p>
        例如，本文档使用了`ageOver` [=属性=]，而不是具体的出生日期，后者构成了更强的个人身份信息。如果某个特定市场的零售商通常要求购买者年龄大于某个年龄，那么在该市场受信任的[=发行者=]可能会选择提供一种[=可验证凭证=]，声称[=主题=]已经满足了该要求，而不是提供包含关于具体出生日期的[=声明=]的[=可验证凭证=]。这使得个人顾客可以在不透露具体个人身份信息的情况下进行购买。
      </p>
    </section>

    <section class="informative">
      <h3>数据最小化原则</h3>

      <p>
        当在一个上下文中泄露的信息泄露到另一个上下文时，就会发生隐私侵犯。防止此类侵犯的公认最佳做法是将请求和接收的信息限制到绝对最小必要。这种数据最小化方法在多个司法管辖区中都被法规要求，包括美国的健康保险可携带性和责任法案（HIPAA）和欧盟的一般数据保护条例（GDPR）。
      </p>
      <p>
        对于[=可验证的凭证=]，对[=发行者=]来说，数据最小化意味着将[=可验证的凭证=]的内容限制到潜在的[=验证者=]预期使用所需的最小限度。对于[=验证者=]，数据最小化意味着限制请求或获取服务所需的信息范围。
      </p>
      <p>
        例如，一个包含驾驶员ID号码、身高、体重、生日和家庭地址的驾驶执照是一个[=凭证=]，它包含的信息比确认一个人是否超过某个年龄所需的信息更多。
      </p>

      <p>
        一般认为，[=发行者=]最好将信息原子化或使用允许[=选择性披露=]的签名方案。例如，驾驶执照的[=发行者=]可以发行一个包含驾驶执照上出现的每个属性的[=可验证的凭证=]，以及一组每个[=可验证的凭证=]只包含一个属性（如一个人的生日）的[=可验证的凭证=]。它还可以发行更抽象的[=可验证的凭证=]（例如，只包含`ageOver`属性的[=可验证的凭证=]）。一种可能的适应方式是[=发行者=]提供安全的HTTP端点，用于检索单次使用的[=持有人凭证=]，以促进[=可验证的凭证=]的匿名使用。认为这种做法不切实际或不安全的实施者，应考虑使用[=选择性披露=]方案，以消除在证明时间和减少来自[=发行者=]的时间关联风险的依赖。
      </p>

      <p>
        强烈建议[=验证者=]只请求进行特定交易绝对必要的信息。这至少有两个原因。它：
      </p>

      <ul>
        <li>
          减少了[=验证者=]处理其不需要的高度敏感信息的责任。
        </li>
        <li>
          通过只询问特定交易所需的信息，增强了个人的隐私。
        </li>
      </ul>

      <p class="note">
        虽然可以实践最小披露原则，但在一个会话或多个会话中，对于特定用例，可能无法避免强烈识别个人。本文档的作者无法强调在现实世界场景中满足这一原则有多困难。
      </p>
    </section>

    <section class="informative">
      <h3>持票人凭证</h3>

      <p>
        一个<dfn data-lt="bearer credentials">持票人凭证</dfn>是一种
        增强隐私的信息，例如音乐会门票，它使得持票人凭证的[=持有者=]有权获得特定资源，而无需
        泄露关于[=持有者=]的敏感信息。持票人凭证通常用于低风险的使用场景，其中分享持票人凭证不是
        一个问题，或者不会导致巨大的经济或声誉损失。
      </p>

      <p>
        [=可验证凭证=]中的[=持票人凭证=]是通过不指定[=主题=]标识符实现的，该标识符使用
        `id` [=属性=]表示，它嵌套在
        `credentialSubject` [=属性=]中。例如，以下
        [=可验证凭证=]是一个[=持票人凭证=]：
      </p>

      <pre class="example nohighlight vc" title="Usage of issuer properties"
        data-vc-vm="https://university.example/issuers/14#keys-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/temporary/28934792387492384",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2017-10-22T12:23:48Z",
  "credentialSubject": {
    <span class="comment">// note that the 'id' property is not specified for bearer credentials</span>
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
          虽然[=持票人凭证=]可以增强隐私，但必须精心设计，以免意外泄露比[=持有人=]
          预期的更多信息。例如，在多个站点上重复使用相同的
          [=持票人凭证=]使这些站点可能串通起来不当地跟踪或关联[=持有人=]。同样，
          可能看似非识别的信息，如出生日期和邮政编码，在同一[=持票人凭证=]或会话中一起使用时
          可以用于统计识别个人。
        </p>
  
        <p>
          [=发行人=]应确保[=持票人凭证=]提供增强隐私的好处，包括：
        </p>
  
        <ul>
          <li>
            尽可能实现一次性使用。
          </li>
          <li>
            不包含个人识别信息。
          </li>
          <li>
            不会过度关联。
          </li>
        </ul>
  
        <p>
          如果发行或请求包含敏感信息的[=持票人凭证=]，或者在一个或多个会话中组合两个或多个[=持票人凭证=]时存在关联风险，
          [=持有人=]应被其软件警告。虽然检测到所有关联风险可能是不可能的，但某些风险肯定是可以检测到的。
        </p>
  
        <p>
          [=验证者=]不应请求可用于不当关联[=持有人=]的[=持票人凭证=]。
        </p>
    </section>

    <section class="informative">
      <h3>Validation</h3>

      <p>
        When processing [=verifiable credentials=], [=verifiers=]
        evaluate any relevant [=claims=] before relying upon them. This
        evaluation might be done in any manner desired, as long as it satisfies
        the requirements of the [=verifier=] doing the validation.
        Many verifiers will perform the checks listed in Appendix <a href="#validation-0"></a> as well as a variety of
        specific business process
        checks such as:
      </p>

      <ul>
        <li>
          The professional licensure status of the [=holder=].
        </li>
        <li>
          A date of license renewal or revocation.
        </li>
        <li>
          The sub-qualifications of an individual.
        </li>
        <li>
          If a relationship exists between the [=holder=] and the [=entity=]
          with whom the [=holder=] is attempting to interact.
        </li>
        <li>
          The geolocation information associated with the [=holder=].
        </li>
      </ul>

      <p>
        The process of performing these checks might result in information leakage that
        leads to a privacy violation of the [=holder=]. For example, a simple
        operation, such as checking an improperly configured revocation list, can
        notify the [=issuer=] that a specific business is likely interacting
        with the [=holder=]. This could
        enable [=issuers=] to collude to correlate individuals without their
        knowledge.
      </p>

      <p>
        [=Issuers=] are urged to not use mechanisms, such as [=credential=]
        revocation lists that are unique per [=credential=], during the
        [=verification=] process that could lead to privacy violations. Organizations
        providing software to [=holders=] should warn when [=credentials=] include
        information that could lead to privacy violations during the verification
        process. [=Verifiers=] should consider rejecting [=credentials=] that
        produce privacy violations or that enable bad privacy practices.
      </p>
    </section>

    <section class="informative">
      <h3>Storage Providers and Data Mining</h3>

      <p>
        When a [=holder=] receives a [=verifiable credential=] from an
        [=issuer=], the [=verifiable credential=] needs to be stored somewhere
        (for example, in a [=credential=] repository). [=Holders=] are warned that
        the information in a [=verifiable credential=] is sensitive in nature and
        highly individualized, making it a high value target for data mining. Services
        that advertise free storage of [=verifiable credentials=] might in fact be
        mining personal data and selling it to organizations wanting to build
        individualized profiles on people and organizations.
      </p>
      <p>
        [=Holders=] need to be aware of the terms of service for their
        [=credential=] repository, specifically the correlation and data mining
        protections in place for those who store their [=verifiable credentials=]
        with the service provider.
      </p>
      <p>
        Some effective mitigations for data mining and profiling include using:
      </p>

      <ul>
        <li>
          Service providers that do not sell your information to third parties.
        </li>
        <li>
          Software that encrypts [=verifiable credentials=] such that a service
          provider cannot view the contents of the [=credential=].
        </li>
        <li>
          Software that stores [=verifiable credentials=] locally on a device that you
          control and that does not upload or analyze your information beyond your
          expectations.
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>Aggregation of Credentials</h3>

      <p>
        Holding two pieces of information about the same [=subject=] almost always
        reveals more about the [=subject=] than just the sum of the two pieces, even
        when the information is delivered through different channels. The aggregation of
        [=verifiable credentials=] is a privacy risk and all participants in
        the ecosystem need to be aware of the risks of data aggregation.
      </p>

      <p>
        For example, if two [=bearer credentials=], one for an email address and then
        one stating the [=holder=] is over the age of 21, are provided across
        multiple sessions, the [=verifier=] of the information now has a unique
        identifier as well as age-related information for that individual. It is now
        easy to create and build a profile for the [=holder=] such that more and more
        information is leaked over time. Aggregation of [=credentials=] can also be
        performed across multiple sites in collusion with each other, leading to privacy
        violations.
      </p>

      <p>
        From a technological perspective, preventing aggregation of information is a
        very difficult privacy problem to address. While new cryptographic techniques,
        such as zero-knowledge proofs, are being proposed as solutions to the problem
        of aggregation and correlation, the existence of long-lived identifiers and
        browser tracking techniques defeats even the most modern cryptographic
        techniques.
      </p>

      <p>
        The solution to the privacy implications of correlation or aggregation tends not
        to be technological in nature, but policy driven instead. Therefore, if a
        [=holder=] does not want information about them to be aggregated, they must
        express this in the [=verifiable presentations=] they transmit.
      </p>
    </section>

    <section class="informative">
      <h3>Usage Patterns</h3>

      <p>
        Despite the best efforts to assure privacy, actually using
        [=verifiable credentials=] can potentially lead to de-anonymization and a
        loss of privacy. This correlation can occur when:
      </p>

      <ul>
        <li>
          The same [=verifiable credential=] is presented to the same [=verifier=]
          more than once. The [=verifier=] could infer that the [=holder=] is the
          same individual.
        </li>
        <li>
          The same [=verifiable credential=] is presented to different
          [=verifiers=], and either those [=verifiers=] collude or a third party
          has access to transaction records from both [=verifiers=]. An observant
          party could infer that the individual presenting the
          [=verifiable credential=] is the same person at both services. That is, the
          accounts are controlled by the same person.
        </li>
        <li>
          A [=subject=] identifier of a [=credential=] refers to the same
          [=subject=] across multiple [=presentations=] or [=verifiers=]. Even
          when different [=credentials=] are presented, if the [=subject=]
          identifier is the same, [=verifiers=] (and those with access to
          [=verifier=] logs) could infer that the [=holder=] of the
          [=credential=] is the same person.
        </li>
        <li>
          The underlying information in a [=credential=] can be used to identify an
          individual across services. In this case, using information from other sources
          (including information provided directly by the [=holder=]), [=verifiers=]
          can use information inside the [=credential=] to correlate the individual
          with an existing profile. For example, if a [=holder=] presents
          [=credentials=] that include postal code, age, and gender, a [=verifier=]
          can potentially correlate the [=subject=] of that [=credential=] with an
          established profile. For more information, see [[DEMOGRAPHICS]].
        </li>
        <li>
          Passing the identifier of a [=credential=] to a centralized revocation
          server. The centralized server can correlate the [=credential=] usage across
          interactions. For example, if a [=credential=] is used for proof of age in
          this manner, the centralized service could know everywhere that
          [=credential=] was presented (all liquor stores, bars, adult stores, lottery
          purchases, and so on).
        </li>
      </ul>

      <p>
        In part, it is possible to mitigate this de-anonymization and loss of privacy
        by:
      </p>

      <ul>
        <li>
          Using a globally-unique identifier as the [=subject=] for any given
          [=credential=] and never re-use that [=credential=].
        </li>
        <li>
          If the [=credential=] supports revocation, using a globally-distributed
          service for revocation.
        </li>
        <li>
          Designing revocation APIs that do not depend on submitting the ID of the
          [=credential=]. For example, use a revocation list instead of a query.
        </li>
        <li>
          Avoiding the association of personally identifiable information with any
          specific long-lived [=subject=] identifier.
        </li>
      </ul>

      <p>
        It is understood that these mitigation techniques are not always practical
        or even compatible with necessary usage. Sometimes correlation is a
        requirement.
      </p>
      <p>
        For example, in some prescription drug monitoring programs, usage monitoring is
        a requirement. Enforcement entities need to be able to confirm that individuals
        are not cheating the system to get multiple prescriptions for controlled
        substances. This statutory or regulatory need to correlate usage overrides
        individual privacy concerns.
      </p>

      <p>
        [=Verifiable credentials=] will also be used to intentionally correlate
        individuals across services, for example, when using a common persona to log in
        to multiple services, so all activity on each of those services is
        intentionally linked to the same individual. This is not a privacy issue as
        long as each of those services uses the correlation in the expected manner.
      </p>

      <p>
        Privacy risks of [=credential=] usage occur when unintended or unexpected
        correlation arises from the presentation of [=credentials=].
      </p>
    </section>

    <section class="informative">
      <h3>Sharing Information with the Wrong Party</h3>

      <p>
        When a [=holder=] chooses to share information with a [=verifier=], it
        might be the case that the [=verifier=] is acting in bad faith and requests
        information that could be used to harm the [=holder=]. For example, a
        [=verifier=] might ask for a bank account number, which could then be used
        with other information to defraud the [=holder=] or the bank.
      </p>

      <p>
        [=Issuers=] should strive to tokenize as much information as possible such
        that if a [=holder=] accidentally transmits [=credentials=] to the wrong
        [=verifier=], the situation is not catastrophic.
      </p>

      <p>
        For example, instead of including a bank account number for the purpose of
        checking an individual's bank balance, provide a token that enables the
        [=verifier=] to check if the balance is above a certain amount. In this
        case, the bank could issue a [=verifiable credential=] containing a balance
        checking token to a [=holder=]. The [=holder=] would then include the
        [=verifiable credential=] in a [=verifiable presentation=] and bind the
        token to a credit checking agency using a digital signature. The
        [=verifier=] could then wrap the [=verifiable presentation=] in their
        digital signature, and hand it back to the issuer to dynamically check the
        account balance.
      </p>

      <p>
        Using this approach, even if a [=holder=] shares the account balance token
        with the wrong party, an attacker cannot discover the bank account number, nor
        the exact value in the account. And given the validity period for the
        counter-signature, does not gain access to the token for more than a few
        minutes.
      </p>
    </section>

    <section class="informative">
      <h3>Data Theft</h3>

      <p>
        The data expressed in [=verifiable credentials=] and
        [=verifiable presentations=] are valuable since they contain authentic
        statements made by trusted third parties, such as [=issuers=], or
        individuals, such as [=holders=] and [=subjects=]. Storing this data
        can create honeypots of sensitive data that attackers are motivated to
        break into in order to acquire and exchange that data for financial gain.
      </p>
      <p>
        [=Issuers=] are advised to retain the minimum amount of data
        necessary to issue [=verifiable credentials=] to [=holders=] and
        manage the status and revocation of those credentials.
      </p>
      <p>
        [=Holders=] are advised to use implementations that appropriately
        encrypt their data both in transit and at rest, and protect sensitive
        material (such as cryptographic secrets) in ways that cannot be easily
        extracted from hardware devices. Furthermore, it is suggested that
        [=holders=] store and manipulate their data only on devices that they
        control, away from centralized systems, to reduce the likelihood of
        attack on their data, or large-scale theft if an attack is successful.
      </p>
      <p>
        [=Verifiers=] are advised to only ask for data necessary for a particular
        transaction and to not retain any data beyond the needs of any particular
        transaction.
      </p>
      <p>
        Regulators are advised to rethink audit requirements such that more
        privacy-preserving mechanisms can be used to achieve similar levels of
        enforcement and audit capabilities. For example, audit-focused regulations
        that insist on collection and long-term retention of personally identifiable
        information can cause harm to individuals and organizations if that same
        information is compromised and accessed by an attacker. The technologies
        described by this specification enable [=holders=] to more-readily prove
        attributes about themselves and others, reducing the need for long-term data
        retention by [=verifiers=]. Alternatives include keeping logs that the
        information was collected and checked, as well as random tests to ensure
        that compliance regimes are operating as expected.
      </p>
    </section>

    <section class="informative">
      <h3>Frequency of Claim Issuance</h3>

      <p>
        As detailed in Section <a href="#usage-patterns"></a>, usage patterns can be
        correlated into certain types of behavior. Part of this correlation is
        mitigated when a [=holder=] uses a [=verifiable credential=] without the
        knowledge of the [=issuer=]. [=Issuers=] can defeat this protection
        however, by making their [=verifiable credentials=] short lived and renewal
        automatic.
      </p>

      <p>
        For example, an `ageOver` [=verifiable credential=] is useful for
        gaining access to a bar. If an [=issuer=] issues such a
        [=verifiable credential=] with a very short validity period and an automatic
        renewal mechanism, then the [=issuer=] could possibly correlate the behavior
        of the [=holder=] in a way that negatively impacts the [=holder=].
      </p>

      <p>
        Organizations providing software to [=holders=] should warn them if they
        repeatedly use [=credentials=] with short lifespans, which could result in
        behavior correlation. [=Issuers=] should avoid issuing [=credentials=] in
        a way that enables them to correlate usage patterns.
      </p>
    </section>

    <section class="informative">
      <h3>Prefer Single-Use Credentials</h3>

      <p>
        An ideal privacy-respecting system would require only the information necessary
        for interaction with the [=verifier=] to be disclosed by the [=holder=].
        The [=verifier=] would then record that the disclosure requirement was met
        and forget any sensitive information that was disclosed. In many cases,
        competing priorities, such as regulatory burden, prevent this ideal system from
        being employed. In other cases, long-lived identifiers prevent single use. The
        design of any [=verifiable credentials=] ecosystem, however, should strive
        to be as privacy-respecting as possible by preferring single-use
        [=verifiable credentials=] whenever possible.
      </p>

      <p>
        Using single-use [=verifiable credentials=] provides several benefits. The
        first benefit is to [=verifiers=] who can be sure that the data in a
        [=verifiable credential=] is fresh. The second benefit is to [=holders=],
        who know that if there are no long-lived identifiers in the
        [=verifiable credential=], the [=verifiable credential=] itself cannot be
        used to track or correlate them online. Finally, there is nothing for attackers
        to steal, making the entire ecosystem safer to operate within.
      </p>
    </section>

    <section class="informative">
      <h3>Private Browsing</h3>

      <p>
        In an ideal private browsing scenario, no PII will be revealed. Because many
        [=credentials=] include PII, organizations providing software to
        [=holders=] should warn them about the possibility of revealing this
        information if they wish to use [=credentials=] and [=presentations=]
        while in private browsing mode. As each browser vendor handles private browsing
        differently, and some browsers might not have this feature at all, it is
        important for implementers to be aware of these differences and implement
        solutions accordingly.
      </p>
    </section>

    <section class="informative">
      <h3>Issuer Cooperation Impacts on Privacy</h3>

      <p>
        It cannot be overstated that [=verifiable credentials=] rely on a high degree
        of trust in [=issuers=]. The degree to which a [=holder=] might take
        advantage of possible privacy protections often depends strongly on the support
        an [=issuer=] provides for such features. In many cases, privacy protections
        which make use of zero-knowledge proofs, data minimization techniques, bearer
        credentials, abstract claims, and protections against signature-based
        correlation, require the [=issuer=] to actively support such capabilities and
        incorporate them into the [=verifiable credentials=] they issue.
      </p>
      <p>
        It should also be noted that, in addition to a reliance on [=issuer=]
        participation to provide [=verifiable credential=] capabilities that help
        preserve [=holder=] and [=subject=] privacy, [=holders=] rely on
        [=issuers=] to not deliberately subvert privacy protections. For example, an
        [=issuer=] might sign [=verifiable credentials=] using a signature scheme
        that protects against signature-based correlation. This would protect the
        [=holder=] from being correlated by the signature value as it is shared among
        [=verifiers=]. However, if the [=issuer=] creates a unique key for each
        issued [=credential=], it might be possible for the [=issuer=] to track
        [=presentations=] of the [=credential=], regardless of a [=verifier=]'s
        inability to do so.
      </p>
      <p>
        In addition to previously described privacy protections an [=issuer=] might
        use, [=issuers=] need to also be aware of data they leak associated with
        identifiers and claim types they use when issuing [=credentials=]. One
        example of this would be an [=issuer=] issuing drivers licenses which reveal
        both the location(s) in which they have jurisdiction and the location of the
        [=subject's=] residence. [=Verifiers=] might take advantage of this by
        requesting a [=credential=] to check that the [=subject=] is licensed to
        drive, when in fact they are interested in metadata <em>about</em> the
        credential, such as which [=issuer=] issued the credential, and tangential
        information that might have been leaked by the [=issuer=], such as the
        subject's home address. To mitigate such leakage, [=issuers=] might choose to
        use common identifiers to mask specific location information or other sensitive
        metadata; for example, a shared issuer identifier at a state or nation level,
        instead of at the level of a county, city, town, or other smaller municipality.
        Further, [=holder=] attestation mechanisms can be used by [=verifiers=] to
        preserve privacy, by providing proofs that an [=issuer=] exists in a set of
        trusted entities, without needing to disclose the exact [=issuer=].
      </p>
    </section>
  </section>

  <section class="informative">
    <h2>Security Considerations</h2>

    <p>
      There are a number of security considerations that [=issuers=],
      [=holders=], and [=verifiers=] should be aware of when processing data
      described by this specification. Ignoring or not understanding the implications
      of this section can result in security vulnerabilities.
    </p>

    <p>
      While this section attempts to highlight a broad set of security considerations,
      it is not a complete list. Implementers are urged to seek the advice of security
      and cryptography professionals when implementing mission critical systems using
      the technology outlined in this specification.
    </p>

    <section class="informative">
      <h3>Cryptography Suites and Libraries</h3>

      <p>
        Some aspects of the data model described in this specification can be
        protected through the use of cryptography. It is important for implementers to
        understand the cryptography suites and libraries used to create and process
        [=credentials=] and [=presentations=]. Implementing and auditing
        cryptography systems generally requires substantial experience. Effective
        <a href="https://en.wikipedia.org/wiki/Red_team">red teaming</a> can also
        help remove bias from security reviews.
      </p>

      <p>
        Cryptography suites and libraries have a shelf life and eventually fall to
        new attacks and technology advances. Production quality systems need to take
        this into account and ensure mechanisms exist to easily and proactively upgrade
        expired or broken cryptography suites and libraries, and to invalidate
        and replace existing [=credentials=]. Regular monitoring is important to
        ensure the long term viability of systems processing [=credentials=].
      </p>
    </section>

    <section class="informative">
      <h3>Key Management</h3>
      <p>
        The security of most digital signature algorithms, which are used to secure
        [=verifiable credentials=] and [=verifiable presentations=], is dependent
        on the quality and protection of their <em>private signing keys</em>. Guidance
        in the management of cryptographic keys is a large subject and the reader is
        referred to [[NIST-SP-800-57-Part-1]] for more extensive recommendations and
        discussion. As strongly recommended in both [[FIPS-186-5]] and
        [[NIST-SP-800-57-Part-1]], a private signing key is not to be used for multiple
        purposes, e.g., a private signing key is not to be used for encryption as well
        as signing.
      </p>
      <p>
        [[NIST-SP-800-57-Part-1]] strongly advises that private signing keys and
        <em>public verification keys</em> have limited <em>cryptoperiods</em>, where
        a <em>cryptoperiod</em> is &quot;the time span during which a specific key is
        authorized for use by legitimate entities or the keys for a given system will
        remain in effect.&quot; [[NIST-SP-800-57-Part-1]] gives extensive
        guidance on cryptoperiods for different key types under different situations,
        and generally recommends a 1-3 year cryptoperiod for a private signing key.
      </p>
      <p>
        To deal with potential private key compromises, [[NIST-SP-800-57-Part-1]]
        provides recommendations for protective measures, harm reduction, and
        revocation. Although this section focuses primarily on the security of the
        private signing key, [[NIST-SP-800-57-Part-1]] also highly recommends
        confirmation of the validity of all [=verification material=] before using it.
      </p>
    </section>

    <section class="informative">
      <h3>Content Integrity Protection</h3>

      <p>
        [=Verifiable credentials=] often contain URLs to data that resides outside of
        the [=verifiable credential=] itself. Linked content that exists outside a
        [=verifiable credential=], such as images, JSON-LD Contexts, JSON Schemas,
        and other machine-readable data, are often not protected against tampering
        because the data resides outside of the protection of the
        <a href="#securing-mechanisms">securing mechanism</a> on the
        [=verifiable credential=]. For example, the content retrievable by
        dereferencing the following highlighted links is not integrity protected, but
        probably ought to be:
      </p>

      <pre class="example nohighlight" title="Non-content-integrity protected links">
{
  "@context": [
    <span class="highlight">"https://www.w3.org/ns/credentials/v2"</span>,
    <span class="highlight">"https://www.w3.org/ns/credentials/examples/v2"</span>
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://university.example/images/58473"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

      <p>
        While this specification does not recommend any specific content integrity
        protection, document authors who want to ensure links to content are integrity
        protected are advised to use URL schemes that enforce content integrity.
      </p>

      <pre class="example nohighlight" title="Content-integrity protection for links to external data">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2<span class="highlight">?hl=z3aq31uzgnZBuWNzUB</span>",
    "https://www.w3.org/ns/credentials/examples/v2<span class="highlight">?hl=z8guWNzUBnZBu3aq31</span>"
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://example.com/image"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

      <p class="note">
        It is debatable whether the JSON-LD Contexts above need protection because
        production implementations are expected to ship with static copies of important
        JSON-LD Contexts.
      </p>

      <p>
        While the example above is one way to achieve content integrity protection,
        there are other solutions that might be better suited for certain applications.
        Implementers are urged to understand how links to external machine-readable
        content that are not content-integrity protected could result in successful
        attacks against their applications.
      </p>

    </section>

    <section class="informative">
      <h3>Unsigned Claims</h3>

      <p>
        This specification allows [=credentials=] to be produced that are not secured by
        signatures or proofs of any kind. These types of [=credentials=] are often
        useful for intermediate storage, or self-asserted information, which is
        analogous to filling out a form on a web page. Implementers should be aware that
        these types of [=credentials=] are not [=verifiable=] because the
        authorship either is not known or cannot be trusted.
      </p>
    </section>

    <section class="informative">
      <h3>Man-in-the-Middle (MITM), Replay, and Cloning Attacks</h3>

      <p>
        The data model does not inherently prevent
        <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-in-the-Middle (MITM)</a>,
        <a href="https://en.wikipedia.org/wiki/Replay_attack">replay</a>, and
        <a href="https://en.wikipedia.org/wiki/Spoofing_attack">spoofing</a> attacks.
        Both online and offline use cases might be susceptible to these types of
        attacks, where an adversary intercepts, modifies, re-uses, and/or replicates the
        [=verifiable credential=] data during transmission or storage.
      </p>
      <h4>Man-in-the-Middle (MITM) Attack</h4>

      <p>
        A [=verifier=] might need to ensure it is the intended recipient of a
        [=verifiable presentation=] and not the target of a
        <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">
          man-in-the-middle attack</a>. Some <a href="#securing-mechanisms">securing
          mechanisms</a>, like [[VC-JOSE-COSE]] or [[VC-DATA-INTEGRITY]], provide an
        option to specify the intended audience or domain of a [=presentation=],
        which can help reduce this risk.
      </p>
      <p>
        Alternate approaches such as token binding [[RFC8471]], which ties the request
        for a [=verifiable presentation=] to the response, can secure the protocol.
        Any unsecured protocol is susceptible to man-in-the-middle attacks.
      </p>
      <h4>Replay Attack</h4>

      <p>
        A [=verifier=] might wish to ensure that a [=verifiable presentation=] is
        not used more than a certain number of times. For example, a [=verifiable
        credential=] representing an event ticket, might allow entry to multiple
        individuals if presented multiple times, undermining the purpose of the ticket
        from the perspective of its issuer. To prevent against such attacks,
        [=holders=] can make use of techniques such as including a
        <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a> during
        presentation, or adding an expiry timestamp to reduce the window of attack.
      </p>
      <h4>Spoofing Attack</h4>

      <p>
        A [=verifier=] has a vested interest in knowing that a [=holder=] is
        authorized to present the claims inside of a [=verifiable presentation=].
        While the data model outlines the structure and data elements necessary for a
        [=verifiable credential=], it does not include a mechanism to ascertain the
        authorization of presented [=credentials=]. To address this concern,
        implementers might need to explore supplementary methods, such as binding
        [=verifiable credentials=] to strong authentication mechanisms or using
        additional attributes in [=verifiable presentations=]
        to enable proof of control.
      </p>
    </section>
    <section class="informative">
      <h3>Bundling Dependent Claims</h3>

      <p>
        It is considered best practice for [=issuers=] to atomize information in a
        [=credential=], or use a signature scheme that allows for selective
        disclosure. In the case of atomization, if it is not done securely by the
        [=issuer=], the [=holder=] might bundle together different
        [=credentials=] in a way that was not intended by the [=issuer=].
      </p>

      <p>
        For example, a university might issue two [=verifiable credentials=] to a
        person, each containing two [=properties=], which must be taken together
        to designate the "role" of that person in a given "department", such as "Staff
        Member" in the "Department of Computing", or "Post Graduate Student" in the
        "Department of Economics". If these [=verifiable credentials=] are atomized
        to put only one of these [=properties=] into each [=credential=] , then
        the university would issue four [=credentials=] to the person, each
        containing one of the following designations: "Staff Member", "Post Graduate
        Student", "Department of Computing", and "Department of Economics". The
        [=holder=] might then transfer the "Staff Member" and "Department of
        Economics" [=verifiable credentials=] to a [=verifier=], which together
        would comprise a false [=claim=].
      </p>
    </section>

    <section class="informative">
      <h3>Highly Dynamic Information</h3>

      <p>
        When [=verifiable credentials=] are issued for highly dynamic information,
        implementers should ensure the validity periods are set appropriately. Validity
        periods longer than the timeframe where the [=verifiable credential=] is
        meant for use might create exploitable security vulnerabilities. Validity
        periods shorter than the timeframe where the information expressed by the
        [=verifiable credential=] is expected to be used creates a burden on
        [=holders=] and [=verifiers=]. It is therefore important to set validity
        periods for [=verifiable credentials=] that are appropriate to the use case
        and the expected lifetime for the information contained in the
        [=verifiable credential=].
      </p>
    </section>

    <section class="informative">
      <h3>Device Theft and Impersonation</h3>

      <p>
        When [=verifiable credentials=] are stored on a device and that
        device is lost or stolen, it might be possible for an attacker to gain access
        to systems using the victim's [=verifiable credentials=]. Ways to mitigate
        this type of attack include:
      </p>

      <ul>
        <li>
          Enabling password, pin, pattern, or biometric screen unlock protection on the
          device.
        </li>
        <li>
          Enabling password, biometric, or multi-factor authentication for the
          [=credential=] [=repository=].
        </li>
        <li>
          Enabling password, biometric, or multi-factor authentication when accessing
          cryptographic keys.
        </li>
        <li>
          Using a separate hardware-based signature device.
        </li>
        <li>
          All or any combination of the above.
        </li>
      </ul>

      <p>
        Furthermore, instances of impersonation can manifest in various forms, including
        situations where an [=entity=] attempts to disavow their actions. Elevating
        the level of trust and security within the realm of [=verifiable
        credentials=] entails more than just averting impersonation; it involves the
        implementation of non-repudiation mechanisms. These mechanisms solidify an
        [=entity=]'s responsibility for their actions or transactions, thereby
        reinforcing accountability and deterring malicious behaviors. The attainment of
        non-repudiation is a multifaceted endeavor, encompassing an array of techniques
        ranging from <a href="#securing-mechanisms">securing mechanisms</a>, proofs of
        possession, and authentication schemes in a variety of protocols designed to
        foster trust and reliability.
      </p>
    </section>
    <section class="informative">
      <h3>Acceptable Use</h3>

      <p>
        Ensuring that there is alignment between an [=entity=]'s actions, such as
        [=presentation=], and the intended purpose of those actions, is of
        importance. It involves having the authorization to make use of [=verifiable
        credentials=] as well as using [=credentials=] in a manner that adheres to
        their designated scope(s) and objective(s). Two critical aspects that arise
        within this context are <i>Unauthorized Use</i> and <i>Inappropriate Use</i>.
      </p>
      <h4>Unauthorized Use</h4>
      <p>
        Any attempt by entities to make use of [=verifiable credentials=] and
        [=verifiable presentations=] outside of their intended use can be seen as
        unauthorized. One class of unauthorized use is a <i>confidentiality
          violation</i>. Consider an example where a [=holder=] shares a [=verifiable
        presentation=] with a [=verifier=] to establish their age and residency
        status. If the [=verifier=] then proceeds to exploit the [=holder's=] data
        without proper consent, such as by selling the data to a data broker, that would
        constitute an unauthorized use of the data, violating an expectation of privacy
        that the [=holder=] might have in the transaction.
      </p>
      <p>
        Similarly, an [=issuer=] could make use of a
        <a href="#terms-of-use">termsOfUse</a> property to stipulate how and when a
        credential might be used. A [=holder=] using credentials outside of the
        scopes defined in the `termsOfUse` would be considered unauthorized
        use.
      </p>
      <p class="note">
        Further study is required to determine how a [=holder=] can assert and
        enforce authorized use of their data after [=presentation=].
      </p>
      <h4>Inappropriate Use</h4>
      <p>
        While valid cryptographic signatures and successful status checks signify the
        reliability of [=credentials=], they do not signify that all
        [=credentials=] are interchangeable for all contexts. It is crucial that
        [=verifiers=] also <a href="#validation-0">validate</a> any claims which
        might be relevant, considering the source and nature of the claim as well as
        privilege or service for which the credential is presented.
      </p>
      <p>
        For instance, in scenarios where a certified medical diagnosis is required, a
        self-asserted [=credential=] carrying the necessary data might not suffice
        because it lacks validity from an authoritative medical source. To ensure the
        propriety of [=credential=] use, stakeholders are urged to assess the
        <a href="#dfn-credential">credential's</a> relevance and authority within the
        specific context of their intended application.
      </p>
    </section>
  </section>

  <section class="informative">
    <h2>Accessibility Considerations</h2>

    <p>
      There are a number of accessibility considerations implementers should be
      aware of when processing data described in this specification. As with
      implementation of any web standard or protocol, ignoring accessibility issues
      makes this information unusable by a large subset of the population. It is
      important to follow accessibility guidelines and standards, such as [[WCAG21]],
      to ensure that all people, regardless of ability, can make use of this data.
      This is especially important when establishing systems utilizing cryptography,
      which have historically created problems for assistive technologies.
    </p>

    <p>
      This section details the general accessibility considerations to take into
      account when utilizing this data model.
    </p>

    <section class="informative">
      <h3>Data First Approaches</h3>

      <p>
        Many physical [=credentials=] in use today, such as government identification
        cards, have poor accessibility characteristics, including, but not limited to,
        small print, reliance on small and high-resolution images, and no affordances
        for people with vision impairments.
      </p>

      <p>
        When utilizing this data model to create [=verifiable credentials=], it is
        suggested that data model designers use a <em>data first</em> approach. For
        example, given the choice of using data or a graphical image to depict a
        [=credential=], designers should express every element of the image, such as
        the name of an institution or the professional [=credential=], in a
        machine-readable way instead of relying on a viewer's interpretation of the
        image to convey this information. Using a data first approach is preferred
        because it provides the foundational elements of building different interfaces
        for people with varying abilities.
      </p>
    </section>
  </section>

  <section class="informative">
    <h2>Internationalization Considerations</h2>

    <p>
      Implementers are advised to be aware of a number of internationalization
      considerations when publishing data described in this specification.
      As with any web standards or protocols implementation, ignoring
      internationalization makes it difficult for data to be produced and consumed
      across a disparate set of languages and societies, which limits the
      applicability of the specification and significantly diminishes its value as a
      standard.
    </p>

    <p>
      Implementers are strongly advised to read the
      <em>Strings on the Web: Language and Direction Metadata</em> document
      [[STRING-META]], published by the W3C Internationalization Activity, which
      elaborates on the need to provide reliable metadata about text to support
      internationalization. For the latest information on internationalization
      considerations, implementers are also urged to read the Verifiable Credentials
      Implementation Guidelines [[VC-IMP-GUIDE]] document.
    </p>

    <p>
      This section outlines general internationalization considerations to take into
      account when utilizing this data model and is intended to highlight specific
      parts of the <em>Strings on the Web: Language and Direction Metadata</em>
      document [[STRING-META]] that implementers might be interested in reading.
    </p>

    <section>
      <h3>Language and Base Direction</h3>

      <p>
        Data publishers are strongly encouraged to read the section on
        Cross-Syntax Expression in the <em>Strings on the Web: Language and Direction
          Metadata</em> document [[STRING-META]] to ensure that the expression of
        language and <dfn data-cite="i18n-glossary">base direction</dfn> information is
        possible across multiple expression syntaxes, such as [[JSON-LD11]], [[JSON]],
        and CBOR [[?RFC7049]].
      </p>

      <p>
        The general design pattern is to use the following markup template when
        expressing a text string that is tagged with a language and, optionally, a
        specific base direction.
      </p>

      <pre class="example nohighlight" title="Design pattern for natural language strings">
"myProperty": {
  "@value": "<span class="highlight">The string value</span>",
  "@language": "LANGUAGE"
  "@direction": "DIRECTION"
}
        </pre>

      <p>
        When the language value object is used in place of a string value, the object
        MUST contain a `@value` property whose value is a string, and SHOULD contain a
        `@language` property whose value is a string containing a well-formed
        `Language-Tag` as defined by [[BCP47]], and MAY contain a `@direction` property
        whose value is a [=base direction=] string defined by the `@direction`
        attribute in [[JSON-LD11]]. The language value object MUST NOT include any other
        keys beyond `@value`, `@language`, and `@direction`.
      </p>

      <p>
        Using the design pattern above, the following example expresses the title of a
        book in the English language without specifying a text direction.
      </p>

      <pre class="example nohighlight" title="Expressing natural language text as English">
"title": {
  "@value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
  "@language": "en"
}
        </pre>

      <p>
        The next example uses a similar title expressed in the Arabic language with a
        base direction of right-to-left.
      </p>

      <pre class="example nohighlight" title="Arabic text with a base direction of right-to-left">
"title": {
  "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
  "@language": "ar",
  "@direction": "rtl"
}
        </pre>

      <p class="note">
        The text above would most likely be rendered incorrectly as left-to-right
        without the explicit expression of language and direction because many systems
        use the first character of a text string to determine its [=base direction=].
      </p>

      <p>
        Multiple language value objects MAY be provided as an array value for the
        property:
      </p>

      <pre class="example nohighlight" title="Multiple language texts provided for title">
"title": [
  {
    "@value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
    "@language": "en"
  },
  {
    "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
    "@language": "ar",
    "@direction": "rtl"
  }
]
        </pre>
    </section>

    <section class="substantive">
      <h3>Providing Default Language and Direction</h3>

      <p>
        The language and base direction of each natural language string property value
        SHOULD be provided, either via the language value structure for each property
        value, or via a default language and base direction for all values in the entire
        credential. Using the per-value language value structure is preferred, because
        using document defaults can result in a requirement that downstream processors
        perform JSON-LD expansion-based transformation which is otherwise optional. See
        the <a data-cite="JSON-LD11#string-internationalization">
          String Internationalization</a> section of the [[JSON-LD11]] specification for
        more information. Natural language string values that do not have a language
        associated with them SHOULD be treated as if the language value is `undefined`
        (language tag "`und`"). Natural language string values that do not have a base
        direction associated with them SHOULD be treated as if the direction value is
        "`auto`".
      </p>
    </section>

    <section class="informative">
      <h3>Complex Language Markup</h3>

      <p>
        When a single natural language string contains multiple languages or
        annotations, the contents of the string might require additional structure or
        markup in order to be presented correctly. It is possible to use markup
        languages, such as HTML, to label spans of text in different languages or to
        supply string-internal markup needed for proper display of [=bidirectional
        text=]. It is also possible to use the `rdf:HTML` datatype to
        encode such values accurately in JSON-LD.
      </p>

      <p>
        Despite the ability to encode information as HTML, implementers are strongly
        discouraged from doing this because it:
      </p>

      <ul>
        <li>
          Requires some version of an HTML processor, which increases the burden of
          processing language and base direction information.
        </li>
        <li>
          Increases the security attack surface when utilizing this data model because
          blindly processing HTML could result in executing a `script` tag that
          an attacker injected at some point during the data production process.
        </li>
      </ul>

      <p>
        If implementers feel they must use HTML, or other markup languages capable of
        containing executable scripts, to address a specific use case, they are advised
        to analyze how an attacker would use the markup to mount injection attacks
        against a consumer of the markup and then deploy mitigations against the
        identified attacks.
      </p>
    </section>

  </section>

  <section class="appendix informative">
    <h2>Validation</h2>

    <p>
      While this specification does not provide conformance criteria for the process
      of the [=validation=] of [=verifiable credentials=] or
      [=verifiable presentations=], readers might be curious about how the
      information in this data model is expected to be utilized by [=verifiers=]
      during the process of [=validation=]. This section captures a selection of
      conversations held by the Working Group related to the expected usage of the
      data fields in this specification by [=verifiers=].
    </p>

    <section class="informative">
      <h3>Credential Type</h3>

      <p>
        When a [=verifier=] requests one or more [=verifiable credentials=]
        from a [=holder=], they can specify the type of credential(s) that they would
        like to receive. The type of a credential is expressed via the
        <a href="#types">type</a> property. A [=verifiable credential=] of a specific
        type is expected to contain specific [=properties=] that can be used to
        determine whether or not the [=presentation=] meets a set of processing rules
        that the [=verifier=] is executing. By requesting
        [=verifiable credentials=] of a particular `type`, the
        [=verifier=] is able to gather specific information from the [=holder=],
        which originated with the [=issuer=] of each [=verifiable credential=],
        that will enable it to determine the next stage of an interaction with a
        [=holder=].
      </p>
    </section>

    <section class="informative">
      <h3>Credential Subject</h3>

      <p>
        In the [=verifiable credentials=] presented by a [=holder=], the value
        associated with the `id` [=property=] for each
        `credentialSubject` is expected to identify a [=subject=] to the
        [=verifier=]. If the [=holder=] is also the [=subject=], then
        the [=verifier=] could authenticate the [=holder=] if they have
        [=verification=] metadata related to the [=holder=]. The [=verifier=]
        could then authenticate the [=holder=] using a signature generated by the [=holder=]
        contained in the [=verifiable presentation=]. The `id`
        [=property=] is optional. [=Verifiers=] could use other [=properties=]
        in a [=verifiable credential=] to uniquely identify a [=subject=].
      </p>

      <p class="note">
        For information on how authentication and WebAuthn might work with
        [=verifiable credentials=], see the Verifiable Credentials Implementation
        Guidelines [[VC-IMP-GUIDE]] document.
      </p>

    </section>

    <section class="informative">
      <h3>Issuer</h3>

      <p>
        The value associated with the `issuer` [=property=] is expected
        to identify an [=issuer=] that is known to and trusted by the
        [=verifier=].
      </p>

      <p>
        Metadata related to the `issuer` [=property=] is available to the
        [=verifier=] through the <a href="#verification">verification
          algorithm</a> as defined in Section <a href="#verification"></a>.
        This metadata includes identification of the verified controller of the
        verification method used by the securing mechanism to secure each [=verifiable
        credential=] or [=verifiable presentation=], of which the controller is
        typically the respective `issuer` or `holder`.
      </p>

      <p>
        Some ecosystems might have more complex relationships between [=issuers=]
        and controllers of verification methods and might use lists of verified
        issuers in addition to, or instead of, the mapping described above.
      </p>
    </section>

    <section class="informative">
      <h4>Holder</h4>
      <p>
        The value associated with the `holder` [=property=] is expected
        to be usable to identify the [=holder=] to the [=verifier=].
      </p>
      <p>
        Often relevant metadata about the [=holder=], as identified by the value of
        the `holder` [=property=], is available to, or retrievable by, the
        [=verifier=]. For example, a [=holder=] can publish information containing
        the [=verification material=] used to secure [=verifiable presentations=]. This
        metadata is expected to be used when checking proofs on [=verifiable presentations=].
        Some cryptographic identifiers contain all necessary metadata in the identifier itself.
        In those cases, no additional metadata is required. Other identifiers use verifiable data
        registries where such metadata is automatically published for use by
        [=verifiers=], without any additional action by the [=holder=].
      </p>
      <p>
        See the <a data-cite="VC-IMP-GUIDE/#subject-holder-relationships"></a> and
        <a data-cite="VC-USE-CASES#user-tasks"></a> for additional examples related to
        [=subject=] and [=holder=].
      </p>

      <p class="note">
        Validation is the process by which verifiers apply business rules to
        evaluate the propriety of a particular use of a [=verifiable credential=].
      </p>
      <ul>
        <li>
        </li>
      </ul>
      <p>
        A [=verifier=] might need to validate a given [=verifiable presentation=]
        against complex business rules; for example, the verifier might need confidence
        that the [=holder=] is the same entity as a [=subject=] of a [=verifiable
        credential=]. In such a situation, the following factors can provide a
        [=verifier=] with reasonable confidence that the claims expressed regarding
        that identifier, in included [=verifiable credentials=], are, in fact, about
        the current presenter:
      </p>
      <ul>
        <li>
          The [=verifiable presentation=] is secured, using a mechanism the
          [=verifier=] trusts to protect the integrity of the content.
        </li>
        <li>
          The [=verifiable presentation=] includes one or more [=verifiable
          credentials=] that are secured, using a mechanism the [=verifier=] trusts
          to protect the integrity of the content.
        </li>
        <li>
          The identifier in the `holder` property of the [=verifiable presentation=]
          and at least one identifier property of at least one object in the
          `credentialSubject` array are the same.
        </li>
        <li>
          That common identifier can be used to discover or derive the verification
          material used to verify the integrity of that [=verifiable presentation=].
        </li>
      </ul>
    </section>

    <section class="informative">
      <h3>Issuance Date</h3>

      <p>
        The `validFrom` is expected to be within an expected range for the
        [=verifier=]. For example, a [=verifier=] can check that the start of
        the validity period for a [=verifiable credential=] is not in the future.
      </p>
    </section>

    <section class="informative">
      <h3>Proofs (Signatures)</h3>

      <p>
        The cryptographic mechanism used to prove that the information in a
        [=verifiable credential=] or [=verifiable presentation=] was not tampered
        with is called a <em>proof</em>. There are many types of cryptographic proofs
        including, but not limited to, digital signatures and zero-knowledge proofs. In
        general, when verifying proofs, implementations are expected to ensure:
      </p>

      <ul>
        <li>
          The proof is available in the form of a known proof suite.
        </li>
        <li>
          All required proof suite [=properties=] are present.
        </li>
        <li>
          The proof suite [=verification=] algorithm, when applied to the data, results
          in an acceptable proof.
        </li>
      </ul>

      <p>
        Some proofs are digital signatures. In general, when verifying digital
        signatures, implementations are expected to ensure:
      </p>

      <ul>
        <li>
          Acceptably recent metadata regarding the [=verification material=] associated
          with the signature is available. For example, the metadata might include
          [=properties=] related to validity periods, key owner, or key purpose.
        </li>
        <li>
          The key is not suspended, revoked, or expired.
        </li>
        <li>
          The cryptographic signature is expected to verify.
        </li>
        <li>
          Any additional requirements defined by the securing mechanism are satisfied.
        </li>
      </ul>

      <p class="note">
        The digital signature provides a number of protections, other than tamper
        resistance, which are not immediately obvious. For example, a Linked Data
        Signature `created` [=property=] establishes a date and time
        before which the [=credential=] should not be considered [=verified=],
        distinct from the validity period of the credential. This property describes the
        validity of the proof, not of the credential.
        The JWT `iat` claim likewise provides the time that the signature was made.
        <br /><br />
        The `verificationMethod` [=property=] specifies, for example, the
        public key that can be used to verify the digital signature. Dereferencing a
        public key URL reveals information about the controller of the key, which can
        be checked against the issuer of the [=credential=]. The
        `proofPurpose` [=property=] clearly expresses the purpose for
        the proof and ensures this information is protected by the signature. A proof is
        typically attached to a [=verifiable presentation=] for authentication
        purposes and to a [=verifiable credential=] as a method of assertion.
      </p>
    </section>

    <section class="informative">
      <h3>Validity Periods</h3>

      <p>
        The [=verifier=] expects that the `validFrom` and
        `validUntil` properties will be within a certain range. For example,
        a [=verifier=] can check that the end of the validity period of a
        [=verifiable credential=] is not in the past. Because some credentials can be
        useful for secondary purposes even if their original validity period has
        expired, validity period, as expressed using the `validFrom` and
        `validUntil` properties, is always considered a component of
        validation, which is performed <em>after</em> verification.
      </p>
    </section>

    <section class="informative">
      <h3>Status</h3>

      <p>
        If the `credentialStatus` property is available, the status of a
        [=verifiable credential=] is expected to be evaluated by the [=verifier=]
        according to the `credentialStatus` [=type=] definition for the
        [=verifiable credential=] and the [=verifier's=] own status evaluation
        criteria. For example, a [=verifier=] can ensure the status of the
        [=verifiable credential=] is not "withdrawn for cause by the [=issuer=]".
      </p>
    </section>

    <section class="informative">
      <h3>Schema</h3>

      <p>
        If the `credentialSchema` property is available, the schema of a
        [=verifiable credential=] is expected to be evaluated by the [=verifier=]
        according to the `credentialSchema` [=type=] definition for the
        [=verifiable credential=] and the [=verifier's=] own schema evaluation
        criteria. For example, if the `credentialSchema`'s `type`
        value is [[?VC-JSON-SCHEMA]], then a [=verifier=] can ensure a credential's
        data is valid against the given JSON Schema.
      </p>
    </section>

    <section class="informative">
      <h3>Fitness for Purpose</h3>

      <p>
        Fitness for purpose is about whether the custom [=properties=] in the
        [=verifiable credential=] are appropriate for the [=verifier's=] purpose.
        For example, if a [=verifier=] needs to determine whether a [=subject=] is
        older than 21 years of age, they might rely on a specific `birthdate`
        [=property=], or on more abstract [=properties=], such as
        `ageOver`.
      </p>

      <p>
        The [=issuer=] is trusted by the [=verifier=] to make the [=claims=] at
        hand. For example, a franchised fast food restaurant location trusts the
        discount coupon [=claims=] made by the corporate headquarters of the
        franchise. Policy information expressed by the [=issuer=] in the
        [=verifiable credential=] should be respected by [=holders=] and
        [=verifiers=] unless they accept the liability of ignoring the policy.
      </p>
    </section>
  </section>

  <section class="appendix">
    <h2>Contexts, Vocabularies, Types, and Credential Schemas</h2>

    <section class="normative">
      <h3>Base Context</h3>

      <p class="issue" title="(AT RISK) Hash values might change during Candidate Recommendation">
        This section lists cryptographic hash values that might change during the
        Candidate Recommendation phase based on implementer feedback that requires
        the referenced files to be modified.
        <br><br>
        The Working Group is expecting all of the terms and URLs supplied in the
        JSON-LD Context to be either stabilized, or removed, before the publication of
        this specification as a Proposed Recommendation. While that means that this
        specification could be delayed if dependencies such as [[?VC-DATA-INTEGRITY]],
        [[?VC-JOSE-COSE]], SD-JWT, [[?VC-JSON-SCHEMA]], or status list
        do not enter the Proposed Recommendation phase around the same time frame, the
        Working Group is prepared to remove the dependencies if an undue burden is
        placed on transitioning to the Recommendation phase. This is a calculated
        risk that the Working Group is taking and has a mitigation strategy in place
        to ensure the timely transition of this specification to a Recommendation.
      </p>
      <p>
        Implementations MUST treat the base context value, located at
        `https://www.w3.org/ns/credentials/v2`, as already retrieved;
        the following value is the SHA-384 digest of the resource
        computed and encoded according to the [[SRI]] definition of `digest`:
        <strong>`vxRgTREj3/ZmDabpiTX+Au4UXY8GDhyCSFNw+UQtdtISDyO/znDUY+FTg8rNsGXJ`</strong>.
        It is strongly advised that all JSON-LD Context URLs used by an
        application utilize the same mechanism, or a functionally equivalent mechanism,
        to ensure end-to-end security. Implementations are expected to throw errors
        if a cryptographic hash value for a resource does not match the expected hash
        value.
      </p>
      <p>
        Implementations that apply the base context above, as well as other contexts
        and values in any `@context` property, during operations such as
        <a href="https://www.w3.org/TR/json-ld11-api/#expansion-algorithm">
          JSON-LD Expansion</a> or
        <a href="https://www.w3.org/TR/json-ld11/#serializing-deserializing-rdf">
          transformation to RDF</a>, are expected to do so without experiencing any
        errors. If such operations are performed and result in an error,
        the [=verifiable credential=] or [=verifiable presentation=] MUST result
        in a verification failure.
      </p>
      <p>
        It is possible to confirm the SHA-384 digest above by running the following
        command from a modern Unix command interface line:
        `curl -s https://www.w3.org/ns/credentials/v2 | openssl dgst -sha384 -binary | openssl base64 -A`
      </p>
      <p>
        More details regarding this hash encoding method can be found in the <a
          href="https://www.w3.org/TR/SRI/#integrity-metadata">integrity metadata</a>
        section of [[SRI]].
      </p>
      <p class="note" title="See errata if hash value changes are detected">
        It is extremely unlikely that the files that have associated cryptographic hash
        values in this specification will change. However, if critical errata are
        found in the specification and corrections are required to ensure
        ecosystem stability the cryptographic hash values might change. As such, the
        HTTP cache times for the files are not set to infinity and implementers are
        advised to check for errata if a cryptographic hash value change is detected.
      </p>
      <p>
        This section serves as a reminder of the importance of ensuring that, when
        verifying [=verifiable credentials=] and [=verifiable presentations=], the
        [=verifier=] has information that is consistent with what the [=issuer=]
        or [=holder=] had when securing the [=credential=] or [=presentation=].
        This information might include at least:
      </p>
      <ol>
        <li>
          The contents of the credential itself, which is secured in
          [=verifiable credentials=] and [=verifiable presentations=] by using
          mechanisms such as [[VC-JOSE-COSE]] and [[VC-DATA-INTEGRITY]].
        </li>
        <li>
          The content in a credential whose meaning depends on a link to an external URL,
          such as a JSON-LD Context, which can be secured by using a local static copy
          or a cryptographic digest of the file.
        </li>
      </ol>
      <p>
        Verifiers are warned that other data that is referenced from within a
        credential, such as resources that are linked to via URLs, are not
        cryptographically protected by default. It is considered a best practice to
        ensure that the same sorts of protections are provided for any URL that is
        critical to the security of the [=verifiable credential=] through the use of
        permanently cached files and/or cryptographic hashes. See the
        <a data-cite="?vc-imp-guide/#content-integrity">Content Integrity</a>
        section of the Verifiable Credential Implementation Guide for further
        information. Ultimately, knowing the cryptographic digest of any linked external
        content enables a [=verifier=] to confirm that the content is the same
        as what the [=issuer=] or [=holder=] intended.
      </p>
    </section>

    <section class="normative">
      <h3>词汇表</h3>

      <p class="issue" title="(有风险) URL 值可能在候选推荐阶段发生变化">
        本节列出了在候选推荐阶段可能发生变化的 URL 值，这取决于将文档迁移到时间戳位置、将文档迁移到 W3C 技术报告命名空间以及需要修改引用的 URL 的实施者反馈。
      </p>

      <p>
        依赖 RDF 词汇处理的实现必须确保基本上解析到以下文件的词汇 URL，这些文件是规范的。实现可以使用其他语义等效的词汇文件的序列化。为了确保开发人员可以验证每个文件的内容是否正确，提供了所有内容的加密哈希。
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>URL and Media Type</th>
            <th>Content and Hashes</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              https://www.w3.org/2018/credentials#<br>
              `application/ld+json`
            </td>
            <td>
              https://www.w3.org/2018/credentials/index.jsonld<br><br>
              sha256: `z52TgKqh2nqTCuACI8lCvhRdjwxQjeVmuOMCDCEijq4=`<br><br>
              sha3-512: `m8Ss+jgZiyL2Ws/ICJcWjHFd9PccJWsXPvMatBOhrH<wbr>
h0qCBrzfgO2zO1OQQbTL7zoPgLseIbcxJJpunD2bkoRA==`
            </td>
          </tr>
          <tr>
            <td>
              https://w3id.org/security#<br>
              `application/ld+json`
            </td>
            <td>
              https://w3c.github.io/vc-data-integrity/vocab/security/vocabulary.jsonld<br><br>
              sha256: `LEaoTyf796eTaSlYWjfPe3Yb+poCW9TjWYTbFDmC0tc=`<br><br>
              sha3-512: `f4DhJ3xhT8nT+GZ8UUZi4QC+HT//wXE2fRTgUP4UNw<wbr>
e4kvel2PFfd6jcofHBm9BjwEiGzVFGv4K+fFTKXRD2NA==`
            </td>
          </tr>
        </tbody>
      </table>

      <p>
        可以通过在现代Unix命令界面中运行以下命令来确认上述加密摘要：
        `curl -sL -H "Accept: &lt;MEDIA_TYPE>" &lt;DOCUMENT_URL> | openssl dgst -&ltDIGEST_ALGORITHM> -binary | openssl
        base64 -nopad -a`
      </p>

      <p class="note" title="schema.org定期更改，但被认为是稳定的">
        实施者和文档作者可能注意到，`schema.org`的加密摘要未提供。这是因为`schema.org`词汇经常更改；任何提供的摘要在发布几周后就会过时。工作组讨论了这个问题，并得出结论，本规范使用的`schema.org`词汇的语义含义多年来一直稳定，并且极不可能发生变化。
      </p>

      <p>
        本规范为处理器和其他受益于此类定义的规范定义了以下基类：
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th>Base Class</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr id="bc-credential-evidence">
            <td>
              `CredentialEvidence`
            </td>
            <td>
              Serves as a superclass for specific evidence types that are placed into the
              <a href="#evidence">evidence</a> property. <span class="issue atrisk">This
                superclass is at risk and will be removed if at least two independent
                implementations for the superclass are not identified by the end of the
                Candidate Recommendation phase.</span>
            </td>
          </tr>
          <tr id="bc-credential-schema">
            <td>
              `CredentialSchema`
            </td>
            <td>
              Serves as a superclass for specific schema types that are placed into the
              <a href="#data-schemas">credentialSchema</a> property.
            </td>
          </tr>
          <tr id="bc-credential-status">
            <td>
              `CredentialStatus`
            </td>
            <td>
              Serves as a superclass for specific credential status types that are placed into
              the <a href="#status">credentialStatus</a> property.
            </td>
          </tr>
          <tr id="bc-confidence-method">
            <td>
              `ConfidenceMethod`
            </td>
            <td>
              Serves as a superclass for specific confidence method types that are placed into
              the `confidenceMethod` property.
              <span class="issue atrisk">This superclass is at risk and will be removed if
                at least two independent implementations for the superclass are not identified
                by the end of the Candidate Recommendation phase.
              </span>
            </td>
          </tr>
          <tr id="bc-refresh-service">
            <td>
              `RefreshService`
            </td>
            <td>
              Serves as a superclass for specific refresh service types that are placed into
              the <a href="#refreshing">credentialRefresh</a> property.
              <span class="issue atrisk">This superclass is at risk and will be removed if
                at least two independent implementations for the superclass are not identified
                by the end of the Candidate Recommendation phase.
              </span>
            </td>
          </tr>
          <tr id="bc-render-method">
            <td>
              `RenderMethod`
            </td>
            <td>
              Serves as a superclass for specific render method types that are placed into
              the `renderMethod` property.
              <span class="issue atrisk">This superclass is at risk and will be removed if
                at least two independent implementations for the superclass are not identified
                by the end of the Candidate Recommendation phase.
              </span>
            </td>
          </tr>
          <tr id="bc-terms-of-use">
            <td>
              `TermsOfUse`
            </td>
            <td>
              Serves as a superclass for specific terms of use types that are placed into
              the <a href="#terms-of-use">termsOfUse</a> property.
              <span class="issue atrisk">This superclass is at risk and will be removed if
                at least two independent implementations for the superclass are not identified
                by the end of the Candidate Recommendation phase.
              </span>
            </td>
          </tr>
        </tbody>
      </table>

    </section>

    <section>
      <h3>数据类型</h3>
      <p>
        本节定义了该规范使用的数据类型。
      </p>

      <section>
        <h4>`sriString` 数据类型</h4>

        <p>
          字符串使用[[SRI]]规范中指定的方法为资源提供完整性信息。
        </p>

        <p>
          `sriString` 数据类型定义如下：
        </p>

        <dl>
          <dt>表示此数据类型的URL</dt>
          <dd>`https://www.w3.org/2018/credentials#sriString`</dd>
          <dt>词法空间</dt>
          <dd>
            请参阅[[SRI]]规范中定义的`integrity`属性的<a href="https://www.w3.org/TR/SRI/#the-integrity-attribute">ABNF
              语法</a>，了解字符串格式的限制。
          </dd>
          <dt>值空间</dt>
          <dd>
            一个（可能为空的）<i>(alg,val)</i>对列表，其中<i>alg</i>标识哈希函数，<i>val</i>是标准数学概念中的整数。
          </dd>
          <dt>词法到值的映射</dt>
          <dd>
            通过根据[[SRI]]规范中的<a href="https://www.w3.org/TR/SRI/#parse-metadata">解析元数据算法</a>和<a
              href="https://www.w3.org/TR/SRI/#the-integrity-attribute">ABNF
              语法</a>，将词法空间中的任何元素映射到值空间。
          </dd>
          <dt>规范映射</dt>
          <dd>
            规范映射包括词法到值的映射。
          </dd>
        </dl>
      </section>


    </section>

    <section class="informative">
      <h3>上下文、类型和凭证模式的区别</h3>

      <p>
        [=可验证凭证=]和[=可验证展示=]数据模型利用了包括[[JSON-LD11]]和[[?VC-JSON-SCHEMA]]在内的各种底层技术。本节将对`@context`、`type`和`credentialSchema`属性进行比较，并介绍一些更具体的使用情况，其中可以使用数据模型的这些特性。
      </p>

      <p>
        `type`属性用于唯一标识出现在其中的[=可验证凭证=]的类型，即指示[=可验证凭证=]包含的声明集合。该属性及其值集合中的`VerifiableCredential`值是强制性的。虽然在数组中包含一个额外的值来描述该[=可验证凭证=]的唯一子类型是良好的实践，但可以省略或包含其他类型值。许多验证者将请求特定子类型的[=可验证凭证=]，因此省略子类型值可能会使验证者更难告知持有者他们需要哪个[=可验证凭证=]。当一个[=可验证凭证=]具有多个子类型时，在`type`属性中列出所有子类型是明智的。在[=可验证凭证=]的[[JSON-LD11]]表示中使用`type`属性可以强制执行[=可验证凭证=]的语义，因为机器能够检查语义。在[[JSON-LD11]]中，技术不仅描述了声明集合的分类，还传达了图中属性子图的结构和语义。在[[JSON-LD11]]中，这表示图中节点的类型，这就是为什么一些[=可验证凭证=]的[[JSON-LD11]]表示将在许多对象上使用`type`属性的原因。
      </p>

      <p>
        `@context`属性的主要目的是以[[JSON-LD11]]的视角传达数据的含义和数据的术语定义，以机器可读的方式。`@context`属性用于将[=可验证凭证=]和[=可验证展示=]中属性的全局唯一URL映射为短形式的别名，使[[JSON-LD11]]表示更易于阅读。从[[JSON-LD11]]的视角来看，这种映射还允许在一个机器可读数据图中对[=可验证凭证=]或[=可验证展示=]中的数据进行建模，通过增强[=可验证凭证=]或[=可验证展示=]中的数据与更大的机器可读数据图的关系。这对于告诉机器如何将数据的含义与无法协调的各方的其他数据相关联非常有用。这个属性的第一个值是`https://www.w3.org/ns/credentials/v2`，是强制性的。
      </p>

      <p>
        由于`@context`属性用于将数据映射到图数据模型中，而[[JSON-LD11]]中的`type`属性用于描述图中的节点，当同时使用这两个属性时，`type`属性变得更加重要。例如，如果在使用[[JSON-LD11]]解析的`@context`资源中不包含`type`属性，可能会导致声明被丢弃和/或其完整性在[=可验证凭证=]的生成和消费过程中不再受到保护。或者，在[=可验证凭证=]的生成或消费过程中可能会引发错误。这将取决于实现的设计选择，今天的实现中都使用了这两种路径，因此在使用[=可验证凭证=]或[=可验证展示=]的[[JSON-LD11]]表示时，注意这些属性非常重要。
      </p>

      <p>
        `credentialSchema`属性的主要目的是定义[=可验证凭证=]的结构以及每个属性值的数据类型。`credentialSchema`对于定义[=可验证凭证=]中一组声明的内容和结构非常有用，而[[JSON-LD11]]和[=可验证凭证=]中的`@context`最好只用于传达数据的语义和术语定义，并且也可以用于定义[=可验证凭证=]的结构。
      </p>

      <p>
        虽然可以使用一些[[JSON-LD11]]的特性来暗示[=可验证凭证=]的内容，但通常不建议使用`@context`来限制数据模型的数据类型。例如，`"@type":
        "@json"`对于保持语义开放和不严格定义是有用的。如果实现者希望限制[=凭证=]中声明的数据类型，并且不希望使用该属性，这可能是危险的。
      </p>

      <p>
        当`credentialSchema`和`@context`属性结合使用时，生产者和消费者都可以更加确信[=可验证凭证=]和[=可验证展示=]的预期内容和数据类型。
      </p>
    </section>
  </section>

  <section class="appendix informative">
    <h2>IANA注意事项</h2>

    <p>
      本节将提交给互联网工程指导组（IESG）进行审查、批准，并在IANA注册。
    </p>

    <section id="vc-ld-media-type">
      <h2>application/vc+ld+json</h2>
      <p>
        本规范专门为识别符合可验证凭证格式的文档注册了`application/vc+ld+json`媒体类型。
      </p>
      <table>
        <tr>
          <td>类型名称：</td>
          <td>应用程序</td>
        </tr>
        <tr>
          <td>子类型名称：</td>
          <td>vc+ld+json</td>
        </tr>
        <tr>
          <td>必需参数：</td>
          <td>无</td>
        </tr>
        <tr>
          <td>编码注意事项：</td>
          <td>
            使用"`application/vc+ld+json`"媒体类型的资源
            必须符合所有"`application/ld+json`"媒体类型的要求，因此受到[[RFC7159]]第11节中指定的相同编码注意事项的约束。
          </td>
        </tr>
        <tr>
          <td>安全性考虑：</td>
          <td>按照本规范定义。</td>
        </tr>
        <tr>
          <td>联系方式：</td>
          <td>
            W3C 可验证凭证工作组
            <a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
          </td>
        </tr>
      </table>

      <p>
        请注意，虽然可验证凭证格式使用了JSON-LD约定，
        但是对于可验证凭证实现有一些约束和额外要求，这就证明了使用特定媒体类型的必要性。
      </p>

      <p>
        这种媒体类型可以用于使用[=封装证明=]保护的凭证。
      </p>
      <p>
        期望在文档的主体中存在一个[[JSON-LD11]]上下文，并且如媒体类型中的`ld+json`所示，期望凭证是一个有效的
        <a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document">JSON-LD
          文档</a>。
      </p>
    </section>

    <section id="vp-ld-media-type">
      <h2>application/vp+ld+json</h2>
      <p>
        本规范专门为符合可验证呈现格式的文档注册了`application/vp+ld+json`媒体类型。
      </p>
      <table>
        <tr>
          <td>类型名称：</td>
          <td>application</td>
        </tr>
        <tr>
          <td>子类型名称：</td>
          <td>vp+ld+json</td>
        </tr>
        <tr>
          <td>必需参数：</td>
          <td>无</td>
        </tr>
        <tr>
          <td>编码注意事项：</td>
          <td>
            使用"`application/vp+ld+json`"媒体类型的资源需要遵守
            "`application/ld+json`"媒体类型的所有要求，因此需要遵循[[RFC7159]]第11节中规定的相同编码注意事项。
          </td>
        </tr>
        <tr>
          <td>安全注意事项：</td>
          <td>按照本规范定义。</td>
        </tr>
        <tr>
          <td>联系方式：</td>
          <td>
            W3C 可验证凭证工作组
            <a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
          </td>
        </tr>
      </table>

      <p>
        请注意，虽然可验证凭证格式使用 JSON-LD 约定，但可验证凭证实现有许多限制和额外要求，这些限制和要求足以证明使用特定媒体类型是合理的。
      </p>

      <p>
        该媒体类型可用于使用[=enveloping proof=]保护的演示文稿。
      </p>
      <p>
        预计文档正文中会存在一个[[JSON-LD11]]上下文，并且如媒体类型中的`ld+json`所示，凭证预计将是一个有效的
        <a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document">JSON-LD
          文档</a>。
      </p>
    </section>

  </section>

  <section class="appendix informative">
    <h2>Additional Diagrams for Verifiable Presentations</h2>

    <p>
      <a href="#info-graph-vp-mult-creds"></a> below is a variant of <a href="#info-graph-vp"></a>:
      a [=verifiable presentation=] referring to two [=verifiable credentials=], and using [=embedded proofs=]
      based on [[?VC-DATA-INTEGRITY]].
      Each [=verifiable credential graph=] is connected to
      its own separate [=proof graph=]; the `verifiableCredential` property is used
      to connect the [=verifiable presentation=] to the [=verifiable credential graphs=].
      The [=presentation=] [=proof graph=] represents the digital signature of the [=verifiable presentation graph=],
      both [=verifiable credential graphs=], and the [=proof graphs=] linked from the [=verifiable credential graphs=].
      The complete [=verifiable presentation=]
      consists, in this case, of six information [=graphs=].
    </p>

    <figure id="info-graph-vp-mult-creds">
      <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-graph-mult-creds.svg" alt="
Diagram with a 'verifiable presentation graph' on top, connected via a
'proof' to a 'verifiable presentation proof graph' on the bottom. The
verifiable presentation graph has an object, 'Presentation ABC', with 3
properties: 'type' with value 'VerifiablePresentation'; 'termsOfUse' with
value 'Do Not Archive'; and two instances of 'verifiableCredential',
detailed below. This graph is annotated with a parenthetical remark, '(the
default graph)'. This graph is connected, through 'verifiableCredential',
to the part of the figure that consists two variants of Figure 6 (one is
identical; the other has minor differences in the labels referring to
validity dates, the name of the person, and the values for the nonce and
the signature), except that these verifiable credential graphs are
annotated to be named graphs instead of a default graph. The verifiable
presentation proof graph has an object labeled 'Signature 8920' with 5
properties: 'type' with value 'DataIntegrityProof'; 'verificationMethod'
with value 'Example Presenter Public Key 11'; 'created' with value
'2024-01-02T12:43:56Z'; 'nonce' with value 'hasdkyruod87j'; and
'proofValue' with value 'zpewJHoan87='. This graph is annotated with the
parenthetical remark '(a named graph)'
            ">
      <figcaption style="text-align: center;">
        A variant of <a href="#info-graph-vp"></a>: information [=graphs=] associated with a [=verifiable presentation=]
        referring to two
        verifiable credentials, using an [=embedded proof=] based on [[[VC-DATA-INTEGRITY]]] [[?VC-DATA-INTEGRITY]].
      </figcaption>
    </figure>

    <p>
      <a href="#info-graph-vp-jwt-mult-creds"></a> below shows the same [=verifiable presentation=]
      as <a href="#info-graph-vp-mult-creds"></a>, but using an [=enveloping proof=] based on [[?VC-JOSE-COSE]].
      Each [=verifiable credential graph=] contains a single
      <a href="#defn-EnvelopedVerifiableCredential">`EnvelopedVerifiableCredential`</a> instance,
      referring, via a `data:` URL [[RFC2397]], to a verifiable credential secured via
      an [=enveloping proof=]</a>.
    </p>

    <figure id="info-graph-vp-jwt-mult-creds">
      <img style="margin: auto; display: block; width: 100%;" src="diagrams/vp-jwt-mult-creds.svg" alt="
Diagram with, on the left, a box, labeled as 'JWT (Decoded)', and with
three textual labels stacked vertically, namely 'Header', 'Payload', and
'Signature'. The 'Header' label is connected, with an arrow, to a
separate rectangle on the right hand side containing six text fields:
'kid: aB8J-_Z', 'alg: ES384', and 'cty: vc+ld+json', iss:
https://example.com, iat: 1704690029, and typ: vp+ld+json+sd-jwt The
'Payload' label of the left side is connected, with an arrow, to a
separate rectangle, consisting of three related graphs (stacked
vertically) connected by two arrows labeled 'verifiableCredential'
starting from the top graph and connecting it to the two other graphs,
respectively. The top graph has a label 'verifiable presentation graph
(serialized in JSON)'; the other two are both labeled by 'verifiable
credential graph (serialized in JSON)'. The top graph in the rectangle
has and object 'Presentation ABC' with 3 properties: 'type' of value
VerifiablePresentation, 'termsOfUse' of value 'Do Not Archive'. One of
the the bottom graphs includes
'data:application/vc+ld+json+sd-jwt;QzVjV...RMjU' as a subject with a
single property: 'type' of value `EnvelopedVerifiableCredential`. The
last bottom graph is identical other, except for the subject which is
labeled as 'data:application/vc+ld+json+sd-jwt;RkOyT...KjOl'. Finally,
the 'Signature' label on the left side is connected, with an arrow, to a
separate rectangle, containing a single text field:
'cYjaSdfIoJH45NIqw3MYnasGIba...'.
        ">
      <figcaption style="text-align: center;">
        A variant of <a href="#info-graph-vp-jwt"></a>: information [=graphs=] associated with a [=verifiable
        presentation=]
        referring to two verifiable credentials using [=enveloping proofs=] based on JOSE [[?VC-JOSE-COSE]].
      </figcaption>
    </figure>


  </section>

  <section>
    <h2>修订历史</h2>

    <p>
      本节包含了此规范随时间所做的实质性更改。
    </p>

    <p>
      自
      <a href="https://www.w3.org/TR/2022/REC-vc-data-model-20220303/">
        v1.1 推荐规范</a>以来的变更：
    </p>
    <ul>
      <li>
        进行了许多编辑更新和修复，以使规范现代化并更容易理解特定概念。
      </li>
      <li>
        在数据完整性和本规范之间删除了关于 `proof` 的重复声明。
      </li>
      <li>
        澄清了发行者验证的过程。
      </li>
      <li>
        澄清了保护机制扩展点的要求。
      </li>
      <li>
        在算法部分添加了对 [[?INFRA]] 的依赖。
      </li>
      <li>
        添加了保护机制规范的要求。
      </li>
      <li>
        澄清了执行特定凭证类型处理的方法。
      </li>
      <li>
        添加了在可验证演示中嵌入封装的可验证凭证的机制。
      </li>
      <li>
        添加验证算法、安全机制接口和问题详细信息对象。
      </li>
      <li>
        调整`issuer`属性的允许值。
      </li>
      <li>
        提供更具体的指导，以表达语言信息以及默认语言和方向。
      </li>
      <li>
        为发行者和验证者实现添加新的符合类。
      </li>
      <li>
        添加有关密钥管理的新的安全注意事项。
      </li>
      <li>
        添加有关信任边界、基于元数据的关联、数据盗窃和使用Oblivious HTTP的隐私注意事项。
      </li>
      <li>
        正式定义词汇的基类和属性。
      </li>
      <li>
        提供警告，不要使用高级JSON-LD功能，以最大程度地提高互操作性。
      </li>
      <li>
        提供更明确的指导，涉及集合和数组。
      </li>
      <li>
        为发行者和凭证添加`name`和`description`字段的支持。
      </li>
      <li>
        添加有关拦截、重放和欺骗攻击的安全注意事项。
      </li>
      <li>
        在基本JSON-LD上下文中添加JWT和SD-JWT声明。
      </li>
      <li>
        澄清“凭证”和“可验证凭证”的区别。
      </li>
      <li>
        添加关于如何确保生态系统兼容性的部分。
      </li>
      <li>
        添加关于特定凭证类型处理的部分。
      </li>
      <li>
        添加关于验证和与持有者的相关性的部分。
      </li>
      <li>
        添加关于媒体类型精度和解释的部分。
      </li>
      <li>
        确保使用`dateTimeStamp`作为时间值。提供有关时间值和时区的正确使用的进一步指导。
      </li>
      <li>
        使`validFrom`变为可选。
      </li>
      <li>
        添加`relatedResource`功能。
      </li>
      <li>
        使基本上下文和词汇成为规范，并为其内容提供加密哈希。
      </li>
      <li>
        将`renderMethod`和`confidenceMethod`添加到保留属性列表中。
      </li>
      <li>
        更新规范中的示例。
      </li>
      <li>
        添加“入门指南”部分。
      </li>
      <li>
        添加保留属性的属性表，这些属性尚未标准化或有可能被删除。
      </li>
      <li>
        将数据模型序列化限制为紧凑文档形式的JSON-LD。
      </li>
      <li>
        更新ZKP部分以删除旧内容。
      </li>
      <li>
        在v2上下文中为演示文稿添加`termsOfUse`。
      </li>
      <li>
        在v2上下文中为未定义术语添加默认词汇。
      </li>
      <li>
        添加`application/vc+ld+json`和`application/vp+ld+json`的媒体类型。
      </li>
      <li>
        提供有关如何将符合要求的文档与其他数字凭证格式进行转换的指导。
      </li>
      <li>
        将对URI/IRI的引用更改为使用WHATWG URL规范。
      </li>
      <li>
        在数据完整性和JOSE/COSE安全机制上添加规范依赖。
      </li>
      <li>
        将`issuanceDate`/`expirationDate`重命名为`validFrom`/`validUntil`。
      </li>
      <li>
        添加JSON Schema支持，并更新示例以使用新格式。
      </li>
      <li>
        澄清`credentialSubject`值不能为字符串。
      </li>
      <li>
        创建更正式的词汇文档，引用此规范。
      </li>
      <li>
        定义v2.0 JSON-LD上下文。
      </li>
      <li>
        将VC-JWT部分迁移到单独的安全规范。
      </li>
      <li>
        将主题-持有者关系移至可验证凭证实现指南。
      </li>
      <li>
        将版本号增加到v2.0，并删除之前的REC跟踪评论。
      </li>
      <li>
        在可验证凭证数据完整性规范[[VC-DATA-INTEGRITY]]中添加规范依赖。
      </li>
      <li>
        由于v1.0和v1.1中缺乏实现，删除了关于“争议”的部分。
      </li>
    </ul>

    <p>
      自
      <a href="https://www.w3.org/TR/2019/REC-vc-data-model-20191119/">
        v1.0 推荐</a>以来的变化：
    </p>
    <ul>
      <li>
        添加此修订历史部分。
      </li>

      <li>
        更新先前的规范参考，将指向 RFC3339 的日期时间详细信息改为规范参考 XMLSCHEMA11-2，这更准确地反映了示例和库中的使用情况。
      </li>

      <li>
        放宽要求，允许在数据模型的 `credentialStatus` 和 `refreshService` 部分的 `id` 属性中使用无法解引用的 [=URLs=]。
      </li>

      <li>
        放宽零知识证明部分的规范性陈述，以支持新的零知识证明方案，例如 BBS+，这些方案是在 v1.0 规范作为推荐标准发布之后创建的。
      </li>

      <li>
        更新所有引用，指向所引用规范的最新版本。修复指向已不可用的论文的损坏链接，将其更新为可用论文的新位置。
      </li>

      <li>
        提高 SVG 图表的可访问性。
      </li>

      <li>
        修复一些示例中与 `issuer`、`issuanceDate`、`credentialStatus`、日期、失效链接和次要语法错误相关的编辑错误。
      </li>

      <li>
        将致谢从“文档状态”部分移至致谢附录。
      </li>
    </ul>
  </section>

  <section class="appendix informative">
    <h2>致谢</h2>

    <p>
      工作组感谢以下个人不仅对本文档内容的贡献，还对这个标准社区的辛勤工作，推动了变革、讨论和共识，尽管意见各异：Matt Stone、Gregg Kellogg、Ted Thibodeau Jr、Oliver Terbu、Joe
      Andrieu、David I. Lehn、Matthew Collier和Adrian Gropper。
    </p>

    <p>
      本规范的工作得到了由Christopher Allen、Shannon Appelcline、Kiara Robles、Brian Weller、Betty Dhamers、Kaliya Young、Manu
      Sporny、Drummond Reed、Joe Andrieu、Heather Vescent、Kim Hamilton Duffy、Samantha Chase和Andrew Hughes组织的Rebooting the
      Web of Trust社区的支持。由Phil Windley、Kaliya Young、Doc Searls和Heidi Nobantu Saul组织的Internet Identity
      Workshop的参与者也通过众多工作会议的设计来支持这项工作的完善，旨在教育、辩论和改进本规范。
    </p>

    <p>
      工作组还感谢我们的主席Dan Burnett、Matt Stone、Brent Zundel、Wayne Chang和Kristina Yasuda，以及我们的W3C工作人员联系人Kazuyuki Ashimura和Ivan
      Herman，他们在W3C标准化过程中的专业管理和稳定指导。
    </p>

    <p>
      本规范的部分工作得到了美国国土安全部科学与技术总局根据合同HSHQDC-17-C-00019的资助。本规范的内容不一定反映美国政府的立场或政策，不应推断出任何官方认可。
    </p>

    <p>
      工作组要感谢以下个人对规范进行审查并提供反馈意见（按字母顺序排列）：
    </p>

    <p>
      Christopher Allen, David Ammouial, Joe Andrieu, Bohdan Andriyiv, Ganesh
      Annan, Kazuyuki Ashimura, Tim Bouma, Pelle Braendgaard, Dan Brickley,
      Allen Brown, Jeff Burdges, Daniel Burnett, ckennedy422, David Chadwick,
      Chaoxinhu, Kim (Hamilton) Duffy, Lautaro Dragan, enuoCM, Ken Ebert, Eric
      Elliott, William Entriken, David Ezell, Nathan George, Reto Gmür, Ryan
      Grant, glauserr, Adrian Gropper, Joel Gustafson, Amy Guy, Lovesh
      Harchandani, Daniel Hardman, Dominique Hazael-Massieux, Jonathan Holt,
      David Hyland-Wood, Iso5786, Renato Iannella, Richard Ishida, Ian Jacobs,
      Anil John, Tom Jones, Rieks Joosten, Gregg Kellogg, Kevin, Eric Korb,
      David I. Lehn, Michael Lodder, Dave Longley, Christian Lundkvist, Jim
      Masloski, Pat McBennett, Adam C. Migus, Liam Missin, Alexander Mühle,
      Anthony Nadalin, Clare Nelson, Mircea Nistor, Grant Noble, Darrell
      O'Donnell, Nate Otto, Matt Peterson, Addison Phillips, Eric Prud'hommeaux,
      Liam Quin, Rajesh Rathnam, Drummond Reed, Yancy Ribbens, Justin Richer,
      Evstifeev Roman, RorschachRev, Steven Rowat, Pete Rowley, Markus
      Sabadello, Kristijan Sedlak, Tzviya Seigman, Reza Soltani, Manu Sporny,
      Orie Steele, Matt Stone, Oliver Terbu, Ted Thibodeau Jr, John Tibbetts,
      Mike Varley, Richard Varn, Heather Vescent, Christopher Lemmer Webber,
      Benjamin Young, Kaliya Young, Dmitri Zagidulin, and Brent Zundel.
    </p>
  </section>
</body>

</html>